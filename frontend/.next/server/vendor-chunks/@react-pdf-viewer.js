"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf-viewer";
exports.ids = ["vendor-chunks/@react-pdf-viewer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-pdf-viewer/core/lib/cjs/core.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-pdf-viewer/core/lib/cjs/core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar PdfJsApi = __webpack_require__(/*! pdfjs-dist */ \"(ssr)/./node_modules/pdfjs-dist/build/pdf.js\");\n\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\nvar PdfJsApi__namespace = /*#__PURE__*/_interopNamespaceDefault(PdfJsApi);\n\nexports.AnnotationType = void 0;\n(function (AnnotationType) {\n    AnnotationType[AnnotationType[\"Text\"] = 1] = \"Text\";\n    AnnotationType[AnnotationType[\"Link\"] = 2] = \"Link\";\n    AnnotationType[AnnotationType[\"FreeText\"] = 3] = \"FreeText\";\n    AnnotationType[AnnotationType[\"Line\"] = 4] = \"Line\";\n    AnnotationType[AnnotationType[\"Square\"] = 5] = \"Square\";\n    AnnotationType[AnnotationType[\"Circle\"] = 6] = \"Circle\";\n    AnnotationType[AnnotationType[\"Polygon\"] = 7] = \"Polygon\";\n    AnnotationType[AnnotationType[\"Polyline\"] = 8] = \"Polyline\";\n    AnnotationType[AnnotationType[\"Highlight\"] = 9] = \"Highlight\";\n    AnnotationType[AnnotationType[\"Underline\"] = 10] = \"Underline\";\n    AnnotationType[AnnotationType[\"Squiggly\"] = 11] = \"Squiggly\";\n    AnnotationType[AnnotationType[\"StrikeOut\"] = 12] = \"StrikeOut\";\n    AnnotationType[AnnotationType[\"Stamp\"] = 13] = \"Stamp\";\n    AnnotationType[AnnotationType[\"Caret\"] = 14] = \"Caret\";\n    AnnotationType[AnnotationType[\"Ink\"] = 15] = \"Ink\";\n    AnnotationType[AnnotationType[\"Popup\"] = 16] = \"Popup\";\n    AnnotationType[AnnotationType[\"FileAttachment\"] = 17] = \"FileAttachment\";\n})(exports.AnnotationType || (exports.AnnotationType = {}));\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nexports.TextDirection = void 0;\n(function (TextDirection) {\n    TextDirection[\"RightToLeft\"] = \"RTL\";\n    TextDirection[\"LeftToRight\"] = \"LTR\";\n})(exports.TextDirection || (exports.TextDirection = {}));\nvar ThemeContext = React__namespace.createContext({\n    currentTheme: 'light',\n    direction: exports.TextDirection.LeftToRight,\n    setCurrentTheme: function () { },\n});\n\nvar classNames = function (classes) {\n    var result = [];\n    Object.keys(classes).forEach(function (clazz) {\n        if (clazz && classes[clazz]) {\n            result.push(clazz);\n        }\n    });\n    return result.join(' ');\n};\n\nvar Button = function (_a) {\n    var children = _a.children, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ className: classNames({\n            'rpv-core__button': true,\n            'rpv-core__button--rtl': isRtl,\n        }), type: \"button\", onClick: onClick }, attrs), children));\n};\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;\n\nvar useIntersectionObserver = function (props) {\n    var containerRef = React__namespace.useRef(null);\n    var once = props.once, threshold = props.threshold, onVisibilityChanged = props.onVisibilityChanged;\n    useIsomorphicLayoutEffect(function () {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        var intersectionTracker = new IntersectionObserver(function (entries) {\n            entries.forEach(function (entry) {\n                var isVisible = entry.isIntersecting;\n                var ratio = entry.intersectionRatio;\n                onVisibilityChanged({ isVisible: isVisible, ratio: ratio });\n                if (isVisible && once) {\n                    intersectionTracker.unobserve(container);\n                    intersectionTracker.disconnect();\n                }\n            });\n        }, {\n            threshold: threshold || 0,\n        });\n        intersectionTracker.observe(container);\n        return function () {\n            intersectionTracker.unobserve(container);\n            intersectionTracker.disconnect();\n        };\n    }, []);\n    return containerRef;\n};\n\nvar LazyRender = function (_a) {\n    var attrs = _a.attrs, children = _a.children, testId = _a.testId;\n    var _b = React__namespace.useState(false), visible = _b[0], setVisible = _b[1];\n    var containerAttrs = testId ? __assign(__assign({}, attrs), { 'data-testid': testId }) : attrs;\n    var handleVisibilityChanged = function (params) {\n        if (params.isVisible) {\n            setVisible(true);\n        }\n    };\n    var containerRef = useIntersectionObserver({\n        once: true,\n        onVisibilityChanged: handleVisibilityChanged,\n    });\n    return (React__namespace.createElement(\"div\", __assign({ ref: containerRef }, containerAttrs), visible && children));\n};\n\nvar Menu = function (_a) {\n    var children = _a.children;\n    var containerRef = React__namespace.useRef();\n    var visibleMenuItemsRef = React__namespace.useRef([]);\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var handleKeyDown = function (e) {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        switch (e.key) {\n            case 'Tab':\n                e.preventDefault();\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n                moveToItem(function (_, currentIndex) { return currentIndex + 1; });\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n                moveToItem(function (_, currentIndex) { return currentIndex - 1; });\n                break;\n            case 'End':\n                e.preventDefault();\n                moveToItem(function (items, _) { return items.length - 1; });\n                break;\n            case 'Home':\n                e.preventDefault();\n                moveToItem(function (_, __) { return 0; });\n                break;\n        }\n    };\n    var moveToItem = function (getNextItem) {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        var items = visibleMenuItemsRef.current;\n        var currentIndex = items.findIndex(function (item) { return item.getAttribute('tabindex') === '0'; });\n        var targetIndex = Math.min(items.length - 1, Math.max(0, getNextItem(items, currentIndex)));\n        if (currentIndex >= 0 && currentIndex <= items.length - 1) {\n            items[currentIndex].setAttribute('tabindex', '-1');\n        }\n        items[targetIndex].setAttribute('tabindex', '0');\n        items[targetIndex].focus();\n    };\n    var findVisibleItems = function (container) {\n        var visibleItems = [];\n        container.querySelectorAll('.rpv-core__menu-item[role=\"menuitem\"]').forEach(function (item) {\n            if (item instanceof HTMLElement) {\n                var parent_1 = item.parentElement;\n                if (parent_1 === container) {\n                    visibleItems.push(item);\n                }\n                else {\n                    if (window.getComputedStyle(parent_1).display !== 'none') {\n                        visibleItems.push(item);\n                    }\n                }\n            }\n        });\n        return visibleItems;\n    };\n    useIsomorphicLayoutEffect(function () {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        var visibleItems = findVisibleItems(container);\n        visibleMenuItemsRef.current = visibleItems;\n    }, []);\n    useIsomorphicLayoutEffect(function () {\n        document.addEventListener('keydown', handleKeyDown);\n        return function () {\n            document.removeEventListener('keydown', handleKeyDown);\n        };\n    }, []);\n    return (React__namespace.createElement(\"div\", { ref: containerRef, \"aria-orientation\": \"vertical\", className: classNames({\n            'rpv-core__menu': true,\n            'rpv-core__menu--rtl': isRtl,\n        }), role: \"menu\", tabIndex: 0 }, children));\n};\n\nvar MenuDivider = function () { return (React__namespace.createElement(\"div\", { \"aria-orientation\": \"horizontal\", className: \"rpv-core__menu-divider\", role: \"separator\" })); };\n\nvar Icon = function (_a) {\n    var children = _a.children, _b = _a.ignoreDirection, ignoreDirection = _b === void 0 ? false : _b, _c = _a.size, size = _c === void 0 ? 24 : _c;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = !ignoreDirection && direction === exports.TextDirection.RightToLeft;\n    var width = \"\".concat(size || 24, \"px\");\n    return (React__namespace.createElement(\"svg\", { \"aria-hidden\": \"true\", className: classNames({\n            'rpv-core__icon': true,\n            'rpv-core__icon--rtl': isRtl,\n        }), focusable: \"false\", height: width, viewBox: \"0 0 24 24\", width: width }, children));\n};\n\nvar CheckIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M23.5,0.499l-16.5,23l-6.5-6.5\" }))); };\n\nvar MenuItem = function (_a) {\n    var _b = _a.checked, checked = _b === void 0 ? false : _b, children = _a.children, _c = _a.icon, icon = _c === void 0 ? null : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ className: classNames({\n            'rpv-core__menu-item': true,\n            'rpv-core__menu-item--disabled': isDisabled,\n            'rpv-core__menu-item--ltr': !isRtl,\n            'rpv-core__menu-item--rtl': isRtl,\n        }), role: \"menuitem\", tabIndex: -1, type: \"button\", onClick: onClick }, attrs),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__menu-item-icon': true,\n                'rpv-core__menu-item-icon--ltr': !isRtl,\n                'rpv-core__menu-item-icon--rtl': isRtl,\n            }) }, icon),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__menu-item-label': true,\n                'rpv-core__menu-item-label--ltr': !isRtl,\n                'rpv-core__menu-item-label--rtl': isRtl,\n            }) }, children),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__menu-item-check': true,\n                'rpv-core__menu-item-check--ltr': !isRtl,\n                'rpv-core__menu-item-check--rtl': isRtl,\n            }) }, checked && React__namespace.createElement(CheckIcon, null))));\n};\n\nvar MinimalButton = function (_a) {\n    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.ariaKeyShortcuts, ariaKeyShortcuts = _c === void 0 ? '' : _c, children = _a.children, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.isSelected, isSelected = _e === void 0 ? false : _e, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ \"aria-label\": ariaLabel }, (ariaKeyShortcuts && { 'aria-keyshortcuts': ariaKeyShortcuts }), (isDisabled && { 'aria-disabled': true }), { className: classNames({\n            'rpv-core__minimal-button': true,\n            'rpv-core__minimal-button--disabled': isDisabled,\n            'rpv-core__minimal-button--rtl': isRtl,\n            'rpv-core__minimal-button--selected': isSelected,\n        }), type: \"button\", onClick: onClick }, attrs), children));\n};\n\nvar PrimaryButton = function (_a) {\n    var children = _a.children, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ className: classNames({\n            'rpv-core__primary-button': true,\n            'rpv-core__primary-button--rtl': isRtl,\n        }), type: \"button\", onClick: onClick }, attrs), children));\n};\n\nvar ProgressBar = function (_a) {\n    var progress = _a.progress;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    return (React__namespace.createElement(\"div\", { className: classNames({\n            'rpv-core__progress-bar': true,\n            'rpv-core__progress-bar--rtl': isRtl,\n        }) },\n        React__namespace.createElement(\"div\", { className: \"rpv-core__progress-bar-progress\", style: { width: \"\".concat(progress, \"%\") } },\n            progress,\n            \"%\")));\n};\n\nvar Separator = function () { return React__namespace.createElement(\"div\", { className: \"rpv-core__separator\" }); };\n\nvar Spinner = function (_a) {\n    var _b = _a.size, size = _b === void 0 ? '4rem' : _b, testId = _a.testId;\n    var _c = React__namespace.useState(false), visible = _c[0], setVisible = _c[1];\n    var attrs = testId ? { 'data-testid': testId } : {};\n    var handleVisibilityChanged = function (params) {\n        setVisible(params.isVisible);\n    };\n    var containerRef = useIntersectionObserver({\n        onVisibilityChanged: handleVisibilityChanged,\n    });\n    return (React__namespace.createElement(\"div\", __assign({}, attrs, { className: classNames({\n            'rpv-core__spinner': true,\n            'rpv-core__spinner--animating': visible,\n        }), ref: containerRef, style: { height: size, width: size } })));\n};\n\nvar Splitter = function (_a) {\n    var constrain = _a.constrain;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var resizerRef = React__namespace.useRef();\n    var leftSideRef = React__namespace.useRef();\n    var rightSideRef = React__namespace.useRef();\n    var xRef = React__namespace.useRef(0);\n    var yRef = React__namespace.useRef(0);\n    var leftWidthRef = React__namespace.useRef(0);\n    var resizerWidthRef = React__namespace.useRef(0);\n    var eventOptions = {\n        capture: true,\n    };\n    var handleMouseMove = function (e) {\n        var resizerEle = resizerRef.current;\n        var leftSide = leftSideRef.current;\n        var rightSide = rightSideRef.current;\n        if (!resizerEle || !leftSide || !rightSide) {\n            return;\n        }\n        var resizerWidth = resizerWidthRef.current;\n        var dx = e.clientX - xRef.current;\n        var firstHalfSize = leftWidthRef.current + (isRtl ? -dx : dx);\n        var containerWidth = resizerEle.parentElement.getBoundingClientRect().width;\n        var firstHalfPercentage = (firstHalfSize * 100) / containerWidth;\n        resizerEle.classList.add('rpv-core__splitter--resizing');\n        if (constrain) {\n            var secondHalfSize = containerWidth - firstHalfSize - resizerWidth;\n            var secondHalfPercentage = (secondHalfSize * 100) / containerWidth;\n            if (!constrain({ firstHalfPercentage: firstHalfPercentage, firstHalfSize: firstHalfSize, secondHalfPercentage: secondHalfPercentage, secondHalfSize: secondHalfSize })) {\n                return;\n            }\n        }\n        leftSide.style.width = \"\".concat(firstHalfPercentage, \"%\");\n        document.body.classList.add('rpv-core__splitter-body--resizing');\n        leftSide.classList.add('rpv-core__splitter-sibling--resizing');\n        rightSide.classList.add('rpv-core__splitter-sibling--resizing');\n    };\n    var handleMouseUp = function (e) {\n        var resizerEle = resizerRef.current;\n        var leftSide = leftSideRef.current;\n        var rightSide = rightSideRef.current;\n        if (!resizerEle || !leftSide || !rightSide) {\n            return;\n        }\n        document.body.classList.remove('rpv-core__splitter-body--resizing');\n        resizerEle.classList.remove('rpv-core__splitter--resizing');\n        leftSide.classList.remove('rpv-core__splitter-sibling--resizing');\n        rightSide.classList.remove('rpv-core__splitter-sibling--resizing');\n        document.removeEventListener('mousemove', handleMouseMove, eventOptions);\n        document.removeEventListener('mouseup', handleMouseUp, eventOptions);\n    };\n    var handleMouseDown = function (e) {\n        var leftSide = leftSideRef.current;\n        if (!leftSide) {\n            return;\n        }\n        xRef.current = e.clientX;\n        yRef.current = e.clientY;\n        leftWidthRef.current = leftSide.getBoundingClientRect().width;\n        document.addEventListener('mousemove', handleMouseMove, eventOptions);\n        document.addEventListener('mouseup', handleMouseUp, eventOptions);\n    };\n    React__namespace.useEffect(function () {\n        var resizerEle = resizerRef.current;\n        if (!resizerEle) {\n            return;\n        }\n        resizerWidthRef.current = resizerEle.getBoundingClientRect().width;\n        leftSideRef.current = resizerEle.previousElementSibling;\n        rightSideRef.current = resizerEle.nextElementSibling;\n    }, []);\n    return React__namespace.createElement(\"div\", { ref: resizerRef, className: \"rpv-core__splitter\", onMouseDown: handleMouseDown });\n};\n\nvar TextBox = function (_a) {\n    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.autoFocus, autoFocus = _c === void 0 ? false : _c, _d = _a.placeholder, placeholder = _d === void 0 ? '' : _d, testId = _a.testId, _e = _a.type, type = _e === void 0 ? 'text' : _e, _f = _a.value, value = _f === void 0 ? '' : _f, onChange = _a.onChange, _g = _a.onKeyDown, onKeyDown = _g === void 0 ? function () { } : _g;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var textboxRef = React__namespace.useRef();\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = {\n        ref: textboxRef,\n        'data-testid': '',\n        'aria-label': ariaLabel,\n        className: classNames({\n            'rpv-core__textbox': true,\n            'rpv-core__textbox--rtl': isRtl,\n        }),\n        placeholder: placeholder,\n        value: value,\n        onChange: function (e) { return onChange(e.target.value); },\n        onKeyDown: onKeyDown,\n    };\n    if (testId) {\n        attrs['data-testid'] = testId;\n    }\n    useIsomorphicLayoutEffect(function () {\n        if (autoFocus) {\n            var textboxEle = textboxRef.current;\n            if (textboxEle) {\n                var x = window.scrollX;\n                var y = window.scrollY;\n                textboxEle.focus();\n                window.scrollTo(x, y);\n            }\n        }\n    }, []);\n    return type === 'text' ? React__namespace.createElement(\"input\", __assign({ type: \"text\" }, attrs)) : React__namespace.createElement(\"input\", __assign({ type: \"password\" }, attrs));\n};\n\nvar Api;\n(function (Api) {\n    Api[Api[\"ExitFullScreen\"] = 0] = \"ExitFullScreen\";\n    Api[Api[\"FullScreenChange\"] = 1] = \"FullScreenChange\";\n    Api[Api[\"FullScreenElement\"] = 2] = \"FullScreenElement\";\n    Api[Api[\"FullScreenEnabled\"] = 3] = \"FullScreenEnabled\";\n    Api[Api[\"RequestFullScreen\"] = 4] = \"RequestFullScreen\";\n})(Api || (Api = {}));\nvar defaultVendor = {\n    ExitFullScreen: 'exitFullscreen',\n    FullScreenChange: 'fullscreenchange',\n    FullScreenElement: 'fullscreenElement',\n    FullScreenEnabled: 'fullscreenEnabled',\n    RequestFullScreen: 'requestFullscreen',\n};\nvar webkitVendor = {\n    ExitFullScreen: 'webkitExitFullscreen',\n    FullScreenChange: 'webkitfullscreenchange',\n    FullScreenElement: 'webkitFullscreenElement',\n    FullScreenEnabled: 'webkitFullscreenEnabled',\n    RequestFullScreen: 'webkitRequestFullscreen',\n};\nvar msVendor = {\n    ExitFullScreen: 'msExitFullscreen',\n    FullScreenChange: 'msFullscreenChange',\n    FullScreenElement: 'msFullscreenElement',\n    FullScreenEnabled: 'msFullscreenEnabled',\n    RequestFullScreen: 'msRequestFullscreen',\n};\nvar isBrowser = typeof window !== 'undefined';\nvar vendor = isBrowser\n    ? (Api.FullScreenEnabled in document && defaultVendor) ||\n        (webkitVendor.FullScreenEnabled in document && webkitVendor) ||\n        (msVendor.FullScreenEnabled in document && msVendor) ||\n        defaultVendor\n    : defaultVendor;\nvar isFullScreenEnabled = function () {\n    return isBrowser && vendor.FullScreenEnabled in document && document[vendor.FullScreenEnabled] === true;\n};\nvar addFullScreenChangeListener = function (handler) {\n    if (isBrowser) {\n        document.addEventListener(vendor.FullScreenChange, handler);\n    }\n};\nvar removeFullScreenChangeListener = function (handler) {\n    if (isBrowser) {\n        document.removeEventListener(vendor.FullScreenChange, handler);\n    }\n};\nvar exitFullScreen = function (element) {\n    return isBrowser\n        ?\n            element[vendor.ExitFullScreen]()\n        : Promise.resolve({});\n};\nvar getFullScreenElement = function () {\n    return isBrowser ? document[vendor.FullScreenElement] : null;\n};\nvar requestFullScreen = function (element) {\n    if (isBrowser) {\n        element[vendor.RequestFullScreen]();\n    }\n};\n\nvar useDebounceCallback = function (callback, wait) {\n    var timeout = React__namespace.useRef();\n    var cleanup = function () {\n        if (timeout.current) {\n            clearTimeout(timeout.current);\n        }\n    };\n    React__namespace.useEffect(function () {\n        return function () { return cleanup(); };\n    }, []);\n    return React__namespace.useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        cleanup();\n        timeout.current = setTimeout(function () {\n            callback.apply(void 0, args);\n        }, wait);\n    }, [callback, wait]);\n};\n\nvar useIsMounted = function () {\n    var isMountedRef = React__namespace.useRef(false);\n    React__namespace.useEffect(function () {\n        isMountedRef.current = true;\n        return function () {\n            isMountedRef.current = false;\n        };\n    }, []);\n    return isMountedRef;\n};\n\nvar usePrevious = function (value) {\n    var ref = React__namespace.useRef(value);\n    React__namespace.useEffect(function () {\n        ref.current = value;\n    }, [value]);\n    return ref.current;\n};\n\nvar PageRenderStatus;\n(function (PageRenderStatus) {\n    PageRenderStatus[\"NotRenderedYet\"] = \"NotRenderedYet\";\n    PageRenderStatus[\"Rendering\"] = \"Rendering\";\n    PageRenderStatus[\"Rendered\"] = \"Rendered\";\n})(PageRenderStatus || (PageRenderStatus = {}));\nvar OUT_OF_RANGE_VISIBILITY = -9999;\nvar useRenderQueue = function (_a) {\n    var doc = _a.doc;\n    var numPages = doc.numPages;\n    var docId = doc.loadingTask.docId;\n    var initialPageVisibilities = React__namespace.useMemo(function () {\n        return Array(numPages)\n            .fill(null)\n            .map(function (_, pageIndex) { return ({\n            pageIndex: pageIndex,\n            renderStatus: PageRenderStatus.NotRenderedYet,\n            visibility: OUT_OF_RANGE_VISIBILITY,\n        }); });\n    }, [docId]);\n    var latestRef = React__namespace.useRef({\n        currentRenderingPage: -1,\n        startRange: 0,\n        endRange: numPages - 1,\n        visibilities: initialPageVisibilities,\n    });\n    var markNotRendered = function () {\n        for (var i = 0; i < numPages; i++) {\n            latestRef.current.visibilities[i].renderStatus = PageRenderStatus.NotRenderedYet;\n        }\n    };\n    var markRendered = function (pageIndex) {\n        latestRef.current.visibilities[pageIndex].renderStatus = PageRenderStatus.Rendered;\n    };\n    var markRendering = function (pageIndex) {\n        if (latestRef.current.currentRenderingPage !== -1 &&\n            latestRef.current.currentRenderingPage !== pageIndex &&\n            latestRef.current.visibilities[latestRef.current.currentRenderingPage].renderStatus ===\n                PageRenderStatus.Rendering) {\n            latestRef.current.visibilities[latestRef.current.currentRenderingPage].renderStatus =\n                PageRenderStatus.NotRenderedYet;\n        }\n        latestRef.current.visibilities[pageIndex].renderStatus = PageRenderStatus.Rendering;\n        latestRef.current.currentRenderingPage = pageIndex;\n    };\n    var setRange = function (startIndex, endIndex) {\n        latestRef.current.startRange = startIndex;\n        latestRef.current.endRange = endIndex;\n        for (var i = 0; i < numPages; i++) {\n            if (i < startIndex || i > endIndex) {\n                latestRef.current.visibilities[i].visibility = OUT_OF_RANGE_VISIBILITY;\n                latestRef.current.visibilities[i].renderStatus = PageRenderStatus.NotRenderedYet;\n            }\n        }\n    };\n    var setOutOfRange = function (pageIndex) {\n        setVisibility(pageIndex, OUT_OF_RANGE_VISIBILITY);\n    };\n    var setVisibility = function (pageIndex, visibility) {\n        latestRef.current.visibilities[pageIndex].visibility = visibility;\n    };\n    var getHighestPriorityPage = function () {\n        var visiblePages = latestRef.current.visibilities\n            .slice(latestRef.current.startRange, latestRef.current.endRange + 1)\n            .filter(function (item) { return item.visibility > OUT_OF_RANGE_VISIBILITY; });\n        if (!visiblePages.length) {\n            return -1;\n        }\n        var firstVisiblePage = visiblePages[0].pageIndex;\n        var lastVisiblePage = visiblePages[visiblePages.length - 1].pageIndex;\n        var numVisiblePages = visiblePages.length;\n        for (var i = 0; i < numVisiblePages; i++) {\n            if (visiblePages[i].renderStatus === PageRenderStatus.Rendering) {\n                return -1;\n            }\n            if (visiblePages[i].renderStatus === PageRenderStatus.NotRenderedYet) {\n                return visiblePages[i].pageIndex;\n            }\n        }\n        if (lastVisiblePage + 1 < numPages &&\n            latestRef.current.visibilities[lastVisiblePage + 1].renderStatus !== PageRenderStatus.Rendered) {\n            return lastVisiblePage + 1;\n        }\n        else if (firstVisiblePage - 1 >= 0 &&\n            latestRef.current.visibilities[firstVisiblePage - 1].renderStatus !== PageRenderStatus.Rendered) {\n            return firstVisiblePage - 1;\n        }\n        return -1;\n    };\n    var isInRange = function (pageIndex) {\n        return pageIndex >= latestRef.current.startRange && pageIndex <= latestRef.current.endRange;\n    };\n    return {\n        getHighestPriorityPage: getHighestPriorityPage,\n        isInRange: isInRange,\n        markNotRendered: markNotRendered,\n        markRendered: markRendered,\n        markRendering: markRendering,\n        setOutOfRange: setOutOfRange,\n        setRange: setRange,\n        setVisibility: setVisibility,\n    };\n};\n\nvar core = {\n\taskingPassword: {\n\t\trequirePasswordToOpen: \"This document requires a password to open\",\n\t\tsubmit: \"Submit\"\n\t},\n\twrongPassword: {\n\t\ttryAgain: \"The password is wrong. Please try again\"\n\t},\n\tpageLabel: \"Page {{pageIndex}}\"\n};\nvar enUs = {\n\tcore: core\n};\n\nvar DefaultLocalization = enUs;\nvar LocalizationContext = React__namespace.createContext({\n    l10n: DefaultLocalization,\n    setL10n: function () { },\n});\n\nvar id = 0;\nvar uniqueId = function () { return id++; };\n\nvar useClickOutside = function (closeOnClickOutside, targetRef, onClickOutside) {\n    var clickHandler = function (e) {\n        var target = targetRef.current;\n        if (!target) {\n            return;\n        }\n        var clickedTarget = e.target;\n        if (clickedTarget instanceof Element && clickedTarget.shadowRoot) {\n            var paths = e.composedPath();\n            if (paths.length > 0 && !target.contains(paths[0])) {\n                onClickOutside();\n            }\n        }\n        else if (!target.contains(clickedTarget)) {\n            onClickOutside();\n        }\n    };\n    React__namespace.useEffect(function () {\n        if (!closeOnClickOutside) {\n            return;\n        }\n        var eventOptions = {\n            capture: true,\n        };\n        document.addEventListener('click', clickHandler, eventOptions);\n        return function () {\n            document.removeEventListener('click', clickHandler, eventOptions);\n        };\n    }, []);\n};\n\nvar useEscape = function (handler) {\n    var keyUpHandler = function (e) {\n        if (e.key === 'Escape') {\n            handler();\n        }\n    };\n    React__namespace.useEffect(function () {\n        document.addEventListener('keyup', keyUpHandler);\n        return function () {\n            document.removeEventListener('keyup', keyUpHandler);\n        };\n    }, []);\n};\n\nvar useLockScroll = function () {\n    React__namespace.useEffect(function () {\n        var originalStyle = window.getComputedStyle(document.body).overflow;\n        document.body.style.overflow = 'hidden';\n        return function () {\n            document.body.style.overflow = originalStyle;\n        };\n    }, []);\n};\n\nvar ModalBody = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, onToggle = _a.onToggle;\n    var contentRef = React__namespace.useRef();\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    useLockScroll();\n    useEscape(function () {\n        if (contentRef.current && closeOnEscape) {\n            onToggle();\n        }\n    });\n    useClickOutside(closeOnClickOutside, contentRef, onToggle);\n    useIsomorphicLayoutEffect(function () {\n        var contentEle = contentRef.current;\n        if (!contentEle) {\n            return;\n        }\n        var maxHeight = document.body.clientHeight * 0.75;\n        if (contentEle.getBoundingClientRect().height >= maxHeight) {\n            contentEle.style.overflow = 'auto';\n            contentEle.style.maxHeight = \"\".concat(maxHeight, \"px\");\n        }\n    }, []);\n    return (React__namespace.createElement(\"div\", { \"aria-modal\": \"true\", className: classNames({\n            'rpv-core__modal-body': true,\n            'rpv-core__modal-body--rtl': isRtl,\n        }), id: \"rpv-core__modal-body-\".concat(ariaControlsSuffix), ref: contentRef, role: \"dialog\", tabIndex: -1 }, children));\n};\n\nvar ModalOverlay = function (_a) {\n    var children = _a.children;\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__modal-overlay\" }, children);\n};\n\nexports.ToggleStatus = void 0;\n(function (ToggleStatus) {\n    ToggleStatus[\"Close\"] = \"Close\";\n    ToggleStatus[\"Open\"] = \"Open\";\n    ToggleStatus[\"Toggle\"] = \"Toggle\";\n})(exports.ToggleStatus || (exports.ToggleStatus = {}));\n\nvar useToggle = function (isOpened) {\n    var _a = React__namespace.useState(isOpened), opened = _a[0], setOpened = _a[1];\n    var toggle = function (status) {\n        switch (status) {\n            case exports.ToggleStatus.Close:\n                setOpened(false);\n                break;\n            case exports.ToggleStatus.Open:\n                setOpened(true);\n                break;\n            case exports.ToggleStatus.Toggle:\n            default:\n                setOpened(function (isOpened) { return !isOpened; });\n                break;\n        }\n    };\n    return { opened: opened, toggle: toggle };\n};\n\nvar Portal = function (_a) {\n    var content = _a.content, _b = _a.isOpened, isOpened = _b === void 0 ? false : _b, target = _a.target;\n    var _c = useToggle(isOpened), opened = _c.opened, toggle = _c.toggle;\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        target && target(toggle, opened),\n        opened && content(toggle)));\n};\n\nvar Modal = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, _b = _a.isOpened, isOpened = _b === void 0 ? false : _b, target = _a.target;\n    var controlsSuffix = ariaControlsSuffix || \"\".concat(uniqueId());\n    var renderTarget = function (toggle, opened) { return (React__namespace.createElement(\"div\", { \"aria-expanded\": opened ? 'true' : 'false', \"aria-haspopup\": \"dialog\", \"aria-controls\": \"rpv-core__modal-body-\".concat(controlsSuffix) }, target(toggle, opened))); };\n    var renderContent = function (toggle) { return (React__namespace.createElement(ModalOverlay, null,\n        React__namespace.createElement(ModalBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, closeOnEscape: closeOnEscape, onToggle: toggle }, content(toggle)))); };\n    return React__namespace.createElement(Portal, { target: target ? renderTarget : null, content: renderContent, isOpened: isOpened });\n};\n\nexports.Position = void 0;\n(function (Position) {\n    Position[\"TopLeft\"] = \"TOP_LEFT\";\n    Position[\"TopCenter\"] = \"TOP_CENTER\";\n    Position[\"TopRight\"] = \"TOP_RIGHT\";\n    Position[\"RightTop\"] = \"RIGHT_TOP\";\n    Position[\"RightCenter\"] = \"RIGHT_CENTER\";\n    Position[\"RightBottom\"] = \"RIGHT_BOTTOM\";\n    Position[\"BottomLeft\"] = \"BOTTOM_LEFT\";\n    Position[\"BottomCenter\"] = \"BOTTOM_CENTER\";\n    Position[\"BottomRight\"] = \"BOTTOM_RIGHT\";\n    Position[\"LeftTop\"] = \"LEFT_TOP\";\n    Position[\"LeftCenter\"] = \"LEFT_CENTER\";\n    Position[\"LeftBottom\"] = \"LEFT_BOTTOM\";\n})(exports.Position || (exports.Position = {}));\n\nvar calculatePosition = function (content, target, position, offset) {\n    var targetRect = target.getBoundingClientRect();\n    var contentRect = content.getBoundingClientRect();\n    var height = contentRect.height, width = contentRect.width;\n    var top = 0;\n    var left = 0;\n    switch (position) {\n        case exports.Position.TopLeft:\n            top = targetRect.top - height;\n            left = targetRect.left;\n            break;\n        case exports.Position.TopCenter:\n            top = targetRect.top - height;\n            left = targetRect.left + targetRect.width / 2 - width / 2;\n            break;\n        case exports.Position.TopRight:\n            top = targetRect.top - height;\n            left = targetRect.left + targetRect.width - width;\n            break;\n        case exports.Position.RightTop:\n            top = targetRect.top;\n            left = targetRect.left + targetRect.width;\n            break;\n        case exports.Position.RightCenter:\n            top = targetRect.top + targetRect.height / 2 - height / 2;\n            left = targetRect.left + targetRect.width;\n            break;\n        case exports.Position.RightBottom:\n            top = targetRect.top + targetRect.height - height;\n            left = targetRect.left + targetRect.width;\n            break;\n        case exports.Position.BottomLeft:\n            top = targetRect.top + targetRect.height;\n            left = targetRect.left;\n            break;\n        case exports.Position.BottomCenter:\n            top = targetRect.top + targetRect.height;\n            left = targetRect.left + targetRect.width / 2 - width / 2;\n            break;\n        case exports.Position.BottomRight:\n            top = targetRect.top + targetRect.height;\n            left = targetRect.left + targetRect.width - width;\n            break;\n        case exports.Position.LeftTop:\n            top = targetRect.top;\n            left = targetRect.left - width;\n            break;\n        case exports.Position.LeftCenter:\n            top = targetRect.top + targetRect.height / 2 - height / 2;\n            left = targetRect.left - width;\n            break;\n        case exports.Position.LeftBottom:\n            top = targetRect.top + targetRect.height - height;\n            left = targetRect.left - width;\n            break;\n    }\n    return {\n        left: left + (offset.left || 0),\n        top: top + (offset.top || 0),\n    };\n};\n\nvar usePosition = function (contentRef, targetRef, anchorRef, position, offset) {\n    useIsomorphicLayoutEffect(function () {\n        var targetEle = targetRef.current;\n        var contentEle = contentRef.current;\n        var anchorEle = anchorRef.current;\n        if (!contentEle || !targetEle || !anchorEle) {\n            return;\n        }\n        var anchorRect = anchorEle.getBoundingClientRect();\n        var _a = calculatePosition(contentEle, targetEle, position, offset), top = _a.top, left = _a.left;\n        contentEle.style.top = \"\".concat(top - anchorRect.top, \"px\");\n        contentEle.style.left = \"\".concat(left - anchorRect.left, \"px\");\n    }, []);\n};\n\nvar Arrow = function (_a) {\n    var _b;\n    var customClassName = _a.customClassName, position = _a.position;\n    return (React__namespace.createElement(\"div\", { className: classNames((_b = {\n                'rpv-core__arrow': true,\n                'rpv-core__arrow--tl': position === exports.Position.TopLeft,\n                'rpv-core__arrow--tc': position === exports.Position.TopCenter,\n                'rpv-core__arrow--tr': position === exports.Position.TopRight,\n                'rpv-core__arrow--rt': position === exports.Position.RightTop,\n                'rpv-core__arrow--rc': position === exports.Position.RightCenter,\n                'rpv-core__arrow--rb': position === exports.Position.RightBottom,\n                'rpv-core__arrow--bl': position === exports.Position.BottomLeft,\n                'rpv-core__arrow--bc': position === exports.Position.BottomCenter,\n                'rpv-core__arrow--br': position === exports.Position.BottomRight,\n                'rpv-core__arrow--lt': position === exports.Position.LeftTop,\n                'rpv-core__arrow--lc': position === exports.Position.LeftCenter,\n                'rpv-core__arrow--lb': position === exports.Position.LeftBottom\n            },\n            _b[\"\".concat(customClassName)] = customClassName !== '',\n            _b)) }));\n};\n\nvar PopoverBody = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, offset = _a.offset, position = _a.position, targetRef = _a.targetRef, onClose = _a.onClose;\n    var contentRef = React__namespace.useRef();\n    var innerRef = React__namespace.useRef();\n    var anchorRef = React__namespace.useRef();\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    useClickOutside(closeOnClickOutside, contentRef, onClose);\n    usePosition(contentRef, targetRef, anchorRef, position, offset);\n    useIsomorphicLayoutEffect(function () {\n        var innerContentEle = innerRef.current;\n        if (!innerContentEle) {\n            return;\n        }\n        var maxHeight = document.body.clientHeight * 0.75;\n        if (innerContentEle.getBoundingClientRect().height >= maxHeight) {\n            innerContentEle.style.overflow = 'auto';\n            innerContentEle.style.maxHeight = \"\".concat(maxHeight, \"px\");\n        }\n    }, []);\n    var innerId = \"rpv-core__popover-body-inner-\".concat(ariaControlsSuffix);\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),\n        React__namespace.createElement(\"div\", { \"aria-describedby\": innerId, className: classNames({\n                'rpv-core__popover-body': true,\n                'rpv-core__popover-body--rtl': isRtl,\n            }), id: \"rpv-core__popover-body-\".concat(ariaControlsSuffix), ref: contentRef, role: \"dialog\", tabIndex: -1 },\n            React__namespace.createElement(Arrow, { customClassName: \"rpv-core__popover-body-arrow\", position: position }),\n            React__namespace.createElement(\"div\", { id: innerId, ref: innerRef }, children))));\n};\n\nvar PopoverOverlay = function (_a) {\n    var closeOnEscape = _a.closeOnEscape, onClose = _a.onClose;\n    var containerRef = React__namespace.useRef();\n    useEscape(function () {\n        if (containerRef.current && closeOnEscape) {\n            onClose();\n        }\n    });\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__popover-overlay\", ref: containerRef });\n};\n\nvar Popover = function (_a) {\n    var _b = _a.ariaHasPopup, ariaHasPopup = _b === void 0 ? 'dialog' : _b, ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, _c = _a.lockScroll, lockScroll = _c === void 0 ? true : _c, offset = _a.offset, position = _a.position, target = _a.target;\n    var _d = useToggle(false), opened = _d.opened, toggle = _d.toggle;\n    var targetRef = React__namespace.useRef();\n    var controlsSuffix = React__namespace.useMemo(function () { return ariaControlsSuffix || \"\".concat(uniqueId()); }, []);\n    return (React__namespace.createElement(\"div\", { ref: targetRef, \"aria-expanded\": opened ? 'true' : 'false', \"aria-haspopup\": ariaHasPopup, \"aria-controls\": \"rpv-core__popver-body-\".concat(controlsSuffix) },\n        target(toggle, opened),\n        opened && (React__namespace.createElement(React__namespace.Fragment, null,\n            lockScroll && React__namespace.createElement(PopoverOverlay, { closeOnEscape: closeOnEscape, onClose: toggle }),\n            React__namespace.createElement(PopoverBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, offset: offset, position: position, targetRef: targetRef, onClose: toggle }, content(toggle))))));\n};\n\nvar TooltipBody = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, contentRef = _a.contentRef, offset = _a.offset, position = _a.position, targetRef = _a.targetRef;\n    var anchorRef = React__namespace.useRef();\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    usePosition(contentRef, targetRef, anchorRef, position, offset);\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__tooltip-body': true,\n                'rpv-core__tooltip-body--rtl': isRtl,\n            }), id: \"rpv-core__tooltip-body-\".concat(ariaControlsSuffix), ref: contentRef, role: \"tooltip\" },\n            React__namespace.createElement(Arrow, { customClassName: \"rpv-core__tooltip-body-arrow\", position: position }),\n            React__namespace.createElement(\"div\", { className: \"rpv-core__tooltip-body-content\" }, children))));\n};\n\nvar Tooltip = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, content = _a.content, offset = _a.offset, position = _a.position, target = _a.target;\n    var _b = useToggle(false), opened = _b.opened, toggle = _b.toggle;\n    var targetRef = React__namespace.useRef();\n    var contentRef = React__namespace.useRef();\n    var controlsSuffix = React__namespace.useMemo(function () { return ariaControlsSuffix || \"\".concat(uniqueId()); }, []);\n    useEscape(function () {\n        if (targetRef.current && document.activeElement && targetRef.current.contains(document.activeElement)) {\n            close();\n        }\n    });\n    var open = function () {\n        toggle(exports.ToggleStatus.Open);\n    };\n    var close = function () {\n        toggle(exports.ToggleStatus.Close);\n    };\n    var onBlur = function (e) {\n        var shouldHideTooltip = e.relatedTarget instanceof HTMLElement &&\n            e.currentTarget.parentElement &&\n            e.currentTarget.parentElement.contains(e.relatedTarget);\n        if (shouldHideTooltip) {\n            if (contentRef.current) {\n                contentRef.current.style.display = 'none';\n            }\n        }\n        else {\n            close();\n        }\n    };\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", { ref: targetRef, \"aria-describedby\": \"rpv-core__tooltip-body-\".concat(controlsSuffix), onBlur: onBlur, onFocus: open, onMouseEnter: open, onMouseLeave: close }, target),\n        opened && (React__namespace.createElement(TooltipBody, { ariaControlsSuffix: controlsSuffix, contentRef: contentRef, offset: offset, position: position, targetRef: targetRef }, content()))));\n};\n\nfunction createStore(initialState) {\n    var state = initialState || {};\n    var listeners = {};\n    var update = function (key, data) {\n        var _a;\n        state = __assign(__assign({}, state), (_a = {}, _a[key] = data, _a));\n        (listeners[key] || []).forEach(function (handler) { return handler(state[key]); });\n    };\n    var get = function (key) { return state[key]; };\n    return {\n        subscribe: function (key, handler) {\n            listeners[key] = (listeners[key] || []).concat(handler);\n        },\n        unsubscribe: function (key, handler) {\n            listeners[key] = (listeners[key] || []).filter(function (f) { return f !== handler; });\n        },\n        update: function (key, data) {\n            update(key, data);\n        },\n        updateCurrentValue: function (key, updater) {\n            var currentValue = get(key);\n            if (currentValue !== undefined) {\n                update(key, updater(currentValue));\n            }\n        },\n        get: function (key) {\n            return get(key);\n        },\n    };\n}\n\nexports.FullScreenMode = void 0;\n(function (FullScreenMode) {\n    FullScreenMode[\"Normal\"] = \"Normal\";\n    FullScreenMode[\"Entering\"] = \"Entering\";\n    FullScreenMode[\"Entered\"] = \"Entered\";\n    FullScreenMode[\"EnteredCompletely\"] = \"EnteredCompletely\";\n    FullScreenMode[\"Exitting\"] = \"Exitting\";\n    FullScreenMode[\"Exited\"] = \"Exited\";\n})(exports.FullScreenMode || (exports.FullScreenMode = {}));\n\nexports.LayerRenderStatus = void 0;\n(function (LayerRenderStatus) {\n    LayerRenderStatus[LayerRenderStatus[\"PreRender\"] = 0] = \"PreRender\";\n    LayerRenderStatus[LayerRenderStatus[\"DidRender\"] = 1] = \"DidRender\";\n})(exports.LayerRenderStatus || (exports.LayerRenderStatus = {}));\n\nexports.PageMode = void 0;\n(function (PageMode) {\n    PageMode[\"Attachments\"] = \"UseAttachments\";\n    PageMode[\"Bookmarks\"] = \"UseOutlines\";\n    PageMode[\"ContentGroup\"] = \"UseOC\";\n    PageMode[\"Default\"] = \"UserNone\";\n    PageMode[\"FullScreen\"] = \"FullScreen\";\n    PageMode[\"Thumbnails\"] = \"UseThumbs\";\n})(exports.PageMode || (exports.PageMode = {}));\n\nexports.PasswordStatus = void 0;\n(function (PasswordStatus) {\n    PasswordStatus[\"RequiredPassword\"] = \"RequiredPassword\";\n    PasswordStatus[\"WrongPassword\"] = \"WrongPassword\";\n})(exports.PasswordStatus || (exports.PasswordStatus = {}));\n\nexports.RotateDirection = void 0;\n(function (RotateDirection) {\n    RotateDirection[\"Backward\"] = \"Backward\";\n    RotateDirection[\"Forward\"] = \"Forward\";\n})(exports.RotateDirection || (exports.RotateDirection = {}));\n\nexports.ScrollMode = void 0;\n(function (ScrollMode) {\n    ScrollMode[\"Page\"] = \"Page\";\n    ScrollMode[\"Horizontal\"] = \"Horizontal\";\n    ScrollMode[\"Vertical\"] = \"Vertical\";\n    ScrollMode[\"Wrapped\"] = \"Wrapped\";\n})(exports.ScrollMode || (exports.ScrollMode = {}));\n\nexports.SpecialZoomLevel = void 0;\n(function (SpecialZoomLevel) {\n    SpecialZoomLevel[\"ActualSize\"] = \"ActualSize\";\n    SpecialZoomLevel[\"PageFit\"] = \"PageFit\";\n    SpecialZoomLevel[\"PageWidth\"] = \"PageWidth\";\n})(exports.SpecialZoomLevel || (exports.SpecialZoomLevel = {}));\n\nexports.ViewMode = void 0;\n(function (ViewMode) {\n    ViewMode[\"DualPage\"] = \"DualPage\";\n    ViewMode[\"DualPageWithCover\"] = \"DualPageWithCover\";\n    ViewMode[\"SinglePage\"] = \"SinglePage\";\n})(exports.ViewMode || (exports.ViewMode = {}));\n\nvar chunk = function (arr, size) {\n    return arr.reduce(function (acc, e, i) { return (i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc); }, []);\n};\n\nvar isMac = function () { return (typeof window !== 'undefined' ? /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) : false); };\n\nvar normalizeDestination = function (pageIndex, destArray) {\n    switch (destArray[1].name) {\n        case 'XYZ':\n            return {\n                bottomOffset: function (_, viewportHeight) {\n                    return destArray[3] === null ? viewportHeight : destArray[3];\n                },\n                leftOffset: function (_, __) { return (destArray[2] === null ? 0 : destArray[2]); },\n                pageIndex: pageIndex,\n                scaleTo: destArray[4],\n            };\n        case 'Fit':\n        case 'FitB':\n            return {\n                bottomOffset: 0,\n                leftOffset: 0,\n                pageIndex: pageIndex,\n                scaleTo: exports.SpecialZoomLevel.PageFit,\n            };\n        case 'FitH':\n        case 'FitBH':\n            return {\n                bottomOffset: destArray[2],\n                leftOffset: 0,\n                pageIndex: pageIndex,\n                scaleTo: exports.SpecialZoomLevel.PageWidth,\n            };\n        default:\n            return {\n                bottomOffset: 0,\n                leftOffset: 0,\n                pageIndex: pageIndex,\n                scaleTo: 1,\n            };\n    }\n};\nvar pageOutlinesMap = new Map();\nvar pagesMap = new Map();\nvar generateRefKey = function (doc, outline) {\n    return \"\".concat(doc.loadingTask.docId, \"___\").concat(outline.num, \"R\").concat(outline.gen === 0 ? '' : outline.gen);\n};\nvar getPageIndex = function (doc, outline) {\n    var key = generateRefKey(doc, outline);\n    return pageOutlinesMap.has(key) ? pageOutlinesMap.get(key) : null;\n};\nvar cacheOutlineRef = function (doc, outline, pageIndex) {\n    pageOutlinesMap.set(generateRefKey(doc, outline), pageIndex);\n};\nvar clearPagesCache = function () {\n    pageOutlinesMap.clear();\n    pagesMap.clear();\n};\nvar getPage = function (doc, pageIndex) {\n    if (!doc) {\n        return Promise.reject('The document is not loaded yet');\n    }\n    var pageKey = \"\".concat(doc.loadingTask.docId, \"___\").concat(pageIndex);\n    var page = pagesMap.get(pageKey);\n    if (page) {\n        return Promise.resolve(page);\n    }\n    return new Promise(function (resolve, _) {\n        doc.getPage(pageIndex + 1).then(function (page) {\n            pagesMap.set(pageKey, page);\n            if (page.ref) {\n                cacheOutlineRef(doc, page.ref, pageIndex);\n            }\n            resolve(page);\n        });\n    });\n};\nvar getDestination = function (doc, dest) {\n    return new Promise(function (res) {\n        new Promise(function (resolve) {\n            if (typeof dest === 'string') {\n                doc.getDestination(dest).then(function (destArray) {\n                    resolve(destArray);\n                });\n            }\n            else {\n                resolve(dest);\n            }\n        }).then(function (destArray) {\n            if ('object' === typeof destArray[0] && destArray[0] !== null) {\n                var outlineRef_1 = destArray[0];\n                var pageIndex = getPageIndex(doc, outlineRef_1);\n                if (pageIndex === null) {\n                    doc.getPageIndex(outlineRef_1).then(function (pageIndex) {\n                        cacheOutlineRef(doc, outlineRef_1, pageIndex);\n                        getDestination(doc, dest).then(function (result) { return res(result); });\n                    });\n                }\n                else {\n                    res(normalizeDestination(pageIndex, destArray));\n                }\n            }\n            else {\n                var target = normalizeDestination(destArray[0], destArray);\n                res(target);\n            }\n        });\n    });\n};\n\nvar useRunOnce = function (cb, condition) {\n    var isCalledRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        if (condition && !isCalledRef.current) {\n            isCalledRef.current = true;\n            cb();\n        }\n    }, [cb, condition]);\n};\n\nvar useTrackResize = function (_a) {\n    var targetRef = _a.targetRef, onResize = _a.onResize;\n    useIsomorphicLayoutEffect(function () {\n        var io = new ResizeObserver(function (entries) {\n            entries.forEach(function (entry) {\n                onResize(entry.target);\n            });\n        });\n        var container = targetRef.current;\n        if (!container) {\n            return;\n        }\n        io.observe(container);\n        return function () {\n            io.unobserve(container);\n        };\n    }, []);\n};\n\nvar AnnotationBorderStyleType;\n(function (AnnotationBorderStyleType) {\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Solid\"] = 1] = \"Solid\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Dashed\"] = 2] = \"Dashed\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Beveled\"] = 3] = \"Beveled\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Inset\"] = 4] = \"Inset\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Underline\"] = 5] = \"Underline\";\n})(AnnotationBorderStyleType || (AnnotationBorderStyleType = {}));\n\nvar dateRegex = new RegExp('^D:' +\n    '(\\\\d{4})' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '([Z|+|-])?' +\n    '(\\\\d{2})?' +\n    \"'?\" +\n    '(\\\\d{2})?' +\n    \"'?\");\nvar parse = function (value, min, max, defaultValue) {\n    var parsed = parseInt(value, 10);\n    return parsed >= min && parsed <= max ? parsed : defaultValue;\n};\nvar convertDate = function (input) {\n    var matches = dateRegex.exec(input);\n    if (!matches) {\n        return null;\n    }\n    var year = parseInt(matches[1], 10);\n    var month = parse(matches[2], 1, 12, 1) - 1;\n    var day = parse(matches[3], 1, 31, 1);\n    var hour = parse(matches[4], 0, 23, 0);\n    var minute = parse(matches[5], 0, 59, 0);\n    var second = parse(matches[6], 0, 59, 0);\n    var universalTimeRelation = matches[7] || 'Z';\n    var offsetHour = parse(matches[8], 0, 23, 0);\n    var offsetMinute = parse(matches[9], 0, 59, 0);\n    switch (universalTimeRelation) {\n        case '-':\n            hour += offsetHour;\n            minute += offsetMinute;\n            break;\n        case '+':\n            hour -= offsetHour;\n            minute -= offsetMinute;\n            break;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n};\n\nvar getContents = function (annotation) {\n    return annotation.contentsObj ? annotation.contentsObj.str : annotation.contents || '';\n};\n\nvar getTitle = function (annotation) {\n    return annotation.titleObj ? annotation.titleObj.str : annotation.title || '';\n};\n\nvar PopupWrapper = function (_a) {\n    var annotation = _a.annotation;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var containerRef = React__namespace.useRef();\n    var dateStr = '';\n    if (annotation.modificationDate) {\n        var date = convertDate(annotation.modificationDate);\n        dateStr = date ? \"\".concat(date.toLocaleDateString(), \", \").concat(date.toLocaleTimeString()) : '';\n    }\n    React__namespace.useLayoutEffect(function () {\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        var annotationEle = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.id, \"\\\"]\"));\n        if (!annotationEle) {\n            return;\n        }\n        var ele = annotationEle;\n        ele.style.zIndex += 1;\n        return function () {\n            ele.style.zIndex = \"\".concat(parseInt(ele.style.zIndex, 10) - 1);\n        };\n    }, []);\n    return (React__namespace.createElement(\"div\", { ref: containerRef, className: classNames({\n            'rpv-core__annotation-popup-wrapper': true,\n            'rpv-core__annotation-popup-wrapper--rtl': isRtl,\n        }), style: {\n            top: annotation.annotationType === exports.AnnotationType.Popup ? '' : '100%',\n        } },\n        title && (React__namespace.createElement(React__namespace.Fragment, null,\n            React__namespace.createElement(\"div\", { className: classNames({\n                    'rpv-core__annotation-popup-title': true,\n                    'rpv-core__annotation-popup-title--ltr': !isRtl,\n                    'rpv-core__annotation-popup-title--rtl': isRtl,\n                }) }, title),\n            React__namespace.createElement(\"div\", { className: \"rpv-core__annotation-popup-date\" }, dateStr))),\n        contents && (React__namespace.createElement(\"div\", { className: \"rpv-core__annotation-popup-content\" }, contents.split('\\n').map(function (item, index) { return (React__namespace.createElement(React__namespace.Fragment, { key: index },\n            item,\n            React__namespace.createElement(\"br\", null))); })))));\n};\n\nvar TogglePopupBy;\n(function (TogglePopupBy) {\n    TogglePopupBy[\"Click\"] = \"Click\";\n    TogglePopupBy[\"Hover\"] = \"Hover\";\n})(TogglePopupBy || (TogglePopupBy = {}));\nvar useTogglePopup = function () {\n    var _a = useToggle(false), opened = _a.opened, toggle = _a.toggle;\n    var _b = React__namespace.useState(TogglePopupBy.Hover), togglePopupBy = _b[0], setTooglePopupBy = _b[1];\n    var toggleOnClick = function () {\n        switch (togglePopupBy) {\n            case TogglePopupBy.Click:\n                opened && setTooglePopupBy(TogglePopupBy.Hover);\n                toggle(exports.ToggleStatus.Toggle);\n                break;\n            case TogglePopupBy.Hover:\n                setTooglePopupBy(TogglePopupBy.Click);\n                toggle(exports.ToggleStatus.Open);\n                break;\n        }\n    };\n    var openOnHover = function () {\n        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Open);\n    };\n    var closeOnHover = function () {\n        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Close);\n    };\n    return {\n        opened: opened,\n        closeOnHover: closeOnHover,\n        openOnHover: openOnHover,\n        toggleOnClick: toggleOnClick,\n    };\n};\n\nvar Annotation = function (_a) {\n    var annotation = _a.annotation, children = _a.children, ignoreBorder = _a.ignoreBorder, hasPopup = _a.hasPopup, isRenderable = _a.isRenderable, page = _a.page, viewport = _a.viewport;\n    var rect = annotation.rect;\n    var _b = useTogglePopup(), closeOnHover = _b.closeOnHover, opened = _b.opened, openOnHover = _b.openOnHover, toggleOnClick = _b.toggleOnClick;\n    var normalizeRect = function (r) { return [\n        Math.min(r[0], r[2]),\n        Math.min(r[1], r[3]),\n        Math.max(r[0], r[2]),\n        Math.max(r[1], r[3]),\n    ]; };\n    var bound = normalizeRect([\n        rect[0],\n        page.view[3] + page.view[1] - rect[1],\n        rect[2],\n        page.view[3] + page.view[1] - rect[3],\n    ]);\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var styles = {\n        borderColor: '',\n        borderRadius: '',\n        borderStyle: '',\n        borderWidth: '',\n    };\n    if (!ignoreBorder && annotation.borderStyle.width > 0) {\n        switch (annotation.borderStyle.style) {\n            case AnnotationBorderStyleType.Dashed:\n                styles.borderStyle = 'dashed';\n                break;\n            case AnnotationBorderStyleType.Solid:\n                styles.borderStyle = 'solid';\n                break;\n            case AnnotationBorderStyleType.Underline:\n                styles = Object.assign({\n                    borderBottomStyle: 'solid',\n                }, styles);\n                break;\n            case AnnotationBorderStyleType.Beveled:\n            case AnnotationBorderStyleType.Inset:\n        }\n        var borderWidth = annotation.borderStyle.width;\n        styles.borderWidth = \"\".concat(borderWidth, \"px\");\n        if (annotation.borderStyle.style !== AnnotationBorderStyleType.Underline) {\n            width = width - 2 * borderWidth;\n            height = height - 2 * borderWidth;\n        }\n        var _c = annotation.borderStyle, horizontalCornerRadius = _c.horizontalCornerRadius, verticalCornerRadius = _c.verticalCornerRadius;\n        if (horizontalCornerRadius > 0 || verticalCornerRadius > 0) {\n            styles.borderRadius = \"\".concat(horizontalCornerRadius, \"px / \").concat(verticalCornerRadius, \"px\");\n        }\n        annotation.color\n            ? (styles.borderColor = \"rgb(\".concat(annotation.color[0] | 0, \", \").concat(annotation.color[1] | 0, \", \").concat(annotation.color[2] | 0, \")\"))\n            :\n                (styles.borderWidth = '0');\n    }\n    return (React__namespace.createElement(React__namespace.Fragment, null, isRenderable &&\n        children({\n            popup: {\n                opened: opened,\n                closeOnHover: closeOnHover,\n                openOnHover: openOnHover,\n                toggleOnClick: toggleOnClick,\n            },\n            slot: {\n                attrs: {\n                    style: Object.assign({\n                        height: \"\".concat(height, \"px\"),\n                        left: \"\".concat(bound[0], \"px\"),\n                        top: \"\".concat(bound[1], \"px\"),\n                        transform: \"matrix(\".concat(viewport.transform.join(','), \")\"),\n                        transformOrigin: \"-\".concat(bound[0], \"px -\").concat(bound[1], \"px\"),\n                        width: \"\".concat(width, \"px\"),\n                    }, styles),\n                },\n                children: React__namespace.createElement(React__namespace.Fragment, null, hasPopup && opened && React__namespace.createElement(PopupWrapper, { annotation: annotation })),\n            },\n        })));\n};\n\nvar Caret = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--caret\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar Circle = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--circle\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"circle\", { cy: height / 2, fill: \"none\", rx: width / 2 - borderWidth / 2, ry: height / 2 - borderWidth / 2, stroke: \"transparent\", strokeWidth: borderWidth || 1 })),\n        props.slot.children)); }));\n};\n\nvar getFileName = function (url) {\n    var str = url.split('/').pop();\n    return str ? str.split('#')[0].split('?')[0] : url;\n};\n\nvar downloadFile = function (url, data) {\n    var blobUrl = typeof data === 'string' ? '' : URL.createObjectURL(new Blob([data], { type: '' }));\n    var link = document.createElement('a');\n    link.style.display = 'none';\n    link.href = blobUrl || url;\n    link.setAttribute('download', getFileName(url));\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    if (blobUrl) {\n        URL.revokeObjectURL(blobUrl);\n    }\n};\n\nvar FileAttachment = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var hasPopup = annotation.hasPopup === false && (!!title || !!contents);\n    var doubleClick = function () {\n        var file = annotation.file;\n        file && downloadFile(file.filename, file.content);\n    };\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: true, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--file-attachment\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onDoubleClick: doubleClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar FreeText = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--free-text\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar Popup = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(title || contents);\n    var ignoredParents = ['Circle', 'Ink', 'Line', 'Polygon', 'PolyLine', 'Square'];\n    var hasPopup = !annotation.parentType || ignoredParents.indexOf(annotation.parentType) !== -1;\n    useIsomorphicLayoutEffect(function () {\n        if (!annotation.parentId) {\n            return;\n        }\n        var parent = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.parentId, \"\\\"]\"));\n        var container = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.id, \"\\\"]\"));\n        if (!parent || !container) {\n            return;\n        }\n        var left = parseFloat(parent.style.left);\n        var top = parseFloat(parent.style.top) + parseFloat(parent.style.height);\n        container.style.left = \"\".concat(left, \"px\");\n        container.style.top = \"\".concat(top, \"px\");\n        container.style.transformOrigin = \"-\".concat(left, \"px -\").concat(top, \"px\");\n    }, []);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--popup\", \"data-annotation-id\": annotation.id }),\n        React__namespace.createElement(PopupWrapper, { annotation: annotation }))); }));\n};\n\nvar Highlight = function (_a) {\n    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var hasQuadPoints = annotation.quadPoints && annotation.quadPoints.length > 0;\n    if (hasQuadPoints) {\n        var annotations = annotation.quadPoints.map(function (quadPoint) {\n            return Object.assign({}, annotation, {\n                rect: [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y],\n                quadPoints: [],\n            });\n        });\n        return (React__namespace.createElement(React__namespace.Fragment, null, annotations.map(function (ann, index) { return (React__namespace.createElement(Highlight, { key: index, annotation: ann, childAnnotation: childAnnotation, page: page, viewport: viewport })); })));\n    }\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--highlight\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children),\n        childAnnotation &&\n            childAnnotation.annotationType === exports.AnnotationType.Popup &&\n            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));\n};\n\nvar Ink = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--ink\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        annotation.inkLists && annotation.inkLists.length && (React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") }, annotation.inkLists.map(function (inkList, index) { return (React__namespace.createElement(\"polyline\", { key: index, fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, points: inkList.map(function (item) { return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y); }).join(' ') })); }))),\n        props.slot.children)); }));\n};\n\nvar Line = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--line\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"line\", { stroke: \"transparent\", strokeWidth: borderWidth || 1, x1: rect[2] - annotation.lineCoordinates[0], x2: rect[2] - annotation.lineCoordinates[2], y1: rect[3] - annotation.lineCoordinates[1], y2: rect[3] - annotation.lineCoordinates[3] })),\n        props.slot.children)); }));\n};\n\nvar INVALID_PROTOCOL = /^([^\\w]*)(javascript|data|vbscript)/im;\nvar HTML_ENTITIES = /&#(\\w+)(^\\w|;)?/g;\nvar CTRL_CHARS = /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nvar URL_SCHEME = /^([^:]+):/gm;\nvar decodeHtmlEntities = function (str) { return str.replace(HTML_ENTITIES, function (_, dec) { return String.fromCharCode(dec); }); };\nvar sanitizeUrl = function (url, defaultUrl) {\n    if (defaultUrl === void 0) { defaultUrl = 'about:blank'; }\n    var result = decodeHtmlEntities(url || '')\n        .replace(CTRL_CHARS, '')\n        .trim();\n    if (!result) {\n        return defaultUrl;\n    }\n    var firstChar = result[0];\n    if (firstChar === '.' || firstChar === '/') {\n        return result;\n    }\n    var parsedUrlScheme = result.match(URL_SCHEME);\n    if (!parsedUrlScheme) {\n        return result;\n    }\n    var scheme = parsedUrlScheme[0];\n    return INVALID_PROTOCOL.test(scheme) ? defaultUrl : result;\n};\n\nvar Link = function (_a) {\n    var _b;\n    var annotation = _a.annotation, annotationContainerRef = _a.annotationContainerRef, doc = _a.doc, outlines = _a.outlines, page = _a.page, pageIndex = _a.pageIndex, scale = _a.scale, viewport = _a.viewport, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest;\n    var elementRef = React__namespace.useRef();\n    var title = outlines && outlines.length && annotation.dest && typeof annotation.dest === 'string'\n        ? (_b = outlines.find(function (item) { return item.dest === annotation.dest; })) === null || _b === void 0 ? void 0 : _b.title\n        : '';\n    var link = function (e) {\n        e.preventDefault();\n        annotation.action\n            ? onExecuteNamedAction(annotation.action)\n            : getDestination(doc, annotation.dest).then(function (target) {\n                var element = elementRef.current;\n                var annotationContainer = annotationContainerRef.current;\n                if (element && annotationContainer) {\n                    var linkRect = element.getBoundingClientRect();\n                    annotationContainer.style.setProperty('height', '100%');\n                    annotationContainer.style.setProperty('width', '100%');\n                    var annotationLayerRect = annotationContainer.getBoundingClientRect();\n                    annotationContainer.style.removeProperty('height');\n                    annotationContainer.style.removeProperty('width');\n                    var leftOffset = (linkRect.left - annotationLayerRect.left) / scale;\n                    var bottomOffset = (annotationLayerRect.bottom - linkRect.bottom + linkRect.height) / scale;\n                    onJumpFromLinkAnnotation({\n                        bottomOffset: bottomOffset,\n                        label: title,\n                        leftOffset: leftOffset,\n                        pageIndex: pageIndex,\n                    });\n                }\n                onJumpToDest(target);\n            });\n    };\n    var isRenderable = !!(annotation.url || annotation.dest || annotation.action || annotation.unsafeUrl);\n    var attrs = {};\n    if (annotation.url || annotation.unsafeUrl) {\n        var targetUrl = sanitizeUrl(annotation.url || annotation.unsafeUrl, '');\n        if (targetUrl) {\n            attrs = {\n                'data-target': 'external',\n                href: targetUrl,\n                rel: 'noopener noreferrer nofollow',\n                target: annotation.newWindow ? '_blank' : '',\n                title: targetUrl,\n            };\n        }\n        else {\n            isRenderable = false;\n        }\n    }\n    else {\n        attrs = {\n            href: '',\n            'data-annotation-link': annotation.id,\n            onClick: link,\n        };\n    }\n    if (title) {\n        attrs = Object.assign({}, attrs, {\n            title: title,\n            'aria-label': title,\n        });\n    }\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: false, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--link\", \"data-annotation-id\": annotation.id, \"data-testid\": \"core__annotation--link-\".concat(annotation.id) }),\n        React__namespace.createElement(\"a\", __assign({ ref: elementRef }, attrs)))); }));\n};\n\nvar Polygon = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--polygon\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        annotation.vertices && annotation.vertices.length && (React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"polygon\", { fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, points: annotation.vertices\n                    .map(function (item) { return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y); })\n                    .join(' ') }))),\n        props.slot.children)); }));\n};\n\nvar Polyline = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--polyline\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        annotation.vertices && annotation.vertices.length && (React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"polyline\", { fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, points: annotation.vertices\n                    .map(function (item) { return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y); })\n                    .join(' ') }))),\n        props.slot.children)); }));\n};\n\nvar Square = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--square\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"rect\", { height: height - borderWidth, fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, x: borderWidth / 2, y: borderWidth / 2, width: width - borderWidth })),\n        props.slot.children)); }));\n};\n\nvar Squiggly = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--squiggly\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar Stamp = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--stamp\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar StrikeOut = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--strike-out\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar CommentIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25\" }),\n    React__namespace.createElement(\"path\", { d: \"M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75\" }),\n    React__namespace.createElement(\"path\", { d: \"M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25\" }))); };\n\nvar HelpIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M21.423 5.406L17.415 9.414\" }),\n    React__namespace.createElement(\"path\", { d: \"M14.587 6.585L18.607 2.565\" }),\n    React__namespace.createElement(\"path\", { d: \"M5.405 21.424L9.413 17.416\" }),\n    React__namespace.createElement(\"path\", { d: \"M6.585 14.588L2.577 18.596\" }),\n    React__namespace.createElement(\"path\", { d: \"M18.602 21.419L14.595 17.412\" }),\n    React__namespace.createElement(\"path\", { d: \"M17.419 14.58L21.428 18.589\" }),\n    React__namespace.createElement(\"path\", { d: \"M2.582 5.399L6.588 9.406\" }),\n    React__namespace.createElement(\"path\", { d: \"M9.421 6.581L5.412 2.572\" }))); };\n\nvar KeyIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z\" }))); };\n\nvar NoteIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M6 4.5L6 0.5\" }),\n    React__namespace.createElement(\"path\", { d: \"M18 4.5L18 0.5\" }),\n    React__namespace.createElement(\"path\", { d: \"M10 4.5L10 0.5\" }),\n    React__namespace.createElement(\"path\", { d: \"M14 4.5L14 0.5\" }))); };\n\nvar ParagraphIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M17.5 0.498L17.5 23.498\" }),\n    React__namespace.createElement(\"path\", { d: \"M10.5 0.498L10.5 23.498\" }),\n    React__namespace.createElement(\"path\", { d: \"M23.5.5H6.5a6,6,0,0,0,0,12h4\" }))); };\n\nvar TriangleIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z\" }))); };\n\nvar Text = function (_a) {\n    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var name = annotation.name ? annotation.name.toLowerCase() : '';\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--text\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n            name && (React__namespace.createElement(\"div\", { className: \"rpv-core__annotation-text-icon\" },\n                name === 'check' && React__namespace.createElement(CheckIcon, null),\n                name === 'comment' && React__namespace.createElement(CommentIcon, null),\n                name === 'help' && React__namespace.createElement(HelpIcon, null),\n                name === 'insert' && React__namespace.createElement(TriangleIcon, null),\n                name === 'key' && React__namespace.createElement(KeyIcon, null),\n                name === 'note' && React__namespace.createElement(NoteIcon, null),\n                (name === 'newparagraph' || name === 'paragraph') && React__namespace.createElement(ParagraphIcon, null))),\n            props.slot.children),\n        childAnnotation &&\n            childAnnotation.annotationType === exports.AnnotationType.Popup &&\n            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));\n};\n\nvar Underline = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--underline\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar AnnotationLayerBody = function (_a) {\n    var annotations = _a.annotations, doc = _a.doc, outlines = _a.outlines, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest;\n    var containerRef = React__namespace.useRef();\n    var viewport = page.getViewport({ rotation: rotation, scale: scale });\n    var clonedViewPort = viewport.clone({ dontFlip: true });\n    var filterAnnotations = annotations.filter(function (annotation) { return !annotation.parentId; });\n    useIsomorphicLayoutEffect(function () {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        plugins.forEach(function (plugin) {\n            if (plugin.onAnnotationLayerRender) {\n                plugin.onAnnotationLayerRender({\n                    annotations: filterAnnotations,\n                    container: container,\n                    pageIndex: pageIndex,\n                    rotation: rotation,\n                    scale: scale,\n                });\n            }\n        });\n    }, []);\n    return (React__namespace.createElement(\"div\", { ref: containerRef, className: \"rpv-core__annotation-layer\", \"data-testid\": \"core__annotation-layer-\".concat(pageIndex) }, filterAnnotations.map(function (annotation) {\n        var childAnnotation = annotations.find(function (item) { return item.parentId === annotation.id; });\n        switch (annotation.annotationType) {\n            case exports.AnnotationType.Caret:\n                return (React__namespace.createElement(Caret, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Circle:\n                return (React__namespace.createElement(Circle, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.FileAttachment:\n                return (React__namespace.createElement(FileAttachment, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.FreeText:\n                return (React__namespace.createElement(FreeText, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Highlight:\n                return (React__namespace.createElement(Highlight, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Ink:\n                return (React__namespace.createElement(Ink, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Line:\n                return (React__namespace.createElement(Line, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Link:\n                return (React__namespace.createElement(Link, { key: annotation.id, annotation: annotation, annotationContainerRef: containerRef, doc: doc, outlines: outlines, page: page, pageIndex: pageIndex, scale: scale, viewport: clonedViewPort, onExecuteNamedAction: onExecuteNamedAction, onJumpFromLinkAnnotation: onJumpFromLinkAnnotation, onJumpToDest: onJumpToDest }));\n            case exports.AnnotationType.Polygon:\n                return (React__namespace.createElement(Polygon, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Polyline:\n                return (React__namespace.createElement(Polyline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Popup:\n                return (React__namespace.createElement(Popup, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Square:\n                return (React__namespace.createElement(Square, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Squiggly:\n                return (React__namespace.createElement(Squiggly, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Stamp:\n                return (React__namespace.createElement(Stamp, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.StrikeOut:\n                return (React__namespace.createElement(StrikeOut, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Text:\n                return (React__namespace.createElement(Text, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Underline:\n                return (React__namespace.createElement(Underline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            default:\n                return React__namespace.createElement(React__namespace.Fragment, { key: annotation.id });\n        }\n    })));\n};\n\nvar AnnotationLoader = function (_a) {\n    var page = _a.page, renderAnnotations = _a.renderAnnotations;\n    var isMounted = useIsMounted();\n    var _b = React__namespace.useState({\n        loading: true,\n        annotations: [],\n    }), status = _b[0], setStatus = _b[1];\n    React__namespace.useEffect(function () {\n        page.getAnnotations({ intent: 'display' }).then(function (result) {\n            if (isMounted.current) {\n                setStatus({\n                    loading: false,\n                    annotations: result,\n                });\n            }\n        });\n    }, []);\n    return status.loading ? React__namespace.createElement(React__namespace.Fragment, null) : renderAnnotations(status.annotations);\n};\n\nvar AnnotationLayer = function (_a) {\n    var doc = _a.doc, outlines = _a.outlines, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest;\n    var renderAnnotations = function (annotations) { return (React__namespace.createElement(AnnotationLayerBody, { annotations: annotations, doc: doc, outlines: outlines, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotation, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpFromLinkAnnotation: onJumpFromLinkAnnotation, onJumpToDest: onJumpToDest })); };\n    return React__namespace.createElement(AnnotationLoader, { page: page, renderAnnotations: renderAnnotations });\n};\n\nvar floatToRatio = function (x, limit) {\n    var _a, _b;\n    if (Math.floor(x) === x) {\n        return [x, 1];\n    }\n    var y = 1 / x;\n    if (y > limit) {\n        return [1, limit];\n    }\n    if (Math.floor(y) === y) {\n        return [1, y];\n    }\n    var value = x > 1 ? y : x;\n    var a = 0;\n    var b = 1;\n    var c = 1;\n    var d = 1;\n    while (true) {\n        var numerator = a + c;\n        var denominator = b + d;\n        if (denominator > limit) {\n            break;\n        }\n        value <= numerator / denominator ? (_a = [numerator, denominator], c = _a[0], d = _a[1], _a) : (_b = [numerator, denominator], a = _b[0], b = _b[1], _b);\n    }\n    var middle = (a / b + c / d) / 2;\n    return value < middle ? (value === x ? [a, b] : [b, a]) : value === x ? [c, d] : [d, c];\n};\n\nvar roundToDivide = function (a, b) {\n    var remainder = a % b;\n    return remainder === 0 ? a : Math.floor(a - remainder);\n};\n\nvar MAX_CANVAS_SIZE = 4096 * 4096;\nvar CanvasLayer = function (_a) {\n    var canvasLayerRef = _a.canvasLayerRef, height = _a.height, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, width = _a.width, onRenderCanvasCompleted = _a.onRenderCanvasCompleted;\n    var renderTask = React__namespace.useRef();\n    useIsomorphicLayoutEffect(function () {\n        var task = renderTask.current;\n        if (task) {\n            task.cancel();\n        }\n        var canvasEle = canvasLayerRef.current;\n        canvasEle.removeAttribute('data-testid');\n        plugins.forEach(function (plugin) {\n            if (plugin.onCanvasLayerRender) {\n                plugin.onCanvasLayerRender({\n                    ele: canvasEle,\n                    pageIndex: pageIndex,\n                    rotation: rotation,\n                    scale: scale,\n                    status: exports.LayerRenderStatus.PreRender,\n                });\n            }\n        });\n        var viewport = page.getViewport({\n            rotation: rotation,\n            scale: scale,\n        });\n        var outputScale = window.devicePixelRatio || 1;\n        var maxScale = Math.sqrt(MAX_CANVAS_SIZE / (viewport.width * viewport.height));\n        var shouldScaleByCSS = outputScale > maxScale;\n        shouldScaleByCSS ? (canvasEle.style.transform = \"scale(1, 1)\") : canvasEle.style.removeProperty('transform');\n        var possibleScale = Math.min(maxScale, outputScale);\n        var _a = floatToRatio(possibleScale, 8), x = _a[0], y = _a[1];\n        canvasEle.width = roundToDivide(viewport.width * possibleScale, x);\n        canvasEle.height = roundToDivide(viewport.height * possibleScale, x);\n        canvasEle.style.width = \"\".concat(roundToDivide(viewport.width, y), \"px\");\n        canvasEle.style.height = \"\".concat(roundToDivide(viewport.height, y), \"px\");\n        canvasEle.hidden = true;\n        var canvasContext = canvasEle.getContext('2d', { alpha: false });\n        var transform = shouldScaleByCSS || outputScale !== 1 ? [possibleScale, 0, 0, possibleScale, 0, 0] : null;\n        renderTask.current = page.render({ canvasContext: canvasContext, transform: transform, viewport: viewport });\n        renderTask.current.promise.then(function () {\n            canvasEle.hidden = false;\n            canvasEle.setAttribute('data-testid', \"core__canvas-layer-\".concat(pageIndex));\n            plugins.forEach(function (plugin) {\n                if (plugin.onCanvasLayerRender) {\n                    plugin.onCanvasLayerRender({\n                        ele: canvasEle,\n                        pageIndex: pageIndex,\n                        rotation: rotation,\n                        scale: scale,\n                        status: exports.LayerRenderStatus.DidRender,\n                    });\n                }\n            });\n            onRenderCanvasCompleted();\n        }, function () {\n            onRenderCanvasCompleted();\n        });\n        return function () {\n            if (canvasEle) {\n                canvasEle.width = 0;\n                canvasEle.height = 0;\n            }\n        };\n    }, []);\n    return (React__namespace.createElement(\"div\", { className: \"rpv-core__canvas-layer\", style: {\n            height: \"\".concat(height, \"px\"),\n            width: \"\".concat(width, \"px\"),\n        } },\n        React__namespace.createElement(\"canvas\", { ref: canvasLayerRef })));\n};\n\nvar SvgLayer = function (_a) {\n    var height = _a.height, page = _a.page, rotation = _a.rotation, scale = _a.scale, width = _a.width;\n    var containerRef = React__namespace.useRef();\n    var empty = function () {\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        containerEle.innerHTML = '';\n    };\n    useIsomorphicLayoutEffect(function () {\n        var containerEle = containerRef.current;\n        var viewport = page.getViewport({ rotation: rotation, scale: scale });\n        page.getOperatorList().then(function (operatorList) {\n            empty();\n            var graphic = new PdfJsApi__namespace.SVGGraphics(page.commonObjs, page.objs);\n            graphic.getSVG(operatorList, viewport).then(function (svg) {\n                svg.style.height = \"\".concat(height, \"px\");\n                svg.style.width = \"\".concat(width, \"px\");\n                containerEle.appendChild(svg);\n            });\n        });\n    }, []);\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__svg-layer\", ref: containerRef });\n};\n\nvar TextLayer = function (_a) {\n    var containerRef = _a.containerRef, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onRenderTextCompleted = _a.onRenderTextCompleted;\n    var renderTask = React__namespace.useRef();\n    var empty = function () {\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        var spans = [].slice.call(containerEle.querySelectorAll('.rpv-core__text-layer-text'));\n        spans.forEach(function (span) { return containerEle.removeChild(span); });\n        var breaks = [].slice.call(containerEle.querySelectorAll('br[role=\"presentation\"]'));\n        breaks.forEach(function (br) { return containerEle.removeChild(br); });\n    };\n    useIsomorphicLayoutEffect(function () {\n        var task = renderTask.current;\n        if (task) {\n            task.cancel();\n        }\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        containerEle.removeAttribute('data-testid');\n        var viewport = page.getViewport({ rotation: rotation, scale: scale });\n        plugins.forEach(function (plugin) {\n            if (plugin.onTextLayerRender) {\n                plugin.onTextLayerRender({\n                    ele: containerEle,\n                    pageIndex: pageIndex,\n                    scale: scale,\n                    status: exports.LayerRenderStatus.PreRender,\n                });\n            }\n        });\n        page.getTextContent().then(function (textContent) {\n            empty();\n            renderTask.current = PdfJsApi__namespace.renderTextLayer({\n                container: containerEle,\n                textContent: textContent,\n                textContentSource: textContent,\n                viewport: viewport,\n            });\n            renderTask.current.promise.then(function () {\n                containerEle.setAttribute('data-testid', \"core__text-layer-\".concat(pageIndex));\n                var spans = [].slice.call(containerEle.children);\n                spans.forEach(function (span) {\n                    if (!span.classList.contains('rpv-core__text-layer-text--not')) {\n                        span.classList.add('rpv-core__text-layer-text');\n                    }\n                });\n                plugins.forEach(function (plugin) {\n                    if (plugin.onTextLayerRender) {\n                        plugin.onTextLayerRender({\n                            ele: containerEle,\n                            pageIndex: pageIndex,\n                            scale: scale,\n                            status: exports.LayerRenderStatus.DidRender,\n                        });\n                    }\n                });\n                onRenderTextCompleted();\n            }, function () {\n                containerEle.removeAttribute('data-testid');\n                onRenderTextCompleted();\n            });\n        });\n        return function () {\n            var _a;\n            empty();\n            (_a = renderTask.current) === null || _a === void 0 ? void 0 : _a.cancel();\n        };\n    }, []);\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__text-layer\", ref: containerRef });\n};\n\nvar PageLayer = function (_a) {\n    var doc = _a.doc, measureRef = _a.measureRef, outlines = _a.outlines, pageIndex = _a.pageIndex, pageRotation = _a.pageRotation, pageSize = _a.pageSize, plugins = _a.plugins, renderPage = _a.renderPage, renderQueueKey = _a.renderQueueKey, rotation = _a.rotation, scale = _a.scale, shouldRender = _a.shouldRender, viewMode = _a.viewMode, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest, onRenderCompleted = _a.onRenderCompleted, onRotatePage = _a.onRotatePage;\n    var isMounted = useIsMounted();\n    var _b = React__namespace.useState(null), page = _b[0], setPage = _b[1];\n    var _c = React__namespace.useState(false), canvasLayerRendered = _c[0], setCanvasLayerRendered = _c[1];\n    var _d = React__namespace.useState(false), textLayerRendered = _d[0], setTextLayerRendered = _d[1];\n    var canvasLayerRef = React__namespace.useRef();\n    var textLayerRef = React__namespace.useRef();\n    var isVertical = Math.abs(rotation + pageRotation) % 180 === 0;\n    var scaledWidth = pageSize.pageWidth * scale;\n    var scaledHeight = pageSize.pageHeight * scale;\n    var w = isVertical ? scaledWidth : scaledHeight;\n    var h = isVertical ? scaledHeight : scaledWidth;\n    var rotationValue = (pageSize.rotation + rotation + pageRotation) % 360;\n    var renderQueueKeyRef = React__namespace.useRef(0);\n    var determinePageInstance = function () {\n        getPage(doc, pageIndex).then(function (pdfPage) {\n            if (isMounted.current) {\n                renderQueueKeyRef.current = renderQueueKey;\n                setPage(pdfPage);\n            }\n        });\n    };\n    var defaultPageRenderer = function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,\n        props.canvasLayer.children,\n        props.textLayer.children,\n        props.annotationLayer.children)); };\n    var renderPageLayer = renderPage || defaultPageRenderer;\n    var handleRenderCanvasCompleted = function () {\n        if (isMounted.current) {\n            setCanvasLayerRendered(true);\n        }\n    };\n    var handleRenderTextCompleted = function () {\n        if (isMounted.current) {\n            setTextLayerRendered(true);\n        }\n    };\n    React__namespace.useEffect(function () {\n        setPage(null);\n        setCanvasLayerRendered(false);\n        setTextLayerRendered(false);\n    }, [pageRotation, rotation, scale]);\n    React__namespace.useEffect(function () {\n        if (shouldRender && isMounted.current && !page) {\n            determinePageInstance();\n        }\n    }, [shouldRender, page]);\n    React__namespace.useEffect(function () {\n        if (canvasLayerRendered && textLayerRendered) {\n            if (renderQueueKey !== renderQueueKeyRef.current) {\n                setPage(null);\n                setCanvasLayerRendered(false);\n                setTextLayerRendered(false);\n            }\n            else {\n                onRenderCompleted(pageIndex);\n            }\n        }\n    }, [canvasLayerRendered, textLayerRendered]);\n    return (React__namespace.createElement(\"div\", { className: classNames({\n            'rpv-core__page-layer': true,\n            'rpv-core__page-layer--dual': viewMode === exports.ViewMode.DualPage,\n            'rpv-core__page-layer--dual-cover': viewMode === exports.ViewMode.DualPageWithCover,\n            'rpv-core__page-layer--single': viewMode === exports.ViewMode.SinglePage,\n        }), \"data-testid\": \"core__page-layer-\".concat(pageIndex), ref: measureRef, style: {\n            height: \"\".concat(h, \"px\"),\n            width: \"\".concat(w, \"px\"),\n        } }, !page ? (React__namespace.createElement(Spinner, { testId: \"core__page-layer-loading-\".concat(pageIndex) })) : (React__namespace.createElement(React__namespace.Fragment, null,\n        renderPageLayer({\n            annotationLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(AnnotationLayer, { doc: doc, outlines: outlines, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationValue, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpFromLinkAnnotation: onJumpFromLinkAnnotation, onJumpToDest: onJumpToDest })),\n            },\n            canvasLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(CanvasLayer, { canvasLayerRef: canvasLayerRef, height: h, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationValue, scale: scale, width: w, onRenderCanvasCompleted: handleRenderCanvasCompleted })),\n            },\n            canvasLayerRendered: canvasLayerRendered,\n            doc: doc,\n            height: h,\n            pageIndex: pageIndex,\n            rotation: rotationValue,\n            scale: scale,\n            svgLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(SvgLayer, { height: h, page: page, rotation: rotationValue, scale: scale, width: w })),\n            },\n            textLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(TextLayer, { containerRef: textLayerRef, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationValue, scale: scale, onRenderTextCompleted: handleRenderTextCompleted })),\n            },\n            textLayerRendered: textLayerRendered,\n            width: w,\n            markRendered: onRenderCompleted,\n            onRotatePage: function (direction) { return onRotatePage(pageIndex, direction); },\n        }),\n        plugins.map(function (plugin, idx) {\n            return plugin.renderPageLayer ? (React__namespace.createElement(React__namespace.Fragment, { key: idx }, plugin.renderPageLayer({\n                canvasLayerRef: canvasLayerRef,\n                canvasLayerRendered: canvasLayerRendered,\n                doc: doc,\n                height: h,\n                pageIndex: pageIndex,\n                rotation: rotationValue,\n                scale: scale,\n                textLayerRef: textLayerRef,\n                textLayerRendered: textLayerRendered,\n                width: w,\n            }))) : (React__namespace.createElement(React__namespace.Fragment, { key: idx }));\n        })))));\n};\n\nvar getFileExt = function (url) {\n    var str = url.split(/\\./).pop();\n    return str ? str.toLowerCase() : '';\n};\n\nvar rectReducer = function (state, action) {\n    var rect = action.rect;\n    return state.height !== rect.height || state.width !== rect.width ? rect : state;\n};\nvar useMeasureRect = function (_a) {\n    var elementRef = _a.elementRef;\n    var _b = React__namespace.useState(elementRef.current), element = _b[0], setElement = _b[1];\n    var initializedRectRef = React__namespace.useRef(false);\n    var _c = React__namespace.useReducer(rectReducer, { height: 0, width: 0 }), rect = _c[0], dispatch = _c[1];\n    useIsomorphicLayoutEffect(function () {\n        if (elementRef.current !== element) {\n            setElement(elementRef.current);\n        }\n    });\n    useIsomorphicLayoutEffect(function () {\n        if (element && !initializedRectRef.current) {\n            initializedRectRef.current = true;\n            var _a = element.getBoundingClientRect(), height = _a.height, width = _a.width;\n            dispatch({\n                rect: { height: height, width: width },\n            });\n        }\n    }, [element]);\n    React__namespace.useEffect(function () {\n        if (!element) {\n            return;\n        }\n        var tracker = new ResizeObserver(function (entries, __) {\n            entries.forEach(function (entry) {\n                if (entry.target === element) {\n                    var _a = entry.contentRect, height = _a.height, width = _a.width;\n                    dispatch({\n                        rect: { height: height, width: width },\n                    });\n                }\n            });\n        });\n        tracker.observe(element);\n        return function () {\n            tracker.unobserve(element);\n        };\n    }, [element]);\n    return rect;\n};\n\nvar ScrollDirection;\n(function (ScrollDirection) {\n    ScrollDirection[\"Horizontal\"] = \"Horizontal\";\n    ScrollDirection[\"Vertical\"] = \"Vertical\";\n    ScrollDirection[\"Both\"] = \"Both\";\n})(ScrollDirection || (ScrollDirection = {}));\n\nvar easeOutQuart = function (t) { return 1 - Math.pow(1 - t, 4); };\n\nvar EPS = 0.0001;\nvar smoothScroll = function (ele, scrollDirection, targetPosition, duration, easing, onReachTarget) {\n    if (easing === void 0) { easing = function (t) { return t; }; }\n    if (onReachTarget === void 0) { onReachTarget = function () { }; }\n    var top = 0;\n    var left = 0;\n    var reachTarget = false;\n    switch (scrollDirection) {\n        case ScrollDirection.Horizontal:\n            left = ele.scrollLeft;\n            top = 0;\n        case ScrollDirection.Both:\n            left = ele.scrollLeft;\n            top = ele.scrollTop;\n            break;\n        case ScrollDirection.Vertical:\n        default:\n            left = 0;\n            top = ele.scrollTop;\n            break;\n    }\n    var markTargetReached = function () {\n        if (!reachTarget) {\n            reachTarget = true;\n            ele.scrollLeft = targetPosition.left;\n            ele.scrollTop = targetPosition.top;\n            onReachTarget();\n        }\n    };\n    if (Math.abs(top - targetPosition.top) <= EPS && scrollDirection === ScrollDirection.Vertical) {\n        markTargetReached();\n        return;\n    }\n    if (Math.abs(left - targetPosition.left) <= EPS && scrollDirection === ScrollDirection.Horizontal) {\n        markTargetReached();\n        return;\n    }\n    var startTime = -1;\n    var requestId;\n    var offset = {\n        left: left - targetPosition.left,\n        top: top - targetPosition.top,\n    };\n    var loop = function (currentTime) {\n        if (startTime === -1) {\n            startTime = currentTime;\n        }\n        var time = currentTime - startTime;\n        var percent = Math.min(time / duration, 1);\n        var easedPercent = easing(percent);\n        var updatePosition = {\n            left: left - offset.left * easedPercent,\n            top: top - offset.top * easedPercent,\n        };\n        switch (scrollDirection) {\n            case ScrollDirection.Horizontal:\n                ele.scrollLeft = updatePosition.left;\n                break;\n            case ScrollDirection.Both:\n                ele.scrollLeft = updatePosition.left;\n                ele.scrollTop = updatePosition.top;\n                break;\n            case ScrollDirection.Vertical:\n            default:\n                ele.scrollTop = updatePosition.top;\n                break;\n        }\n        if (Math.abs(updatePosition.top - targetPosition.top) <= EPS &&\n            Math.abs(updatePosition.left - targetPosition.left) <= EPS &&\n            !reachTarget) {\n            window.cancelAnimationFrame(requestId);\n            markTargetReached();\n        }\n        if (time < duration) {\n            requestId = window.requestAnimationFrame(loop);\n        }\n        else {\n            window.cancelAnimationFrame(requestId);\n        }\n    };\n    requestId = window.requestAnimationFrame(loop);\n};\n\nvar ZERO_OFFSET$6 = {\n    left: 0,\n    top: 0,\n};\nvar SCROLL_EVENT_OPTIONS = {\n    capture: false,\n    passive: true,\n};\nvar SCROLL_DURATION = 400;\nvar useScroll = function (_a) {\n    var elementRef = _a.elementRef, enableSmoothScroll = _a.enableSmoothScroll, isRtl = _a.isRtl, scrollDirection = _a.scrollDirection, onSmoothScroll = _a.onSmoothScroll;\n    var _b = React__namespace.useState(ZERO_OFFSET$6), scrollOffset = _b[0], setScrollOffset = _b[1];\n    var _c = React__namespace.useState(elementRef.current), element = _c[0], setElement = _c[1];\n    var factor = isRtl ? -1 : 1;\n    var latestRef = React__namespace.useRef(scrollDirection);\n    latestRef.current = scrollDirection;\n    var latestOffsetRef = React__namespace.useRef(ZERO_OFFSET$6);\n    var isSmoothScrollingDoneRef = React__namespace.useRef(true);\n    var handleSmoothScrollingComplete = React__namespace.useCallback(function () {\n        isSmoothScrollingDoneRef.current = true;\n        if (enableSmoothScroll) {\n            setScrollOffset(latestOffsetRef.current);\n        }\n        onSmoothScroll(false);\n    }, []);\n    var handleScroll = React__namespace.useCallback(function () {\n        if (!element) {\n            return;\n        }\n        switch (latestRef.current) {\n            case ScrollDirection.Horizontal:\n                latestOffsetRef.current = {\n                    left: factor * element.scrollLeft,\n                    top: 0,\n                };\n                break;\n            case ScrollDirection.Both:\n                latestOffsetRef.current = {\n                    left: factor * element.scrollLeft,\n                    top: element.scrollTop,\n                };\n                break;\n            case ScrollDirection.Vertical:\n            default:\n                latestOffsetRef.current = {\n                    left: 0,\n                    top: element.scrollTop,\n                };\n                break;\n        }\n        if (!enableSmoothScroll || isSmoothScrollingDoneRef.current) {\n            setScrollOffset(latestOffsetRef.current);\n        }\n    }, [element]);\n    useIsomorphicLayoutEffect(function () {\n        setElement(elementRef.current);\n    });\n    useIsomorphicLayoutEffect(function () {\n        if (!element) {\n            return;\n        }\n        element.addEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);\n        return function () {\n            element.removeEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);\n        };\n    }, [element]);\n    var scrollTo = React__namespace.useCallback(function (targetPosition, withSmoothScroll) {\n        var ele = elementRef.current;\n        if (!ele) {\n            return Promise.resolve();\n        }\n        var updatePosition = {\n            left: 0,\n            top: 0,\n        };\n        switch (latestRef.current) {\n            case ScrollDirection.Horizontal:\n                updatePosition.left = factor * targetPosition.left;\n                break;\n            case ScrollDirection.Both:\n                updatePosition.left = factor * targetPosition.left;\n                updatePosition.top = targetPosition.top;\n                break;\n            case ScrollDirection.Vertical:\n            default:\n                updatePosition.top = targetPosition.top;\n                break;\n        }\n        if (withSmoothScroll) {\n            isSmoothScrollingDoneRef.current = false;\n            onSmoothScroll(true);\n            return new Promise(function (resolve, _) {\n                smoothScroll(ele, latestRef.current, updatePosition, SCROLL_DURATION, easeOutQuart, function () {\n                    handleSmoothScrollingComplete();\n                    resolve();\n                });\n            });\n        }\n        return new Promise(function (resolve, _) {\n            switch (latestRef.current) {\n                case ScrollDirection.Horizontal:\n                    ele.scrollLeft = updatePosition.left;\n                    break;\n                case ScrollDirection.Both:\n                    ele.scrollLeft = updatePosition.left;\n                    ele.scrollTop = updatePosition.top;\n                    break;\n                case ScrollDirection.Vertical:\n                default:\n                    ele.scrollTop = updatePosition.top;\n                    break;\n            }\n            resolve();\n        });\n    }, [elementRef]);\n    return {\n        scrollOffset: scrollOffset,\n        scrollTo: scrollTo,\n    };\n};\n\nvar clamp = function (min, max, value) { return Math.max(min, Math.min(value, max)); };\n\nvar indexOfMax = function (arr) { return arr.reduce(function (prev, curr, i, a) { return (curr > a[prev] ? i : prev); }, 0); };\n\nvar buildContainerStyles = function (totalSize, scrollMode) {\n    switch (scrollMode) {\n        case exports.ScrollMode.Horizontal:\n            return {\n                position: 'relative',\n                height: '100%',\n                width: \"\".concat(totalSize.width, \"px\"),\n            };\n        case exports.ScrollMode.Vertical:\n        default:\n            return {\n                position: 'relative',\n                height: \"\".concat(totalSize.height, \"px\"),\n                width: '100%',\n            };\n    }\n};\n\nvar buildItemContainerStyles = function (item, parentRect, scrollMode) {\n    return scrollMode !== exports.ScrollMode.Page\n        ? {}\n        : {\n            height: \"\".concat(parentRect.height, \"px\"),\n            width: '100%',\n            position: 'absolute',\n            top: 0,\n            transform: \"translateY(\".concat(item.start.top, \"px)\"),\n        };\n};\n\nvar hasDifferentSizes = function (sizes) {\n    var numberOfItems = sizes.length;\n    if (numberOfItems === 1) {\n        return false;\n    }\n    for (var i = 1; i < numberOfItems; i++) {\n        if (sizes[i].height !== sizes[0].height || sizes[i].width !== sizes[0].width) {\n            return true;\n        }\n    }\n    return false;\n};\nvar getMinWidthOfCover = function (sizes, viewMode) {\n    if (viewMode !== exports.ViewMode.DualPageWithCover) {\n        return 0;\n    }\n    if (!hasDifferentSizes(sizes)) {\n        return 2 * sizes[0].width;\n    }\n    var chunkWidths = chunk(sizes.slice(1), 2).map(function (eachChunk) {\n        return eachChunk.length === 2 ? eachChunk[0].width + eachChunk[1].width : eachChunk[0].width;\n    });\n    var widths = [sizes[0].width].concat(chunkWidths);\n    return Math.max.apply(Math, widths);\n};\nvar buildItemStyles = function (item, isRtl, sizes, viewMode, scrollMode) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    var sideProperty = isRtl ? 'right' : 'left';\n    var factor = isRtl ? -1 : 1;\n    var numberOfItems = sizes.length;\n    var left = item.start.left * factor;\n    var _h = item.size, height = _h.height, width = _h.width;\n    if (viewMode === exports.ViewMode.DualPageWithCover) {\n        var transformTop = scrollMode === exports.ScrollMode.Page ? 0 : item.start.top;\n        if (item.index === 0 || (numberOfItems % 2 === 0 && item.index === numberOfItems - 1)) {\n            return _a = {\n                    height: \"\".concat(height, \"px\"),\n                    minWidth: \"\".concat(getMinWidthOfCover(sizes, viewMode), \"px\"),\n                    width: '100%'\n                },\n                _a[sideProperty] = 0,\n                _a.position = 'absolute',\n                _a.top = 0,\n                _a.transform = \"translate(\".concat(left, \"px, \").concat(transformTop, \"px)\"),\n                _a;\n        }\n        return _b = {\n                height: \"\".concat(height, \"px\"),\n                width: \"\".concat(width, \"px\")\n            },\n            _b[sideProperty] = 0,\n            _b.position = 'absolute',\n            _b.top = 0,\n            _b.transform = \"translate(\".concat(left, \"px, \").concat(transformTop, \"px)\"),\n            _b;\n    }\n    if (viewMode === exports.ViewMode.DualPage) {\n        return _c = {\n                height: \"\".concat(height, \"px\"),\n                width: \"\".concat(width, \"px\")\n            },\n            _c[sideProperty] = 0,\n            _c.position = 'absolute',\n            _c.top = 0,\n            _c.transform = \"translate(\".concat(left, \"px, \").concat(scrollMode === exports.ScrollMode.Page ? 0 : item.start.top, \"px)\"),\n            _c;\n    }\n    switch (scrollMode) {\n        case exports.ScrollMode.Horizontal:\n            return _d = {\n                    height: '100%',\n                    width: \"\".concat(width, \"px\")\n                },\n                _d[sideProperty] = 0,\n                _d.position = 'absolute',\n                _d.top = 0,\n                _d.transform = \"translateX(\".concat(left, \"px)\"),\n                _d;\n        case exports.ScrollMode.Page:\n            return _e = {\n                    height: \"\".concat(height, \"px\"),\n                    width: \"\".concat(width, \"px\")\n                },\n                _e[sideProperty] = 0,\n                _e.position = 'absolute',\n                _e.top = 0,\n                _e;\n        case exports.ScrollMode.Wrapped:\n            return _f = {\n                    height: \"\".concat(height, \"px\"),\n                    width: \"\".concat(width, \"px\")\n                },\n                _f[sideProperty] = 0,\n                _f.position = 'absolute',\n                _f.top = 0,\n                _f.transform = \"translate(\".concat(left, \"px, \").concat(item.start.top, \"px)\"),\n                _f;\n        case exports.ScrollMode.Vertical:\n        default:\n            return _g = {\n                    height: \"\".concat(height, \"px\"),\n                    width: '100%'\n                },\n                _g[sideProperty] = 0,\n                _g.position = 'absolute',\n                _g.top = 0,\n                _g.transform = \"translateY(\".concat(item.start.top, \"px)\"),\n                _g;\n    }\n};\n\nvar findNearest = function (low, high, value, getItemValue) {\n    while (low <= high) {\n        var middle = ((low + high) / 2) | 0;\n        var currentValue = getItemValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        }\n        else if (currentValue > value) {\n            high = middle - 1;\n        }\n        else {\n            return middle;\n        }\n    }\n    return low > 0 ? low - 1 : 0;\n};\n\nvar calculateRange = function (scrollDirection, measurements, outerSize, scrollOffset) {\n    var currentOffset = 0;\n    switch (scrollDirection) {\n        case ScrollDirection.Horizontal:\n            currentOffset = scrollOffset.left;\n            break;\n        case ScrollDirection.Vertical:\n        default:\n            currentOffset = scrollOffset.top;\n            break;\n    }\n    var size = measurements.length - 1;\n    var getOffset = function (index) {\n        switch (scrollDirection) {\n            case ScrollDirection.Horizontal:\n                return measurements[index].start.left;\n            case ScrollDirection.Both:\n            case ScrollDirection.Vertical:\n            default:\n                return measurements[index].start.top;\n        }\n    };\n    var start = findNearest(0, size, currentOffset, getOffset);\n    if (scrollDirection === ScrollDirection.Both) {\n        var startTop = measurements[start].start.top;\n        while (start - 1 >= 0 &&\n            measurements[start - 1].start.top === startTop &&\n            measurements[start - 1].start.left >= scrollOffset.left) {\n            start--;\n        }\n    }\n    var end = start;\n    while (end <= size) {\n        var topLeftCorner = {\n            top: measurements[end].start.top - scrollOffset.top,\n            left: measurements[end].start.left - scrollOffset.left,\n        };\n        var visibleSize = {\n            height: outerSize.height - topLeftCorner.top,\n            width: outerSize.width - topLeftCorner.left,\n        };\n        if (scrollDirection === ScrollDirection.Horizontal && visibleSize.width < 0) {\n            break;\n        }\n        if (scrollDirection === ScrollDirection.Vertical && visibleSize.height < 0) {\n            break;\n        }\n        if (scrollDirection === ScrollDirection.Both && (visibleSize.width < 0 || visibleSize.height < 0)) {\n            break;\n        }\n        end++;\n    }\n    return {\n        start: start,\n        end: end,\n    };\n};\n\nvar ZERO_OFFSET$5 = {\n    left: 0,\n    top: 0,\n};\nvar measure = function (numberOfItems, parentRect, sizes, scrollMode) {\n    var measurements = [];\n    var totalWidth = 0;\n    var firstOfRow = {\n        left: 0,\n        top: 0,\n    };\n    var maxHeight = 0;\n    var start = ZERO_OFFSET$5;\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = sizes[i];\n        if (i === 0) {\n            totalWidth = size.width;\n            firstOfRow = {\n                left: 0,\n                top: 0,\n            };\n            maxHeight = size.height;\n        }\n        else {\n            switch (scrollMode) {\n                case exports.ScrollMode.Wrapped:\n                    totalWidth += size.width;\n                    if (totalWidth < parentRect.width) {\n                        start = {\n                            left: measurements[i - 1].end.left,\n                            top: firstOfRow.top,\n                        };\n                        maxHeight = Math.max(maxHeight, size.height);\n                    }\n                    else {\n                        totalWidth = size.width;\n                        start = {\n                            left: firstOfRow.left,\n                            top: firstOfRow.top + maxHeight,\n                        };\n                        firstOfRow = {\n                            left: start.left,\n                            top: start.top,\n                        };\n                        maxHeight = size.height;\n                    }\n                    break;\n                case exports.ScrollMode.Horizontal:\n                case exports.ScrollMode.Vertical:\n                default:\n                    start = measurements[i - 1].end;\n                    break;\n            }\n        }\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_OFFSET$4 = {\n    left: 0,\n    top: 0,\n};\nvar measureDualPage = function (numberOfItems, parentRect, sizes, scrollMode) {\n    var measurements = [];\n    var top = 0;\n    var maxHeight = 0;\n    var start = ZERO_OFFSET$4;\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = {\n            height: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.height, sizes[i].height) : sizes[i].height,\n            width: Math.max(parentRect.width / 2, sizes[i].width),\n        };\n        if (scrollMode === exports.ScrollMode.Page) {\n            start = {\n                left: i % 2 === 0 ? 0 : size.width,\n                top: Math.floor(i / 2) * size.height,\n            };\n        }\n        else {\n            if (i % 2 === 0) {\n                top = top + maxHeight;\n                start = {\n                    left: 0,\n                    top: top,\n                };\n                maxHeight = i === numberOfItems - 1 ? sizes[i].height : Math.max(sizes[i].height, sizes[i + 1].height);\n            }\n            else {\n                start = {\n                    left: measurements[i - 1].end.left,\n                    top: top,\n                };\n            }\n        }\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_OFFSET$3 = {\n    left: 0,\n    top: 0,\n};\nvar measureDualPageWithCover = function (numberOfItems, parentRect, sizes, scrollMode) {\n    var measurements = [];\n    var top = 0;\n    var maxHeight = 0;\n    var start = ZERO_OFFSET$3;\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = i === 0\n            ? {\n                height: scrollMode === exports.ScrollMode.Page\n                    ? Math.max(parentRect.height, sizes[i].height)\n                    : sizes[i].height,\n                width: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.width, sizes[i].width) : sizes[i].width,\n            }\n            : {\n                height: scrollMode === exports.ScrollMode.Page\n                    ? Math.max(parentRect.height, sizes[i].height)\n                    : sizes[i].height,\n                width: Math.max(parentRect.width / 2, sizes[i].width),\n            };\n        if (scrollMode === exports.ScrollMode.Page) {\n            start =\n                i === 0\n                    ? ZERO_OFFSET$3\n                    : {\n                        left: i % 2 === 0 ? size.width : 0,\n                        top: Math.floor((i - 1) / 2) * size.height + measurements[0].end.top,\n                    };\n        }\n        else {\n            if (i === 0) {\n                start = ZERO_OFFSET$3;\n                top = sizes[0].height;\n                maxHeight = 0;\n            }\n            else if (i % 2 === 1) {\n                top = top + maxHeight;\n                start = {\n                    left: 0,\n                    top: top,\n                };\n                maxHeight = i === numberOfItems - 1 ? sizes[i].height : Math.max(sizes[i].height, sizes[i + 1].height);\n            }\n            else {\n                start = {\n                    left: measurements[i - 1].end.left,\n                    top: top,\n                };\n            }\n        }\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_OFFSET$2 = {\n    left: 0,\n    top: 0,\n};\nvar measureSinglePage = function (numberOfItems, parentRect, sizes) {\n    var measurements = [];\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = {\n            height: Math.max(parentRect.height, sizes[i].height),\n            width: Math.max(parentRect.width, sizes[i].width),\n        };\n        var start = i === 0 ? ZERO_OFFSET$2 : measurements[i - 1].end;\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_RECT$2 = {\n    height: 0,\n    width: 0,\n};\nvar ZERO_OFFSET$1 = {\n    left: 0,\n    top: 0,\n};\nvar COMPARE_EPSILON = 0.000000000001;\nvar VIRTUAL_INDEX_ATTR = 'data-virtual-index';\nvar IO_THRESHOLD = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\nvar useVirtual = function (_a) {\n    var enableSmoothScroll = _a.enableSmoothScroll, isRtl = _a.isRtl, numberOfItems = _a.numberOfItems, parentRef = _a.parentRef, setRenderRange = _a.setRenderRange, sizes = _a.sizes, scrollMode = _a.scrollMode, viewMode = _a.viewMode;\n    var _b = React__namespace.useState(false), isSmoothScrolling = _b[0], setSmoothScrolling = _b[1];\n    var onSmoothScroll = React__namespace.useCallback(function (isSmoothScrolling) { return setSmoothScrolling(isSmoothScrolling); }, []);\n    var scrollModeRef = React__namespace.useRef(scrollMode);\n    scrollModeRef.current = scrollMode;\n    var viewModeRef = React__namespace.useRef(viewMode);\n    viewModeRef.current = viewMode;\n    var scrollDirection = scrollMode === exports.ScrollMode.Wrapped || viewMode === exports.ViewMode.DualPageWithCover || viewMode === exports.ViewMode.DualPage\n        ? ScrollDirection.Both\n        : scrollMode === exports.ScrollMode.Horizontal\n            ? ScrollDirection.Horizontal\n            : ScrollDirection.Vertical;\n    var _c = useScroll({\n        elementRef: parentRef,\n        enableSmoothScroll: enableSmoothScroll,\n        isRtl: isRtl,\n        scrollDirection: scrollDirection,\n        onSmoothScroll: onSmoothScroll,\n    }), scrollOffset = _c.scrollOffset, scrollTo = _c.scrollTo;\n    var parentRect = useMeasureRect({\n        elementRef: parentRef,\n    });\n    var latestRef = React__namespace.useRef({\n        scrollOffset: ZERO_OFFSET$1,\n        measurements: [],\n    });\n    latestRef.current.scrollOffset = scrollOffset;\n    var defaultVisibilities = React__namespace.useMemo(function () { return Array(numberOfItems).fill(-1); }, []);\n    var _d = React__namespace.useState(defaultVisibilities), visibilities = _d[0], setVisibilities = _d[1];\n    var intersectionTracker = React__namespace.useMemo(function () {\n        var io = new IntersectionObserver(function (entries) {\n            entries.forEach(function (entry) {\n                var ratio = entry.isIntersecting ? entry.intersectionRatio : -1;\n                var target = entry.target;\n                var indexAttribute = target.getAttribute(VIRTUAL_INDEX_ATTR);\n                if (!indexAttribute) {\n                    return;\n                }\n                var index = parseInt(indexAttribute, 10);\n                if (0 <= index && index < numberOfItems) {\n                    setVisibilities(function (old) {\n                        old[index] = ratio;\n                        return __spreadArray([], old, true);\n                    });\n                }\n            });\n        }, {\n            threshold: IO_THRESHOLD,\n        });\n        return io;\n    }, []);\n    var measurements = React__namespace.useMemo(function () {\n        if (scrollMode === exports.ScrollMode.Page && viewMode === exports.ViewMode.SinglePage) {\n            return measureSinglePage(numberOfItems, parentRect, sizes);\n        }\n        if (viewMode === exports.ViewMode.DualPageWithCover) {\n            return measureDualPageWithCover(numberOfItems, parentRect, sizes, scrollMode);\n        }\n        if (viewMode === exports.ViewMode.DualPage) {\n            return measureDualPage(numberOfItems, parentRect, sizes, scrollMode);\n        }\n        return measure(numberOfItems, parentRect, sizes, scrollMode);\n    }, [scrollMode, sizes, viewMode, parentRect]);\n    var totalSize = measurements[numberOfItems - 1]\n        ? {\n            height: measurements[numberOfItems - 1].end.top,\n            width: measurements[numberOfItems - 1].end.left,\n        }\n        : ZERO_RECT$2;\n    latestRef.current.measurements = measurements;\n    var _e = React__namespace.useMemo(function () {\n        var _a = calculateRange(scrollDirection, measurements, parentRect, scrollOffset), start = _a.start, end = _a.end;\n        var visiblePageVisibilities = visibilities.slice(clamp(0, numberOfItems, start), clamp(0, numberOfItems, end));\n        var maxVisbilityItem = start + indexOfMax(visiblePageVisibilities);\n        maxVisbilityItem = clamp(0, numberOfItems - 1, maxVisbilityItem);\n        var maxVisbilityIndex = maxVisbilityItem;\n        var _b = setRenderRange({\n            endPage: end,\n            numPages: numberOfItems,\n            startPage: start,\n        }), startPage = _b.startPage, endPage = _b.endPage;\n        startPage = Math.max(startPage, 0);\n        endPage = Math.min(endPage, numberOfItems - 1);\n        switch (viewMode) {\n            case exports.ViewMode.DualPageWithCover:\n                if (maxVisbilityItem > 0) {\n                    maxVisbilityIndex = maxVisbilityItem % 2 === 1 ? maxVisbilityItem : maxVisbilityItem - 1;\n                }\n                startPage = startPage === 0 ? 0 : startPage % 2 === 1 ? startPage : startPage - 1;\n                endPage = endPage % 2 === 1 ? endPage - 1 : endPage;\n                if (numberOfItems - endPage <= 2) {\n                    endPage = numberOfItems - 1;\n                }\n                break;\n            case exports.ViewMode.DualPage:\n                maxVisbilityIndex = maxVisbilityItem % 2 === 0 ? maxVisbilityItem : maxVisbilityItem - 1;\n                startPage = startPage % 2 === 0 ? startPage : startPage - 1;\n                endPage = endPage % 2 === 1 ? endPage : endPage - 1;\n                break;\n            case exports.ViewMode.SinglePage:\n            default:\n                maxVisbilityIndex = maxVisbilityItem;\n                break;\n        }\n        return {\n            startPage: startPage,\n            endPage: endPage,\n            maxVisbilityIndex: maxVisbilityIndex,\n        };\n    }, [measurements, parentRect, scrollOffset, viewMode, visibilities]), startPage = _e.startPage, endPage = _e.endPage, maxVisbilityIndex = _e.maxVisbilityIndex;\n    var virtualItems = React__namespace.useMemo(function () {\n        var virtualItems = [];\n        var _loop_1 = function (i) {\n            var item = measurements[i];\n            var virtualItem = __assign(__assign({}, item), { visibility: visibilities[i] !== undefined ? visibilities[i] : -1, measureRef: function (ele) {\n                    if (!ele) {\n                        return;\n                    }\n                    ele.setAttribute(VIRTUAL_INDEX_ATTR, \"\".concat(i));\n                    intersectionTracker.observe(ele);\n                } });\n            virtualItems.push(virtualItem);\n        };\n        for (var i = startPage; i <= endPage; i++) {\n            _loop_1(i);\n        }\n        return virtualItems;\n    }, [startPage, endPage, visibilities, measurements]);\n    var scrollToItem = React__namespace.useCallback(function (index, offset) {\n        var measurements = latestRef.current.measurements;\n        var normalizedIndex = clamp(0, numberOfItems - 1, index);\n        var measurement = measurements[normalizedIndex];\n        var withOffset = scrollModeRef.current === exports.ScrollMode.Page ? ZERO_OFFSET$1 : offset;\n        return measurement\n            ? scrollTo({\n                left: withOffset.left + measurement.start.left,\n                top: withOffset.top + measurement.start.top,\n            }, enableSmoothScroll)\n            : Promise.resolve();\n    }, [scrollTo, enableSmoothScroll]);\n    var scrollToSmallestItemAbove = React__namespace.useCallback(function (index, offset) {\n        var measurements = latestRef.current.measurements;\n        var start = measurements[index].start;\n        var nextItem = measurements.find(function (item) { return item.start.top - start.top > COMPARE_EPSILON; });\n        if (!nextItem) {\n            return Promise.resolve();\n        }\n        var nextIndex = nextItem.index;\n        switch (viewModeRef.current) {\n            case exports.ViewMode.DualPage:\n                nextIndex = nextIndex % 2 === 0 ? nextIndex : nextIndex + 1;\n                break;\n            case exports.ViewMode.DualPageWithCover:\n                nextIndex = nextIndex % 2 === 1 ? nextIndex : nextIndex + 1;\n                break;\n        }\n        return scrollToItem(nextIndex, offset);\n    }, []);\n    var scrollToBiggestItemBelow = React__namespace.useCallback(function (index, offset) {\n        var measurements = latestRef.current.measurements;\n        var start = measurements[index].start;\n        var prevIndex = index;\n        var found = false;\n        for (var i = numberOfItems - 1; i >= 0; i--) {\n            if (start.top - measurements[i].start.top > COMPARE_EPSILON) {\n                found = true;\n                prevIndex = measurements[i].index;\n                break;\n            }\n        }\n        if (!found) {\n            return Promise.resolve();\n        }\n        switch (viewModeRef.current) {\n            case exports.ViewMode.DualPage:\n                prevIndex = prevIndex % 2 === 0 ? prevIndex : prevIndex - 1;\n                break;\n            case exports.ViewMode.DualPageWithCover:\n                prevIndex = prevIndex % 2 === 0 ? prevIndex - 1 : prevIndex;\n                break;\n        }\n        if (prevIndex === index) {\n            prevIndex = index - 1;\n        }\n        return scrollToItem(prevIndex, offset);\n    }, []);\n    var scrollToNextItem = React__namespace.useCallback(function (index, offset) {\n        if (viewModeRef.current === exports.ViewMode.DualPageWithCover || viewModeRef.current === exports.ViewMode.DualPage) {\n            return scrollToSmallestItemAbove(index, offset);\n        }\n        switch (scrollModeRef.current) {\n            case exports.ScrollMode.Wrapped:\n                return scrollToSmallestItemAbove(index, offset);\n            case exports.ScrollMode.Horizontal:\n            case exports.ScrollMode.Vertical:\n            default:\n                return scrollToItem(index + 1, offset);\n        }\n    }, []);\n    var scrollToPreviousItem = React__namespace.useCallback(function (index, offset) {\n        if (viewModeRef.current === exports.ViewMode.DualPageWithCover || viewModeRef.current === exports.ViewMode.DualPage) {\n            return scrollToBiggestItemBelow(index, offset);\n        }\n        switch (scrollModeRef.current) {\n            case exports.ScrollMode.Wrapped:\n                return scrollToBiggestItemBelow(index, offset);\n            case exports.ScrollMode.Horizontal:\n            case exports.ScrollMode.Vertical:\n            default:\n                return scrollToItem(index - 1, offset);\n        }\n    }, []);\n    var getContainerStyles = React__namespace.useCallback(function () { return buildContainerStyles(totalSize, scrollModeRef.current); }, [totalSize]);\n    var getItemContainerStyles = React__namespace.useCallback(function (item) { return buildItemContainerStyles(item, parentRect, scrollModeRef.current); }, [parentRect]);\n    var getItemStyles = React__namespace.useCallback(function (item) { return buildItemStyles(item, isRtl, sizes, viewModeRef.current, scrollModeRef.current); }, [isRtl, sizes]);\n    var zoom = React__namespace.useCallback(function (scale, index) {\n        var _a = latestRef.current, measurements = _a.measurements, scrollOffset = _a.scrollOffset;\n        var normalizedIndex = clamp(0, numberOfItems - 1, index);\n        var measurement = measurements[normalizedIndex];\n        if (measurement) {\n            var updateOffset = scrollModeRef.current === exports.ScrollMode.Page\n                ? {\n                    left: measurement.start.left,\n                    top: measurement.start.top,\n                }\n                : {\n                    left: scrollOffset.left * scale,\n                    top: scrollOffset.top * scale,\n                };\n            return scrollTo(updateOffset, false);\n        }\n        return Promise.resolve();\n    }, []);\n    React__namespace.useEffect(function () {\n        return function () {\n            intersectionTracker.disconnect();\n        };\n    }, []);\n    return {\n        boundingClientRect: parentRect,\n        isSmoothScrolling: isSmoothScrolling,\n        startPage: startPage,\n        endPage: endPage,\n        maxVisbilityIndex: maxVisbilityIndex,\n        virtualItems: virtualItems,\n        getContainerStyles: getContainerStyles,\n        getItemContainerStyles: getItemContainerStyles,\n        getItemStyles: getItemStyles,\n        scrollToItem: scrollToItem,\n        scrollToNextItem: scrollToNextItem,\n        scrollToPreviousItem: scrollToPreviousItem,\n        zoom: zoom,\n    };\n};\n\nvar SCROLL_BAR_WIDTH = 17;\nvar PAGE_PADDING = 8;\nvar calculateScale = function (container, pageHeight, pageWidth, scale, viewMode, numPages) {\n    var w = pageWidth;\n    switch (true) {\n        case viewMode === exports.ViewMode.DualPageWithCover && numPages >= 3:\n        case viewMode === exports.ViewMode.DualPage && numPages >= 3:\n            w = 2 * pageWidth;\n            break;\n        default:\n            w = pageWidth;\n            break;\n    }\n    switch (scale) {\n        case exports.SpecialZoomLevel.ActualSize:\n            return 1;\n        case exports.SpecialZoomLevel.PageFit:\n            return Math.min((container.clientWidth - SCROLL_BAR_WIDTH) / w, (container.clientHeight - 2 * PAGE_PADDING) / pageHeight);\n        case exports.SpecialZoomLevel.PageWidth:\n            return (container.clientWidth - SCROLL_BAR_WIDTH) / w;\n    }\n};\n\nvar useStack = function (maxLength) {\n    var stackRef = React__namespace.useRef([]);\n    var map = function (transformer) {\n        return stackRef.current.map(function (item) { return transformer(item); });\n    };\n    var pop = function () {\n        var stack = stackRef.current;\n        var size = stack.length;\n        if (size === 0) {\n            return null;\n        }\n        var lastItem = stack.pop();\n        stackRef.current = stack;\n        return lastItem;\n    };\n    var push = function (item) {\n        var stack = stackRef.current;\n        if (stack.length + 1 > maxLength) {\n            stack.shift();\n        }\n        stack.push(item);\n        stackRef.current = stack;\n    };\n    React__namespace.useEffect(function () {\n        return function () {\n            stackRef.current = [];\n        };\n    }, []);\n    return {\n        push: push,\n        map: map,\n        pop: pop,\n    };\n};\n\nvar useQueue = function (maxLength) {\n    var queueRef = React__namespace.useRef([]);\n    var dequeue = function () {\n        var queue = queueRef.current;\n        var size = queue.length;\n        if (size === 0) {\n            return null;\n        }\n        var firstItem = queue.shift();\n        queueRef.current = queue;\n        return firstItem || null;\n    };\n    var enqueue = function (item) {\n        var queue = queueRef.current;\n        if (queue.length + 1 > maxLength) {\n            queue.pop();\n        }\n        queueRef.current = [item].concat(queue);\n    };\n    var map = function (transformer) {\n        return queueRef.current.map(function (item) { return transformer(item); });\n    };\n    React__namespace.useEffect(function () {\n        return function () {\n            queueRef.current = [];\n        };\n    }, []);\n    return {\n        dequeue: dequeue,\n        enqueue: enqueue,\n        map: map,\n    };\n};\n\nvar MAX_QUEUE_LENGTH = 50;\nvar useDestination = function (_a) {\n    var getCurrentPage = _a.getCurrentPage;\n    var previousDestinations = useStack(MAX_QUEUE_LENGTH);\n    var nextDestinations = useQueue(MAX_QUEUE_LENGTH);\n    var getNextDestination = function () {\n        var nextDest = nextDestinations.dequeue();\n        if (nextDest) {\n            previousDestinations.push(nextDest);\n        }\n        if (nextDest && nextDest.pageIndex === getCurrentPage()) {\n            return getNextDestination();\n        }\n        return nextDest;\n    };\n    var getPreviousDestination = function () {\n        var prevDest = previousDestinations.pop();\n        if (prevDest) {\n            nextDestinations.enqueue(prevDest);\n        }\n        if (prevDest && prevDest.pageIndex === getCurrentPage()) {\n            return getPreviousDestination();\n        }\n        return prevDest;\n    };\n    var markVisitedDestination = React__namespace.useCallback(function (destination) {\n        previousDestinations.push(destination);\n    }, []);\n    return {\n        getNextDestination: getNextDestination,\n        getPreviousDestination: getPreviousDestination,\n        markVisitedDestination: markVisitedDestination,\n    };\n};\n\nvar flaternSingleOutline = function (outline) {\n    var result = [];\n    if (outline.items && outline.items.length > 0) {\n        result = result.concat(flaternOutlines(outline.items));\n    }\n    return result;\n};\nvar flaternOutlines = function (outlines) {\n    var result = [];\n    outlines.map(function (outline) {\n        result = result.concat(outline).concat(flaternSingleOutline(outline));\n    });\n    return result;\n};\nvar useOutlines = function (doc) {\n    var isMounted = useIsMounted();\n    var _a = React__namespace.useState([]), outlines = _a[0], setOutlines = _a[1];\n    React__namespace.useEffect(function () {\n        doc.getOutline().then(function (result) {\n            if (isMounted.current && result !== null) {\n                var items = flaternOutlines(result);\n                setOutlines(items);\n            }\n        });\n    }, []);\n    return outlines;\n};\n\nvar RESIZE_EVENT_OPTIONS = {\n    capture: false,\n    passive: true,\n};\nvar ZERO_RECT$1 = {\n    height: 0,\n    width: 0,\n};\nvar useWindowResize = function () {\n    var _a = React__namespace.useState(ZERO_RECT$1), windowRect = _a[0], setWindowRect = _a[1];\n    var handleResize = useDebounceCallback(function () {\n        setWindowRect({\n            height: window.innerHeight,\n            width: window.innerWidth,\n        });\n    }, 100);\n    useIsomorphicLayoutEffect(function () {\n        window.addEventListener('resize', handleResize, RESIZE_EVENT_OPTIONS);\n        return function () {\n            window.removeEventListener('resize', handleResize, RESIZE_EVENT_OPTIONS);\n        };\n    }, []);\n    return windowRect;\n};\n\nvar ZERO_RECT = {\n    height: 0,\n    width: 0,\n};\nvar useFullScreen = function (_a) {\n    var getCurrentPage = _a.getCurrentPage, getCurrentScrollMode = _a.getCurrentScrollMode, jumpToPage = _a.jumpToPage, targetRef = _a.targetRef;\n    var _b = React__namespace.useState(exports.FullScreenMode.Normal), fullScreenMode = _b[0], setFullScreenMode = _b[1];\n    var windowRect = useWindowResize();\n    var _c = React__namespace.useState(ZERO_RECT), targetRect = _c[0], setTargetRect = _c[1];\n    var windowSizeBeforeFullScreenRef = React__namespace.useRef(ZERO_RECT);\n    var targetPageRef = React__namespace.useRef(getCurrentPage());\n    var fullScreenSizeRef = React__namespace.useRef(ZERO_RECT);\n    var _d = React__namespace.useState(targetRef.current), element = _d[0], setElement = _d[1];\n    var fullScreenElementRef = React__namespace.useRef();\n    useIsomorphicLayoutEffect(function () {\n        if (targetRef.current !== element) {\n            setElement(targetRef.current);\n        }\n    }, []);\n    useIsomorphicLayoutEffect(function () {\n        if (!element) {\n            return;\n        }\n        var io = new ResizeObserver(function (entries) {\n            entries.forEach(function (entry) {\n                var _a = entry.target.getBoundingClientRect(), height = _a.height, width = _a.width;\n                setTargetRect({ height: height, width: width });\n            });\n        });\n        io.observe(element);\n        return function () {\n            io.unobserve(element);\n            io.disconnect();\n        };\n    }, [element]);\n    var closeOtherFullScreen = React__namespace.useCallback(function (target) {\n        var currentFullScreenEle = getFullScreenElement();\n        if (currentFullScreenEle && currentFullScreenEle !== target) {\n            setFullScreenMode(exports.FullScreenMode.Normal);\n            return exitFullScreen(currentFullScreenEle);\n        }\n        return Promise.resolve();\n    }, []);\n    var enterFullScreenMode = React__namespace.useCallback(function (target) {\n        if (!target || !isFullScreenEnabled()) {\n            return;\n        }\n        setElement(target);\n        closeOtherFullScreen(target).then(function () {\n            fullScreenElementRef.current = target;\n            setFullScreenMode(exports.FullScreenMode.Entering);\n            requestFullScreen(target);\n        });\n    }, []);\n    var exitFullScreenMode = React__namespace.useCallback(function () {\n        var currentFullScreenEle = getFullScreenElement();\n        if (currentFullScreenEle) {\n            setFullScreenMode(exports.FullScreenMode.Exitting);\n            exitFullScreen(document);\n        }\n    }, []);\n    var handleFullScreenChange = React__namespace.useCallback(function () {\n        if (!element) {\n            return;\n        }\n        var currentFullScreenEle = getFullScreenElement();\n        if (currentFullScreenEle !== element) {\n            setFullScreenMode(exports.FullScreenMode.Exitting);\n        }\n    }, [element]);\n    React__namespace.useEffect(function () {\n        switch (fullScreenMode) {\n            case exports.FullScreenMode.Entering:\n                if (fullScreenElementRef.current) {\n                    fullScreenElementRef.current.style.backgroundColor =\n                        'var(--rpv-core__full-screen-target-background-color)';\n                }\n                targetPageRef.current = getCurrentPage();\n                windowSizeBeforeFullScreenRef.current = {\n                    height: window.innerHeight,\n                    width: window.innerWidth,\n                };\n                break;\n            case exports.FullScreenMode.Entered:\n                if (getCurrentScrollMode() === exports.ScrollMode.Page) {\n                    jumpToPage(targetPageRef.current).then(function () {\n                        setFullScreenMode(exports.FullScreenMode.EnteredCompletely);\n                    });\n                }\n                else {\n                    setFullScreenMode(exports.FullScreenMode.EnteredCompletely);\n                }\n                break;\n            case exports.FullScreenMode.Exitting:\n                if (fullScreenElementRef.current) {\n                    fullScreenElementRef.current.style.backgroundColor = '';\n                    fullScreenElementRef.current = null;\n                }\n                targetPageRef.current = getCurrentPage();\n                break;\n            case exports.FullScreenMode.Exited:\n                setFullScreenMode(exports.FullScreenMode.Normal);\n                if (getCurrentScrollMode() === exports.ScrollMode.Page) {\n                    jumpToPage(targetPageRef.current);\n                }\n                break;\n        }\n    }, [fullScreenMode]);\n    React__namespace.useEffect(function () {\n        if (fullScreenMode === exports.FullScreenMode.Normal) {\n            return;\n        }\n        if (fullScreenMode === exports.FullScreenMode.Entering &&\n            windowRect.height === targetRect.height &&\n            windowRect.width === targetRect.width &&\n            windowRect.height > 0 &&\n            windowRect.width > 0 &&\n            (fullScreenSizeRef.current.height === 0 || windowRect.height == fullScreenSizeRef.current.height)) {\n            fullScreenSizeRef.current = {\n                height: window.innerHeight,\n                width: window.innerWidth,\n            };\n            setFullScreenMode(exports.FullScreenMode.Entered);\n            return;\n        }\n        if (fullScreenMode === exports.FullScreenMode.Exitting &&\n            windowSizeBeforeFullScreenRef.current.height === windowRect.height &&\n            windowSizeBeforeFullScreenRef.current.width === windowRect.width &&\n            windowRect.height > 0 &&\n            windowRect.width > 0) {\n            setFullScreenMode(exports.FullScreenMode.Exited);\n        }\n    }, [fullScreenMode, windowRect, targetRect]);\n    React__namespace.useEffect(function () {\n        addFullScreenChangeListener(handleFullScreenChange);\n        return function () {\n            removeFullScreenChangeListener(handleFullScreenChange);\n        };\n    }, [element]);\n    return {\n        enterFullScreenMode: enterFullScreenMode,\n        exitFullScreenMode: exitFullScreenMode,\n        fullScreenMode: fullScreenMode,\n    };\n};\n\nvar DEFAULT_PAGE_LAYOUT = {\n    buildPageStyles: function () { return ({}); },\n    transformSize: function (_a) {\n        var size = _a.size;\n        return size;\n    },\n};\nvar ZERO_OFFSET = {\n    left: 0,\n    top: 0,\n};\nvar Inner = function (_a) {\n    var currentFile = _a.currentFile, defaultScale = _a.defaultScale, doc = _a.doc, enableSmoothScroll = _a.enableSmoothScroll, initialPage = _a.initialPage, initialRotation = _a.initialRotation, initialScale = _a.initialScale, pageLayout = _a.pageLayout, pageSizes = _a.pageSizes, plugins = _a.plugins, renderPage = _a.renderPage, scrollMode = _a.scrollMode, setRenderRange = _a.setRenderRange, viewMode = _a.viewMode, viewerState = _a.viewerState, onDocumentLoad = _a.onDocumentLoad, onOpenFile = _a.onOpenFile, onPageChange = _a.onPageChange, onRotate = _a.onRotate, onRotatePage = _a.onRotatePage, onZoom = _a.onZoom;\n    var numPages = doc.numPages;\n    var docId = doc.loadingTask.docId;\n    var l10n = React__namespace.useContext(LocalizationContext).l10n;\n    var themeContext = React__namespace.useContext(ThemeContext);\n    var isRtl = themeContext.direction === exports.TextDirection.RightToLeft;\n    var containerRef = React__namespace.useRef();\n    var pagesRef = React__namespace.useRef();\n    var _b = React__namespace.useState(initialPage), currentPage = _b[0], setCurrentPage = _b[1];\n    var mostRecentVisitedRef = React__namespace.useRef(null);\n    var destinationManager = useDestination({\n        getCurrentPage: function () { return stateRef.current.pageIndex; },\n    });\n    var _c = React__namespace.useState(initialRotation), rotation = _c[0], setRotation = _c[1];\n    var previousRotation = usePrevious(rotation);\n    var _d = React__namespace.useState(false), pagesRotationChanged = _d[0], setPagesRotationChanged = _d[1];\n    var _e = React__namespace.useState(new Map()), pagesRotation = _e[0], setPagesRotation = _e[1];\n    var _f = React__namespace.useState(scrollMode), currentScrollMode = _f[0], setCurrentScrollMode = _f[1];\n    var previousScrollMode = usePrevious(currentScrollMode);\n    var _g = React__namespace.useState(viewMode), currentViewMode = _g[0], setCurrentViewMode = _g[1];\n    var previousViewMode = usePrevious(currentViewMode);\n    var outlines = useOutlines(doc);\n    var _h = React__namespace.useState(initialScale), scale = _h[0], setScale = _h[1];\n    var previousScale = usePrevious(scale);\n    var stateRef = React__namespace.useRef(viewerState);\n    var keepSpecialZoomLevelRef = React__namespace.useRef(typeof defaultScale === 'string' ? defaultScale : null);\n    var forceTargetFullScreenRef = React__namespace.useRef(-1);\n    var forceTargetZoomRef = React__namespace.useRef(-1);\n    var forceTargetInitialPageRef = React__namespace.useRef(initialPage);\n    var fullScreen = useFullScreen({\n        getCurrentPage: function () { return stateRef.current.pageIndex; },\n        getCurrentScrollMode: function () { return stateRef.current.scrollMode; },\n        jumpToPage: function (pageIndex) { return jumpToPage(pageIndex); },\n        targetRef: pagesRef,\n    });\n    var _j = React__namespace.useState(-1), renderPageIndex = _j[0], setRenderPageIndex = _j[1];\n    var _k = React__namespace.useState(0), renderQueueKey = _k[0], setRenderQueueKey = _k[1];\n    var renderQueue = useRenderQueue({ doc: doc });\n    React__namespace.useEffect(function () {\n        return function () {\n            clearPagesCache();\n        };\n    }, [docId]);\n    var layoutBuilder = React__namespace.useMemo(function () { return Object.assign({}, DEFAULT_PAGE_LAYOUT, pageLayout); }, []);\n    var sizes = React__namespace.useMemo(function () {\n        return Array(numPages)\n            .fill(0)\n            .map(function (_, pageIndex) {\n            var pageSize = [pageSizes[pageIndex].pageHeight, pageSizes[pageIndex].pageWidth];\n            var rect = Math.abs(rotation) % 180 === 0\n                ? {\n                    height: pageSize[0],\n                    width: pageSize[1],\n                }\n                : {\n                    height: pageSize[1],\n                    width: pageSize[0],\n                };\n            var pageRect = {\n                height: rect.height * scale,\n                width: rect.width * scale,\n            };\n            return layoutBuilder.transformSize({ numPages: numPages, pageIndex: pageIndex, size: pageRect });\n        });\n    }, [rotation, scale]);\n    var virtualizer = useVirtual({\n        enableSmoothScroll: enableSmoothScroll,\n        isRtl: isRtl,\n        numberOfItems: numPages,\n        parentRef: pagesRef,\n        scrollMode: currentScrollMode,\n        setRenderRange: setRenderRange,\n        sizes: sizes,\n        viewMode: currentViewMode,\n    });\n    var handlePagesResize = useDebounceCallback(function () {\n        if (!keepSpecialZoomLevelRef.current ||\n            stateRef.current.fullScreenMode !== exports.FullScreenMode.Normal ||\n            (initialPage > 0 && forceTargetInitialPageRef.current === initialPage)) {\n            return;\n        }\n        zoom(keepSpecialZoomLevelRef.current);\n    }, 200);\n    useTrackResize({\n        targetRef: pagesRef,\n        onResize: handlePagesResize,\n    });\n    var setViewerState = function (viewerState) {\n        var newState = viewerState;\n        plugins.forEach(function (plugin) {\n            if (plugin.onViewerStateChange) {\n                newState = plugin.onViewerStateChange(newState);\n            }\n        });\n        stateRef.current = newState;\n    };\n    var getPagesContainer = function () { return pagesRef.current; };\n    var getViewerState = function () { return stateRef.current; };\n    var handleJumpFromLinkAnnotation = React__namespace.useCallback(function (destination) {\n        destinationManager.markVisitedDestination(destination);\n    }, []);\n    var handleJumpToDestination = React__namespace.useCallback(function (destination) {\n        var pageIndex = destination.pageIndex, bottomOffset = destination.bottomOffset, leftOffset = destination.leftOffset, scaleTo = destination.scaleTo;\n        var pagesContainer = pagesRef.current;\n        var currentState = stateRef.current;\n        if (!pagesContainer || !currentState) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, _) {\n            getPage(doc, pageIndex).then(function (page) {\n                var viewport = page.getViewport({ scale: 1 });\n                var top = 0;\n                var bottom = (typeof bottomOffset === 'function'\n                    ? bottomOffset(viewport.width, viewport.height)\n                    : bottomOffset) || 0;\n                var left = (typeof leftOffset === 'function' ? leftOffset(viewport.width, viewport.height) : leftOffset) || 0;\n                var updateScale = currentState.scale;\n                switch (scaleTo) {\n                    case exports.SpecialZoomLevel.PageFit:\n                        top = 0;\n                        left = 0;\n                        zoom(exports.SpecialZoomLevel.PageFit);\n                        break;\n                    case exports.SpecialZoomLevel.PageWidth:\n                        updateScale = calculateScale(pagesContainer, pageSizes[pageIndex].pageHeight, pageSizes[pageIndex].pageWidth, exports.SpecialZoomLevel.PageWidth, viewMode, numPages);\n                        top = (viewport.height - bottom) * updateScale;\n                        left = left * updateScale;\n                        zoom(updateScale);\n                        break;\n                    default:\n                        top = (viewport.height - bottom) * updateScale;\n                        left = left * updateScale;\n                        break;\n                }\n                switch (currentState.scrollMode) {\n                    case exports.ScrollMode.Horizontal:\n                        virtualizer.scrollToItem(pageIndex, { left: left, top: 0 }).then(function () {\n                            resolve();\n                        });\n                        break;\n                    case exports.ScrollMode.Vertical:\n                    default:\n                        virtualizer.scrollToItem(pageIndex, { left: 0, top: top }).then(function () {\n                            resolve();\n                        });\n                        break;\n                }\n            });\n        });\n    }, []);\n    var jumpToDestination = React__namespace.useCallback(function (destination) {\n        destinationManager.markVisitedDestination(destination);\n        return handleJumpToDestination(destination);\n    }, []);\n    var jumpToNextDestination = React__namespace.useCallback(function () {\n        var nextDestination = destinationManager.getNextDestination();\n        return nextDestination ? handleJumpToDestination(nextDestination) : Promise.resolve();\n    }, []);\n    var jumpToPreviousDestination = React__namespace.useCallback(function () {\n        var lastDestination = destinationManager.getPreviousDestination();\n        return lastDestination ? handleJumpToDestination(lastDestination) : Promise.resolve();\n    }, []);\n    var jumpToNextPage = React__namespace.useCallback(function () { return virtualizer.scrollToNextItem(stateRef.current.pageIndex, ZERO_OFFSET); }, []);\n    var jumpToPage = React__namespace.useCallback(function (pageIndex) {\n        return 0 <= pageIndex && pageIndex < numPages\n            ? virtualizer.scrollToItem(pageIndex, ZERO_OFFSET)\n            : Promise.resolve();\n    }, []);\n    var jumpToPreviousPage = React__namespace.useCallback(function () { return virtualizer.scrollToPreviousItem(stateRef.current.pageIndex, ZERO_OFFSET); }, []);\n    var openFile = React__namespace.useCallback(function (file) {\n        if (getFileExt(file.name).toLowerCase() !== 'pdf') {\n            return;\n        }\n        new Promise(function (resolve) {\n            var reader = new FileReader();\n            reader.readAsArrayBuffer(file);\n            reader.onload = function () {\n                var bytes = new Uint8Array(reader.result);\n                resolve(bytes);\n            };\n        }).then(function (data) {\n            onOpenFile(file.name, data);\n        });\n    }, [onOpenFile]);\n    var rotate = React__namespace.useCallback(function (direction) {\n        var degrees = direction === exports.RotateDirection.Backward ? -90 : 90;\n        var currentRotation = stateRef.current.rotation;\n        var updateRotation = currentRotation === 360 || currentRotation === -360 ? degrees : currentRotation + degrees;\n        renderQueue.markNotRendered();\n        setRotation(updateRotation);\n        setViewerState(__assign(__assign({}, stateRef.current), { rotation: updateRotation }));\n        onRotate({ direction: direction, doc: doc, rotation: updateRotation });\n    }, []);\n    var rotatePage = React__namespace.useCallback(function (pageIndex, direction) {\n        var degrees = direction === exports.RotateDirection.Backward ? -90 : 90;\n        var rotations = stateRef.current.pagesRotation;\n        var currentPageRotation = rotations.has(pageIndex) ? rotations.get(pageIndex) : initialRotation;\n        var finalRotation = currentPageRotation + degrees;\n        var updateRotations = rotations.set(pageIndex, finalRotation);\n        setPagesRotation(updateRotations);\n        setPagesRotationChanged(function (value) { return !value; });\n        setViewerState(__assign(__assign({}, stateRef.current), { pagesRotation: updateRotations, rotatedPage: pageIndex }));\n        onRotatePage({ direction: direction, doc: doc, pageIndex: pageIndex, rotation: finalRotation });\n        renderQueue.markRendering(pageIndex);\n        setRenderPageIndex(pageIndex);\n    }, []);\n    var switchScrollMode = React__namespace.useCallback(function (scrollMode) {\n        setViewerState(__assign(__assign({}, stateRef.current), { scrollMode: scrollMode }));\n        setCurrentScrollMode(scrollMode);\n    }, []);\n    var switchViewMode = React__namespace.useCallback(function (viewMode) {\n        setViewerState(__assign(__assign({}, stateRef.current), { viewMode: viewMode }));\n        setCurrentViewMode(viewMode);\n    }, []);\n    var zoom = React__namespace.useCallback(function (newScale) {\n        var pagesEle = pagesRef.current;\n        var currentPage = stateRef.current.pageIndex;\n        if (currentPage < 0 || currentPage >= numPages) {\n            return;\n        }\n        var currentPageHeight = pageSizes[currentPage].pageHeight;\n        var currentPageWidth = pageSizes[currentPage].pageWidth;\n        var updateScale = pagesEle\n            ? typeof newScale === 'string'\n                ? calculateScale(pagesEle, currentPageHeight, currentPageWidth, newScale, stateRef.current.viewMode, numPages)\n                : newScale\n            : 1;\n        keepSpecialZoomLevelRef.current = typeof newScale === 'string' ? newScale : null;\n        if (updateScale === stateRef.current.scale) {\n            return;\n        }\n        setRenderQueueKey(function (key) { return key + 1; });\n        renderQueue.markNotRendered();\n        setScale(updateScale);\n        onZoom({ doc: doc, scale: updateScale });\n        setViewerState(__assign(__assign({}, stateRef.current), { scale: updateScale }));\n    }, []);\n    var enterFullScreenMode = React__namespace.useCallback(function (target) {\n        fullScreen.enterFullScreenMode(target);\n    }, []);\n    var exitFullScreenMode = React__namespace.useCallback(function () {\n        fullScreen.exitFullScreenMode();\n    }, []);\n    React__namespace.useEffect(function () {\n        setViewerState(__assign(__assign({}, stateRef.current), { fullScreenMode: fullScreen.fullScreenMode }));\n    }, [fullScreen.fullScreenMode]);\n    React__namespace.useEffect(function () {\n        var pluginMethods = {\n            enterFullScreenMode: enterFullScreenMode,\n            exitFullScreenMode: exitFullScreenMode,\n            getPagesContainer: getPagesContainer,\n            getViewerState: getViewerState,\n            jumpToDestination: jumpToDestination,\n            jumpToNextDestination: jumpToNextDestination,\n            jumpToPreviousDestination: jumpToPreviousDestination,\n            jumpToNextPage: jumpToNextPage,\n            jumpToPreviousPage: jumpToPreviousPage,\n            jumpToPage: jumpToPage,\n            openFile: openFile,\n            rotate: rotate,\n            rotatePage: rotatePage,\n            setViewerState: setViewerState,\n            switchScrollMode: switchScrollMode,\n            switchViewMode: switchViewMode,\n            zoom: zoom,\n        };\n        plugins.forEach(function (plugin) {\n            if (plugin.install) {\n                plugin.install(pluginMethods);\n            }\n        });\n        return function () {\n            plugins.forEach(function (plugin) {\n                if (plugin.uninstall) {\n                    plugin.uninstall(pluginMethods);\n                }\n            });\n        };\n    }, [docId]);\n    React__namespace.useEffect(function () {\n        onDocumentLoad({ doc: doc, file: currentFile });\n        plugins.forEach(function (plugin) {\n            plugin.onDocumentLoad && plugin.onDocumentLoad({ doc: doc, file: currentFile });\n        });\n    }, [docId]);\n    var boundingClientRect = virtualizer.boundingClientRect;\n    useRunOnce(function () {\n        if (initialPage) {\n            jumpToPage(initialPage);\n        }\n    }, boundingClientRect.height > 0 && boundingClientRect.width > 0);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > -1 && previousScrollMode !== currentScrollMode) {\n            virtualizer.scrollToItem(latestPage, ZERO_OFFSET).then(function () {\n                if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely) {\n                    if (!enableSmoothScroll) {\n                        renderQueue.markNotRendered();\n                    }\n                    forceTargetFullScreenRef.current = -1;\n                }\n            });\n        }\n    }, [currentScrollMode]);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > -1 && previousRotation !== rotation) {\n            virtualizer.scrollToItem(latestPage, ZERO_OFFSET);\n        }\n    }, [rotation]);\n    useIsomorphicLayoutEffect(function () {\n        if (previousScale != 0 && previousScale != stateRef.current.scale) {\n            virtualizer.zoom(stateRef.current.scale / previousScale, stateRef.current.pageIndex).then(function () {\n                if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely) {\n                    forceTargetZoomRef.current = -1;\n                }\n            });\n        }\n    }, [scale]);\n    useIsomorphicLayoutEffect(function () {\n        if (previousViewMode === stateRef.current.viewMode) {\n            return;\n        }\n        var startPage = virtualizer.startPage, endPage = virtualizer.endPage, virtualItems = virtualizer.virtualItems;\n        renderQueue.markNotRendered();\n        renderQueue.setRange(startPage, endPage);\n        var _loop_1 = function (i) {\n            var item = virtualItems.find(function (item) { return item.index === i; });\n            if (item) {\n                renderQueue.setVisibility(i, item.visibility);\n            }\n        };\n        for (var i = startPage; i <= endPage; i++) {\n            _loop_1(i);\n        }\n        renderNextPage();\n    }, [currentViewMode]);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > -1 && previousViewMode !== currentViewMode) {\n            virtualizer.scrollToItem(latestPage, ZERO_OFFSET);\n        }\n    }, [currentViewMode]);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > 0 &&\n            latestPage === initialPage &&\n            forceTargetInitialPageRef.current === initialPage &&\n            keepSpecialZoomLevelRef.current) {\n            forceTargetInitialPageRef.current = -1;\n            zoom(keepSpecialZoomLevelRef.current);\n        }\n    }, [currentPage]);\n    React__namespace.useEffect(function () {\n        var isSmoothScrolling = virtualizer.isSmoothScrolling;\n        if (isSmoothScrolling) {\n            return;\n        }\n        if (mostRecentVisitedRef.current === null || mostRecentVisitedRef.current !== currentPage) {\n            mostRecentVisitedRef.current = currentPage;\n            onPageChange({ currentPage: currentPage, doc: doc });\n        }\n    }, [currentPage, virtualizer.isSmoothScrolling]);\n    React__namespace.useEffect(function () {\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.Entering && stateRef.current.scrollMode === exports.ScrollMode.Page) {\n            forceTargetFullScreenRef.current = stateRef.current.pageIndex;\n        }\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely &&\n            stateRef.current.scrollMode === exports.ScrollMode.Page &&\n            enableSmoothScroll) {\n            forceTargetFullScreenRef.current = -1;\n        }\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely && keepSpecialZoomLevelRef.current) {\n            forceTargetZoomRef.current = stateRef.current.pageIndex;\n            zoom(keepSpecialZoomLevelRef.current);\n        }\n    }, [fullScreen.fullScreenMode]);\n    React__namespace.useEffect(function () {\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.Entering ||\n            fullScreen.fullScreenMode === exports.FullScreenMode.Exitting ||\n            virtualizer.isSmoothScrolling) {\n            return;\n        }\n        var startPage = virtualizer.startPage, endPage = virtualizer.endPage, maxVisbilityIndex = virtualizer.maxVisbilityIndex, virtualItems = virtualizer.virtualItems;\n        var currentPage = maxVisbilityIndex;\n        var isFullScreen = fullScreen.fullScreenMode === exports.FullScreenMode.Entered ||\n            fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely;\n        if (isFullScreen && currentPage !== forceTargetFullScreenRef.current && forceTargetFullScreenRef.current > -1) {\n            return;\n        }\n        if (isFullScreen && currentPage !== forceTargetZoomRef.current && forceTargetZoomRef.current > -1) {\n            return;\n        }\n        setCurrentPage(currentPage);\n        setViewerState(__assign(__assign({}, stateRef.current), { pageIndex: currentPage }));\n        renderQueue.setRange(startPage, endPage);\n        var _loop_2 = function (i) {\n            var item = virtualItems.find(function (item) { return item.index === i; });\n            if (item) {\n                renderQueue.setVisibility(i, item.visibility);\n            }\n        };\n        for (var i = startPage; i <= endPage; i++) {\n            _loop_2(i);\n        }\n        renderNextPage();\n    }, [\n        virtualizer.startPage,\n        virtualizer.endPage,\n        virtualizer.isSmoothScrolling,\n        virtualizer.maxVisbilityIndex,\n        fullScreen.fullScreenMode,\n        pagesRotationChanged,\n        rotation,\n        scale,\n    ]);\n    var handlePageRenderCompleted = React__namespace.useCallback(function (pageIndex) {\n        renderQueue.markRendered(pageIndex);\n        renderNextPage();\n    }, [renderQueueKey]);\n    var renderNextPage = function () {\n        var nextPage = renderQueue.getHighestPriorityPage();\n        if (nextPage > -1 && renderQueue.isInRange(nextPage)) {\n            renderQueue.markRendering(nextPage);\n            setRenderPageIndex(nextPage);\n        }\n    };\n    var executeNamedAction = function (action) {\n        var previousPage = currentPage - 1;\n        var nextPage = currentPage + 1;\n        switch (action) {\n            case 'FirstPage':\n                jumpToPage(0);\n                break;\n            case 'LastPage':\n                jumpToPage(numPages - 1);\n                break;\n            case 'NextPage':\n                nextPage < numPages && jumpToPage(nextPage);\n                break;\n            case 'PrevPage':\n                previousPage >= 0 && jumpToPage(previousPage);\n                break;\n        }\n    };\n    var renderViewer = React__namespace.useCallback(function () {\n        var virtualItems = virtualizer.virtualItems;\n        var chunks = [];\n        switch (currentViewMode) {\n            case exports.ViewMode.DualPage:\n                chunks = chunk(virtualItems, 2);\n                break;\n            case exports.ViewMode.DualPageWithCover:\n                if (virtualItems.length) {\n                    chunks =\n                        virtualItems[0].index === 0\n                            ? [[virtualItems[0]]].concat(chunk(virtualItems.slice(1), 2))\n                            : chunk(virtualItems, 2);\n                }\n                break;\n            case exports.ViewMode.SinglePage:\n            default:\n                chunks = chunk(virtualItems, 1);\n                break;\n        }\n        var pageLabel = l10n && l10n.core ? l10n.core.pageLabel : 'Page {{pageIndex}}';\n        var slot = {\n            attrs: {\n                className: 'rpv-core__inner-container',\n                'data-testid': 'core__inner-container',\n                ref: containerRef,\n                style: {\n                    height: '100%',\n                },\n            },\n            children: React__namespace.createElement(React__namespace.Fragment, null),\n            subSlot: {\n                attrs: {\n                    'data-testid': 'core__inner-pages',\n                    className: classNames({\n                        'rpv-core__inner-pages': true,\n                        'rpv-core__inner-pages--horizontal': currentScrollMode === exports.ScrollMode.Horizontal,\n                        'rpv-core__inner-pages--rtl': isRtl,\n                        'rpv-core__inner-pages--single': currentScrollMode === exports.ScrollMode.Page,\n                        'rpv-core__inner-pages--vertical': currentScrollMode === exports.ScrollMode.Vertical,\n                        'rpv-core__inner-pages--wrapped': currentScrollMode === exports.ScrollMode.Wrapped,\n                    }),\n                    ref: pagesRef,\n                    style: {\n                        height: '100%',\n                        position: 'relative',\n                    },\n                },\n                children: (React__namespace.createElement(\"div\", { \"data-testid\": \"core__inner-current-page-\".concat(currentPage), style: Object.assign({\n                        '--scale-factor': scale,\n                    }, virtualizer.getContainerStyles()) }, chunks.map(function (items) { return (React__namespace.createElement(\"div\", { className: classNames({\n                        'rpv-core__inner-page-container': true,\n                        'rpv-core__inner-page-container--single': currentScrollMode === exports.ScrollMode.Page,\n                    }), style: virtualizer.getItemContainerStyles(items[0]), key: \"\".concat(items[0].index, \"-\").concat(currentViewMode) }, items.map(function (item) {\n                    var isCover = currentViewMode === exports.ViewMode.DualPageWithCover &&\n                        (item.index === 0 || (numPages % 2 === 0 && item.index === numPages - 1));\n                    return (React__namespace.createElement(\"div\", { \"aria-label\": pageLabel.replace('{{pageIndex}}', \"\".concat(item.index + 1)), className: classNames({\n                            'rpv-core__inner-page': true,\n                            'rpv-core__inner-page--dual-even': currentViewMode === exports.ViewMode.DualPage && item.index % 2 === 0,\n                            'rpv-core__inner-page--dual-odd': currentViewMode === exports.ViewMode.DualPage && item.index % 2 === 1,\n                            'rpv-core__inner-page--dual-cover': isCover,\n                            'rpv-core__inner-page--dual-cover-even': currentViewMode === exports.ViewMode.DualPageWithCover &&\n                                !isCover &&\n                                item.index % 2 === 0,\n                            'rpv-core__inner-page--dual-cover-odd': currentViewMode === exports.ViewMode.DualPageWithCover &&\n                                !isCover &&\n                                item.index % 2 === 1,\n                            'rpv-core__inner-page--single': currentViewMode === exports.ViewMode.SinglePage &&\n                                currentScrollMode === exports.ScrollMode.Page,\n                        }), role: \"region\", key: \"\".concat(item.index, \"-\").concat(currentViewMode), style: Object.assign({}, virtualizer.getItemStyles(item), layoutBuilder.buildPageStyles({\n                            numPages: numPages,\n                            pageIndex: item.index,\n                            scrollMode: currentScrollMode,\n                            viewMode: currentViewMode,\n                        })) },\n                        React__namespace.createElement(PageLayer, { doc: doc, measureRef: item.measureRef, outlines: outlines, pageIndex: item.index, pageRotation: pagesRotation.has(item.index) ? pagesRotation.get(item.index) : 0, pageSize: pageSizes[item.index], plugins: plugins, renderPage: renderPage, renderQueueKey: renderQueueKey, rotation: rotation, scale: scale, shouldRender: renderPageIndex === item.index, viewMode: currentViewMode, onExecuteNamedAction: executeNamedAction, onJumpFromLinkAnnotation: handleJumpFromLinkAnnotation, onJumpToDest: jumpToDestination, onRenderCompleted: handlePageRenderCompleted, onRotatePage: rotatePage })));\n                }))); }))),\n            },\n        };\n        plugins.forEach(function (plugin) {\n            if (plugin.renderViewer) {\n                slot = plugin.renderViewer({\n                    containerRef: containerRef,\n                    doc: doc,\n                    pagesContainerRef: pagesRef,\n                    pagesRotation: pagesRotation,\n                    pageSizes: pageSizes,\n                    rotation: rotation,\n                    slot: slot,\n                    themeContext: themeContext,\n                    jumpToPage: jumpToPage,\n                    openFile: openFile,\n                    rotate: rotate,\n                    rotatePage: rotatePage,\n                    switchScrollMode: switchScrollMode,\n                    switchViewMode: switchViewMode,\n                    zoom: zoom,\n                });\n            }\n        });\n        return slot;\n    }, [plugins, virtualizer]);\n    var renderSlot = React__namespace.useCallback(function (slot) { return (React__namespace.createElement(\"div\", __assign({}, slot.attrs, { style: slot.attrs && slot.attrs.style ? slot.attrs.style : {} }),\n        slot.children,\n        slot.subSlot && renderSlot(slot.subSlot))); }, []);\n    return renderSlot(renderViewer());\n};\n\nvar LEVELS = [\n    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3.0, 3.3, 3.7, 4.1, 4.6,\n    5.1, 5.7, 6.3, 7.0, 7.7, 8.5, 9.4, 10,\n];\nvar decrease = function (currentLevel) {\n    var found = LEVELS.findIndex(function (item) { return item >= currentLevel; });\n    return found === -1 || found === 0 ? currentLevel : LEVELS[found - 1];\n};\n\nvar RESERVE_HEIGHT = 45;\nvar RESERVE_WIDTH = 45;\nvar PageSizeCalculator = function (_a) {\n    var defaultScale = _a.defaultScale, doc = _a.doc, render = _a.render, scrollMode = _a.scrollMode, viewMode = _a.viewMode;\n    var pagesRef = React__namespace.useRef();\n    var _b = React__namespace.useState({\n        pageSizes: [],\n        scale: 0,\n    }), state = _b[0], setState = _b[1];\n    React__namespace.useLayoutEffect(function () {\n        var queryPageSizes = Array(doc.numPages)\n            .fill(0)\n            .map(function (_, i) {\n            return new Promise(function (resolve, _) {\n                getPage(doc, i).then(function (pdfPage) {\n                    var viewport = pdfPage.getViewport({ scale: 1 });\n                    resolve({\n                        pageHeight: viewport.height,\n                        pageWidth: viewport.width,\n                        rotation: viewport.rotation,\n                    });\n                });\n            });\n        });\n        Promise.all(queryPageSizes).then(function (pageSizes) {\n            var pagesEle = pagesRef.current;\n            if (!pagesEle || pageSizes.length === 0) {\n                return;\n            }\n            var w = pageSizes[0].pageWidth;\n            var h = pageSizes[0].pageHeight;\n            var parentEle = pagesEle.parentElement;\n            var scaleWidth = (parentEle.clientWidth - RESERVE_WIDTH) / w;\n            var scaleHeight = (parentEle.clientHeight - RESERVE_HEIGHT) / h;\n            var scaled = scaleWidth;\n            switch (scrollMode) {\n                case exports.ScrollMode.Horizontal:\n                    scaled = Math.min(scaleWidth, scaleHeight);\n                    break;\n                case exports.ScrollMode.Vertical:\n                default:\n                    scaled = scaleWidth;\n                    break;\n            }\n            var scale = defaultScale\n                ? typeof defaultScale === 'string'\n                    ? calculateScale(parentEle, h, w, defaultScale, viewMode, doc.numPages)\n                    : defaultScale\n                : decrease(scaled);\n            setState({ pageSizes: pageSizes, scale: scale });\n        });\n    }, [doc.loadingTask.docId]);\n    return state.pageSizes.length === 0 || state.scale === 0 ? (React__namespace.createElement(\"div\", { className: \"rpv-core__page-size-calculator\", \"data-testid\": \"core__page-size-calculating\", ref: pagesRef },\n        React__namespace.createElement(Spinner, null))) : (render(state.pageSizes, state.scale));\n};\n\nvar LoadingStatus = (function () {\n    function LoadingStatus() {\n    }\n    return LoadingStatus;\n}());\n\nvar AskForPasswordState = (function (_super) {\n    __extends(AskForPasswordState, _super);\n    function AskForPasswordState(verifyPassword, passwordStatus) {\n        var _this = _super.call(this) || this;\n        _this.verifyPassword = verifyPassword;\n        _this.passwordStatus = passwordStatus;\n        return _this;\n    }\n    return AskForPasswordState;\n}(LoadingStatus));\n\nvar AskingPassword = function (_a) {\n    var passwordStatus = _a.passwordStatus, renderProtectedView = _a.renderProtectedView, verifyPassword = _a.verifyPassword, onDocumentAskPassword = _a.onDocumentAskPassword;\n    var l10n = React__namespace.useContext(LocalizationContext).l10n;\n    var _b = React__namespace.useState(''), password = _b[0], setPassword = _b[1];\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var submit = function () { return verifyPassword(password); };\n    var handleKeyDown = function (e) {\n        if (e.key === 'Enter') {\n            submit();\n        }\n    };\n    React__namespace.useEffect(function () {\n        if (onDocumentAskPassword) {\n            onDocumentAskPassword({\n                verifyPassword: verifyPassword,\n            });\n        }\n    }, []);\n    if (renderProtectedView) {\n        return renderProtectedView({\n            passwordStatus: passwordStatus,\n            verifyPassword: verifyPassword,\n        });\n    }\n    return (React__namespace.createElement(\"div\", { className: \"rpv-core__asking-password-wrapper\" },\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__asking-password': true,\n                'rpv-core__asking-password--rtl': isRtl,\n            }) },\n            React__namespace.createElement(\"div\", { className: \"rpv-core__asking-password-message\" },\n                passwordStatus === exports.PasswordStatus.RequiredPassword &&\n                    l10n.core.askingPassword\n                        .requirePasswordToOpen,\n                passwordStatus === exports.PasswordStatus.WrongPassword &&\n                    l10n.core.wrongPassword.tryAgain),\n            React__namespace.createElement(\"div\", { className: \"rpv-core__asking-password-body\" },\n                React__namespace.createElement(\"div\", { className: classNames({\n                        'rpv-core__asking-password-input': true,\n                        'rpv-core__asking-password-input--ltr': !isRtl,\n                        'rpv-core__asking-password-input--rtl': isRtl,\n                    }) },\n                    React__namespace.createElement(TextBox, { testId: \"core__asking-password-input\", type: \"password\", value: password, onChange: setPassword, onKeyDown: handleKeyDown })),\n                React__namespace.createElement(PrimaryButton, { onClick: submit }, l10n.core.askingPassword.submit)))));\n};\n\nvar CompletedState = (function (_super) {\n    __extends(CompletedState, _super);\n    function CompletedState(doc) {\n        var _this = _super.call(this) || this;\n        _this.doc = doc;\n        return _this;\n    }\n    return CompletedState;\n}(LoadingStatus));\n\nvar FailureState = (function (_super) {\n    __extends(FailureState, _super);\n    function FailureState(error) {\n        var _this = _super.call(this) || this;\n        _this.error = error;\n        return _this;\n    }\n    return FailureState;\n}(LoadingStatus));\n\nvar LoadingState = (function (_super) {\n    __extends(LoadingState, _super);\n    function LoadingState(percentages) {\n        var _this = _super.call(this) || this;\n        _this.percentages = percentages;\n        return _this;\n    }\n    return LoadingState;\n}(LoadingStatus));\n\nvar DocumentLoader = function (_a) {\n    var characterMap = _a.characterMap, file = _a.file, httpHeaders = _a.httpHeaders, render = _a.render, renderError = _a.renderError, renderLoader = _a.renderLoader, renderProtectedView = _a.renderProtectedView, transformGetDocumentParams = _a.transformGetDocumentParams, withCredentials = _a.withCredentials, onDocumentAskPassword = _a.onDocumentAskPassword;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var _b = React__namespace.useState(new LoadingState(0)), status = _b[0], setStatus = _b[1];\n    var docRef = React__namespace.useRef('');\n    var isMounted = useIsMounted();\n    React__namespace.useEffect(function () {\n        docRef.current = '';\n        setStatus(new LoadingState(0));\n        var worker = new PdfJsApi__namespace.PDFWorker({ name: \"PDFWorker_\".concat(Date.now()) });\n        var params = Object.assign({\n            httpHeaders: httpHeaders,\n            withCredentials: withCredentials,\n            worker: worker,\n        }, 'string' === typeof file ? { url: file } : { data: file }, characterMap\n            ? {\n                cMapUrl: characterMap.url,\n                cMapPacked: characterMap.isCompressed,\n            }\n            : {});\n        var transformParams = transformGetDocumentParams ? transformGetDocumentParams(params) : params;\n        var loadingTask = PdfJsApi__namespace.getDocument(transformParams);\n        loadingTask.onPassword = function (verifyPassword, reason) {\n            switch (reason) {\n                case PdfJsApi__namespace.PasswordResponses.NEED_PASSWORD:\n                    isMounted.current &&\n                        setStatus(new AskForPasswordState(verifyPassword, exports.PasswordStatus.RequiredPassword));\n                    break;\n                case PdfJsApi__namespace.PasswordResponses.INCORRECT_PASSWORD:\n                    isMounted.current &&\n                        setStatus(new AskForPasswordState(verifyPassword, exports.PasswordStatus.WrongPassword));\n                    break;\n            }\n        };\n        loadingTask.onProgress = function (progress) {\n            var loaded = progress.total > 0\n                ?\n                    Math.min(100, (100 * progress.loaded) / progress.total)\n                : 100;\n            if (isMounted.current && docRef.current === '') {\n                setStatus(new LoadingState(loaded));\n            }\n        };\n        loadingTask.promise.then(function (doc) {\n            docRef.current = doc.loadingTask.docId;\n            isMounted.current && setStatus(new CompletedState(doc));\n        }, function (err) {\n            return isMounted.current &&\n                !worker.destroyed &&\n                setStatus(new FailureState({\n                    message: err.message || 'Cannot load document',\n                    name: err.name,\n                }));\n        });\n        return function () {\n            loadingTask.destroy();\n            worker.destroy();\n        };\n    }, [file]);\n    if (status instanceof AskForPasswordState) {\n        return (React__namespace.createElement(AskingPassword, { passwordStatus: status.passwordStatus, renderProtectedView: renderProtectedView, verifyPassword: status.verifyPassword, onDocumentAskPassword: onDocumentAskPassword }));\n    }\n    if (status instanceof CompletedState) {\n        return render(status.doc);\n    }\n    if (status instanceof FailureState) {\n        return renderError ? (renderError(status.error)) : (React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__doc-error': true,\n                'rpv-core__doc-error--rtl': isRtl,\n            }) },\n            React__namespace.createElement(\"div\", { className: \"rpv-core__doc-error-text\" }, status.error.message)));\n    }\n    return (React__namespace.createElement(\"div\", { \"data-testid\": \"core__doc-loading\", className: classNames({\n            'rpv-core__doc-loading': true,\n            'rpv-core__doc-loading--rtl': isRtl,\n        }) }, renderLoader ? renderLoader(status.percentages) : React__namespace.createElement(Spinner, null)));\n};\n\nvar isDarkMode = function () {\n    return typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n};\n\nvar withTheme = function (theme, onSwitchTheme) {\n    var initialTheme = React__namespace.useMemo(function () { return (theme === 'auto' ? (isDarkMode() ? 'dark' : 'light') : theme); }, []);\n    var _a = React__namespace.useState(initialTheme), currentTheme = _a[0], setCurrentTheme = _a[1];\n    var prevTheme = usePrevious(currentTheme);\n    React__namespace.useEffect(function () {\n        if (theme !== 'auto') {\n            return;\n        }\n        var media = window.matchMedia('(prefers-color-scheme: dark)');\n        var handler = function (e) {\n            setCurrentTheme(e.matches ? 'dark' : 'light');\n        };\n        media.addEventListener('change', handler);\n        return function () { return media.removeEventListener('change', handler); };\n    }, []);\n    React__namespace.useEffect(function () {\n        if (currentTheme !== prevTheme && onSwitchTheme) {\n            onSwitchTheme(currentTheme);\n        }\n    }, [currentTheme]);\n    React__namespace.useEffect(function () {\n        if (theme !== currentTheme) {\n            setCurrentTheme(theme);\n        }\n    }, [theme]);\n    return {\n        currentTheme: currentTheme,\n        setCurrentTheme: setCurrentTheme,\n    };\n};\n\nvar isSameUrl = function (a, b) {\n    var typeA = typeof a;\n    var typeB = typeof b;\n    if (typeA === 'string' && typeB === 'string' && a === b) {\n        return true;\n    }\n    if (typeA === 'object' && typeB === 'object') {\n        return a.length === b.length && a.every(function (v, i) { return v === b[i]; });\n    }\n    return false;\n};\n\nvar NUM_OVERSCAN_PAGES = 3;\nvar DEFAULT_RENDER_RANGE = function (visiblePagesRange) {\n    return {\n        startPage: visiblePagesRange.startPage - NUM_OVERSCAN_PAGES,\n        endPage: visiblePagesRange.endPage + NUM_OVERSCAN_PAGES,\n    };\n};\nvar Viewer = function (_a) {\n    var characterMap = _a.characterMap, defaultScale = _a.defaultScale, _b = _a.enableSmoothScroll, enableSmoothScroll = _b === void 0 ? true : _b, fileUrl = _a.fileUrl, _c = _a.httpHeaders, httpHeaders = _c === void 0 ? {} : _c, _d = _a.initialPage, initialPage = _d === void 0 ? 0 : _d, pageLayout = _a.pageLayout, _e = _a.initialRotation, initialRotation = _e === void 0 ? 0 : _e, localization = _a.localization, _f = _a.plugins, plugins = _f === void 0 ? [] : _f, renderError = _a.renderError, renderLoader = _a.renderLoader, renderPage = _a.renderPage, renderProtectedView = _a.renderProtectedView, _g = _a.scrollMode, scrollMode = _g === void 0 ? exports.ScrollMode.Vertical : _g, _h = _a.setRenderRange, setRenderRange = _h === void 0 ? DEFAULT_RENDER_RANGE : _h, transformGetDocumentParams = _a.transformGetDocumentParams, _j = _a.theme, theme = _j === void 0 ? {\n        direction: exports.TextDirection.LeftToRight,\n        theme: 'light',\n    } : _j, _k = _a.viewMode, viewMode = _k === void 0 ? exports.ViewMode.SinglePage : _k, _l = _a.withCredentials, withCredentials = _l === void 0 ? false : _l, onDocumentAskPassword = _a.onDocumentAskPassword, _m = _a.onDocumentLoad, onDocumentLoad = _m === void 0 ? function () {\n    } : _m, _o = _a.onPageChange, onPageChange = _o === void 0 ? function () {\n    } : _o, _p = _a.onRotate, onRotate = _p === void 0 ? function () {\n    } : _p, _q = _a.onRotatePage, onRotatePage = _q === void 0 ? function () {\n    } : _q, _r = _a.onSwitchTheme, onSwitchTheme = _r === void 0 ? function () {\n    } : _r, _s = _a.onZoom, onZoom = _s === void 0 ? function () {\n    } : _s;\n    var _t = React__namespace.useState({\n        data: fileUrl,\n        name: typeof fileUrl === 'string' ? fileUrl : '',\n        shouldLoad: false,\n    }), file = _t[0], setFile = _t[1];\n    var openFile = function (fileName, data) {\n        setFile({\n            data: data,\n            name: fileName,\n            shouldLoad: true,\n        });\n    };\n    var _u = React__namespace.useState(false), visible = _u[0], setVisible = _u[1];\n    var prevFile = usePrevious(file);\n    React__namespace.useEffect(function () {\n        if (!isSameUrl(prevFile.data, fileUrl)) {\n            setFile({\n                data: fileUrl,\n                name: typeof fileUrl === 'string' ? fileUrl : '',\n                shouldLoad: visible,\n            });\n        }\n    }, [fileUrl, visible]);\n    var visibilityChanged = function (params) {\n        setVisible(params.isVisible);\n        if (params.isVisible) {\n            setFile(function (currentFile) { return Object.assign({}, currentFile, { shouldLoad: true }); });\n        }\n    };\n    var containerRef = useIntersectionObserver({\n        onVisibilityChanged: visibilityChanged,\n    });\n    var themeProps = typeof theme === 'string' ? { direction: exports.TextDirection.LeftToRight, theme: theme } : theme;\n    var _v = React__namespace.useState(localization || DefaultLocalization), l10n = _v[0], setL10n = _v[1];\n    var localizationContext = { l10n: l10n, setL10n: setL10n };\n    var themeContext = Object.assign({}, { direction: themeProps.direction }, withTheme(themeProps.theme || 'light', onSwitchTheme));\n    React__namespace.useEffect(function () {\n        if (localization) {\n            setL10n(localization);\n        }\n    }, [localization]);\n    return (React__namespace.createElement(LocalizationContext.Provider, { value: localizationContext },\n        React__namespace.createElement(ThemeContext.Provider, { value: themeContext },\n            React__namespace.createElement(\"div\", { ref: containerRef, className: \"rpv-core__viewer rpv-core__viewer--\".concat(themeContext.currentTheme), \"data-testid\": \"core__viewer\", style: {\n                    height: '100%',\n                    width: '100%',\n                } }, file.shouldLoad && (React__namespace.createElement(DocumentLoader, { characterMap: characterMap, file: file.data, httpHeaders: httpHeaders, render: function (doc) { return (React__namespace.createElement(PageSizeCalculator, { defaultScale: defaultScale, doc: doc, render: function (pageSizes, initialScale) { return (React__namespace.createElement(Inner, { currentFile: {\n                            data: file.data,\n                            name: file.name,\n                        }, defaultScale: defaultScale, doc: doc, enableSmoothScroll: enableSmoothScroll, initialPage: initialPage, initialRotation: initialRotation, initialScale: initialScale, pageLayout: pageLayout, pageSizes: pageSizes, plugins: plugins, renderPage: renderPage, scrollMode: scrollMode, setRenderRange: setRenderRange, viewMode: viewMode, viewerState: {\n                            file: file,\n                            fullScreenMode: exports.FullScreenMode.Normal,\n                            pageIndex: -1,\n                            pageHeight: pageSizes[0].pageHeight,\n                            pageWidth: pageSizes[0].pageWidth,\n                            pagesRotation: new Map(),\n                            rotation: initialRotation,\n                            scale: initialScale,\n                            scrollMode: scrollMode,\n                            viewMode: viewMode,\n                        }, onDocumentLoad: onDocumentLoad, onOpenFile: openFile, onPageChange: onPageChange, onRotate: onRotate, onRotatePage: onRotatePage, onZoom: onZoom })); }, scrollMode: scrollMode, viewMode: viewMode })); }, renderError: renderError, renderLoader: renderLoader, renderProtectedView: renderProtectedView, transformGetDocumentParams: transformGetDocumentParams, withCredentials: withCredentials, onDocumentAskPassword: onDocumentAskPassword }))))));\n};\n\nvar Worker = function (_a) {\n    var children = _a.children, workerUrl = _a.workerUrl;\n    PdfJsApi__namespace.GlobalWorkerOptions.workerSrc = workerUrl;\n    return React__namespace.createElement(React__namespace.Fragment, null, children);\n};\n\nexports.Button = Button;\nexports.Icon = Icon;\nexports.LazyRender = LazyRender;\nexports.LocalizationContext = LocalizationContext;\nexports.Menu = Menu;\nexports.MenuDivider = MenuDivider;\nexports.MenuItem = MenuItem;\nexports.MinimalButton = MinimalButton;\nexports.Modal = Modal;\nexports.Popover = Popover;\nexports.PrimaryButton = PrimaryButton;\nexports.ProgressBar = ProgressBar;\nexports.Separator = Separator;\nexports.Spinner = Spinner;\nexports.Splitter = Splitter;\nexports.TextBox = TextBox;\nexports.ThemeContext = ThemeContext;\nexports.Tooltip = Tooltip;\nexports.Viewer = Viewer;\nexports.Worker = Worker;\nexports.chunk = chunk;\nexports.classNames = classNames;\nexports.createStore = createStore;\nexports.getDestination = getDestination;\nexports.getPage = getPage;\nexports.isFullScreenEnabled = isFullScreenEnabled;\nexports.isMac = isMac;\nexports.useDebounceCallback = useDebounceCallback;\nexports.useIntersectionObserver = useIntersectionObserver;\nexports.useIsMounted = useIsMounted;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.usePrevious = usePrevious;\nexports.useRenderQueue = useRenderQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi12aWV3ZXIvY29yZS9saWIvY2pzL2NvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxnRUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkIsc0JBQXNCLEtBQUs7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIscUJBQXFCLEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsK0NBQStDO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFFQUFxRSx1Q0FBdUM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzREFBc0Q7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdFQUF3RSxnRUFBZ0U7QUFDeEksZ0ZBQWdGLDJFQUEyRTtBQUMzSix1RUFBdUUseUZBQXlGO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvSkFBb0osS0FBSyw4Q0FBOEMsS0FBSywwT0FBME87QUFDL2M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsWUFBWTtBQUNaLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixlQUFlO0FBQ2YsMkJBQTJCO0FBQzNCLGFBQWE7QUFDYiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLG9CQUFvQjtBQUNwQixpQ0FBaUM7QUFDakMsbUJBQW1CO0FBQ25CLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1bW1lcnktYWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi12aWV3ZXIvY29yZS9saWIvY2pzL2NvcmUuanM/YTJkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUGRmSnNBcGkgPSByZXF1aXJlKCdwZGZqcy1kaXN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuLmRlZmF1bHQgPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoUmVhY3QpO1xudmFyIFBkZkpzQXBpX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KFBkZkpzQXBpKTtcblxuZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoQW5ub3RhdGlvblR5cGUpIHtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiTGlua1wiXSA9IDJdID0gXCJMaW5rXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJGcmVlVGV4dFwiXSA9IDNdID0gXCJGcmVlVGV4dFwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiTGluZVwiXSA9IDRdID0gXCJMaW5lXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJTcXVhcmVcIl0gPSA1XSA9IFwiU3F1YXJlXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJDaXJjbGVcIl0gPSA2XSA9IFwiQ2lyY2xlXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJQb2x5Z29uXCJdID0gN10gPSBcIlBvbHlnb25cIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlBvbHlsaW5lXCJdID0gOF0gPSBcIlBvbHlsaW5lXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJIaWdobGlnaHRcIl0gPSA5XSA9IFwiSGlnaGxpZ2h0XCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJVbmRlcmxpbmVcIl0gPSAxMF0gPSBcIlVuZGVybGluZVwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiU3F1aWdnbHlcIl0gPSAxMV0gPSBcIlNxdWlnZ2x5XCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJTdHJpa2VPdXRcIl0gPSAxMl0gPSBcIlN0cmlrZU91dFwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiU3RhbXBcIl0gPSAxM10gPSBcIlN0YW1wXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJDYXJldFwiXSA9IDE0XSA9IFwiQ2FyZXRcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIklua1wiXSA9IDE1XSA9IFwiSW5rXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJQb3B1cFwiXSA9IDE2XSA9IFwiUG9wdXBcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIkZpbGVBdHRhY2htZW50XCJdID0gMTddID0gXCJGaWxlQXR0YWNobWVudFwiO1xufSkoZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IHt9KSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cblxuZXhwb3J0cy5UZXh0RGlyZWN0aW9uID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChUZXh0RGlyZWN0aW9uKSB7XG4gICAgVGV4dERpcmVjdGlvbltcIlJpZ2h0VG9MZWZ0XCJdID0gXCJSVExcIjtcbiAgICBUZXh0RGlyZWN0aW9uW1wiTGVmdFRvUmlnaHRcIl0gPSBcIkxUUlwiO1xufSkoZXhwb3J0cy5UZXh0RGlyZWN0aW9uIHx8IChleHBvcnRzLlRleHREaXJlY3Rpb24gPSB7fSkpO1xudmFyIFRoZW1lQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dCh7XG4gICAgY3VycmVudFRoZW1lOiAnbGlnaHQnLFxuICAgIGRpcmVjdGlvbjogZXhwb3J0cy5UZXh0RGlyZWN0aW9uLkxlZnRUb1JpZ2h0LFxuICAgIHNldEN1cnJlbnRUaGVtZTogZnVuY3Rpb24gKCkgeyB9LFxufSk7XG5cbnZhciBjbGFzc05hbWVzID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgT2JqZWN0LmtleXMoY2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgaWYgKGNsYXp6ICYmIGNsYXNzZXNbY2xhenpdKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjbGF6eik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbn07XG5cbnZhciBCdXR0b24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgdGVzdElkID0gX2EudGVzdElkLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBhdHRycyA9IHRlc3RJZCA/IHsgJ2RhdGEtdGVzdGlkJzogdGVzdElkIH0gOiB7fTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX2J1dHRvbic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX2J1dHRvbi0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBvbkNsaWNrIH0sIGF0dHJzKSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCA6IFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0O1xuXG52YXIgdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYobnVsbCk7XG4gICAgdmFyIG9uY2UgPSBwcm9wcy5vbmNlLCB0aHJlc2hvbGQgPSBwcm9wcy50aHJlc2hvbGQsIG9uVmlzaWJpbGl0eUNoYW5nZWQgPSBwcm9wcy5vblZpc2liaWxpdHlDaGFuZ2VkO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyc2VjdGlvblRyYWNrZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlZCh7IGlzVmlzaWJsZTogaXNWaXNpYmxlLCByYXRpbzogcmF0aW8gfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBvbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblRyYWNrZXIudW5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblRyYWNrZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZCB8fCAwLFxuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJzZWN0aW9uVHJhY2tlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25UcmFja2VyLnVub2JzZXJ2ZShjb250YWluZXIpO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uVHJhY2tlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBjb250YWluZXJSZWY7XG59O1xuXG52YXIgTGF6eVJlbmRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhdHRycyA9IF9hLmF0dHJzLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCB0ZXN0SWQgPSBfYS50ZXN0SWQ7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIHZpc2libGUgPSBfYlswXSwgc2V0VmlzaWJsZSA9IF9iWzFdO1xuICAgIHZhciBjb250YWluZXJBdHRycyA9IHRlc3RJZCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBhdHRycyksIHsgJ2RhdGEtdGVzdGlkJzogdGVzdElkIH0pIDogYXR0cnM7XG4gICAgdmFyIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbnRhaW5lclJlZiA9IHVzZUludGVyc2VjdGlvbk9ic2VydmVyKHtcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlZDogaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oeyByZWY6IGNvbnRhaW5lclJlZiB9LCBjb250YWluZXJBdHRycyksIHZpc2libGUgJiYgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBNZW51ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIGNvbnRhaW5lclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIHZpc2libGVNZW51SXRlbXNSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihbXSk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1vdmVUb0l0ZW0oZnVuY3Rpb24gKF8sIGN1cnJlbnRJbmRleCkgeyByZXR1cm4gY3VycmVudEluZGV4ICsgMTsgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbW92ZVRvSXRlbShmdW5jdGlvbiAoXywgY3VycmVudEluZGV4KSB7IHJldHVybiBjdXJyZW50SW5kZXggLSAxOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1vdmVUb0l0ZW0oZnVuY3Rpb24gKGl0ZW1zLCBfKSB7IHJldHVybiBpdGVtcy5sZW5ndGggLSAxOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBtb3ZlVG9JdGVtKGZ1bmN0aW9uIChfLCBfXykgeyByZXR1cm4gMDsgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBtb3ZlVG9JdGVtID0gZnVuY3Rpb24gKGdldE5leHRJdGVtKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbXMgPSB2aXNpYmxlTWVudUl0ZW1zUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSAnMCc7IH0pO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBNYXRoLm1pbihpdGVtcy5sZW5ndGggLSAxLCBNYXRoLm1heCgwLCBnZXROZXh0SXRlbShpdGVtcywgY3VycmVudEluZGV4KSkpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID49IDAgJiYgY3VycmVudEluZGV4IDw9IGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGl0ZW1zW2N1cnJlbnRJbmRleF0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1zW3RhcmdldEluZGV4XS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgaXRlbXNbdGFyZ2V0SW5kZXhdLmZvY3VzKCk7XG4gICAgfTtcbiAgICB2YXIgZmluZFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIHZpc2libGVJdGVtcyA9IFtdO1xuICAgICAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnJwdi1jb3JlX19tZW51LWl0ZW1bcm9sZT1cIm1lbnVpdGVtXCJdJykuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGl0ZW0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50XzEgPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRfMSkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2aXNpYmxlSXRlbXM7XG4gICAgfTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aXNpYmxlSXRlbXMgPSBmaW5kVmlzaWJsZUl0ZW1zKGNvbnRhaW5lcik7XG4gICAgICAgIHZpc2libGVNZW51SXRlbXNSZWYuY3VycmVudCA9IHZpc2libGVJdGVtcztcbiAgICB9LCBbXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lclJlZiwgXCJhcmlhLW9yaWVudGF0aW9uXCI6IFwidmVydGljYWxcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fbWVudSc6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSwgcm9sZTogXCJtZW51XCIsIHRhYkluZGV4OiAwIH0sIGNoaWxkcmVuKSk7XG59O1xuXG52YXIgTWVudURpdmlkZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLW9yaWVudGF0aW9uXCI6IFwiaG9yaXpvbnRhbFwiLCBjbGFzc05hbWU6IFwicnB2LWNvcmVfX21lbnUtZGl2aWRlclwiLCByb2xlOiBcInNlcGFyYXRvclwiIH0pKTsgfTtcblxudmFyIEljb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgX2IgPSBfYS5pZ25vcmVEaXJlY3Rpb24sIGlnbm9yZURpcmVjdGlvbiA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IF9hLnNpemUsIHNpemUgPSBfYyA9PT0gdm9pZCAwID8gMjQgOiBfYztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9ICFpZ25vcmVEaXJlY3Rpb24gJiYgZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIHdpZHRoID0gXCJcIi5jb25jYXQoc2l6ZSB8fCAyNCwgXCJweFwiKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX2ljb24nOiB0cnVlLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19pY29uLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgfSksIGZvY3VzYWJsZTogXCJmYWxzZVwiLCBoZWlnaHQ6IHdpZHRoLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCB3aWR0aDogd2lkdGggfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBDaGVja0ljb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEljb24sIHsgc2l6ZTogMTYgfSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjMuNSwwLjQ5OWwtMTYuNSwyM2wtNi41LTYuNVwiIH0pKSk7IH07XG5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLmNoZWNrZWQsIGNoZWNrZWQgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgX2MgPSBfYS5pY29uLCBpY29uID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYywgX2QgPSBfYS5pc0Rpc2FibGVkLCBpc0Rpc2FibGVkID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHRlc3RJZCA9IF9hLnRlc3RJZCwgb25DbGljayA9IF9hLm9uQ2xpY2s7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgYXR0cnMgPSB0ZXN0SWQgPyB7ICdkYXRhLXRlc3RpZCc6IHRlc3RJZCB9IDoge307XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0nOiB0cnVlLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tLWRpc2FibGVkJzogaXNEaXNhYmxlZCxcbiAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLS1sdHInOiAhaXNSdGwsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pLCByb2xlOiBcIm1lbnVpdGVtXCIsIHRhYkluZGV4OiAtMSwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogb25DbGljayB9LCBhdHRycyksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0taWNvbic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0taWNvbi0tbHRyJzogIWlzUnRsLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLWljb24tLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgfSkgfSwgaWNvbiksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tbGFiZWwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLWxhYmVsLS1sdHInOiAhaXNSdGwsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tbGFiZWwtLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgfSkgfSwgY2hpbGRyZW4pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLWNoZWNrJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS1jaGVjay0tbHRyJzogIWlzUnRsLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLWNoZWNrLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgIH0pIH0sIGNoZWNrZWQgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KENoZWNrSWNvbiwgbnVsbCkpKSk7XG59O1xuXG52YXIgTWluaW1hbEJ1dHRvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLmFyaWFMYWJlbCwgYXJpYUxhYmVsID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2IsIF9jID0gX2EuYXJpYUtleVNob3J0Y3V0cywgYXJpYUtleVNob3J0Y3V0cyA9IF9jID09PSB2b2lkIDAgPyAnJyA6IF9jLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfZCA9IF9hLmlzRGlzYWJsZWQsIGlzRGlzYWJsZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYS5pc1NlbGVjdGVkLCBpc1NlbGVjdGVkID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIHRlc3RJZCA9IF9hLnRlc3RJZCwgb25DbGljayA9IF9hLm9uQ2xpY2s7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgYXR0cnMgPSB0ZXN0SWQgPyB7ICdkYXRhLXRlc3RpZCc6IHRlc3RJZCB9IDoge307XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX19hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsIH0sIChhcmlhS2V5U2hvcnRjdXRzICYmIHsgJ2FyaWEta2V5c2hvcnRjdXRzJzogYXJpYUtleVNob3J0Y3V0cyB9KSwgKGlzRGlzYWJsZWQgJiYgeyAnYXJpYS1kaXNhYmxlZCc6IHRydWUgfSksIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fbWluaW1hbC1idXR0b24nOiB0cnVlLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19taW5pbWFsLWJ1dHRvbi0tZGlzYWJsZWQnOiBpc0Rpc2FibGVkLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19taW5pbWFsLWJ1dHRvbi0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21pbmltYWwtYnV0dG9uLS1zZWxlY3RlZCc6IGlzU2VsZWN0ZWQsXG4gICAgICAgIH0pLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBvbkNsaWNrIH0sIGF0dHJzKSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBQcmltYXJ5QnV0dG9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIHRlc3RJZCA9IF9hLnRlc3RJZCwgb25DbGljayA9IF9hLm9uQ2xpY2s7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgYXR0cnMgPSB0ZXN0SWQgPyB7ICdkYXRhLXRlc3RpZCc6IHRlc3RJZCB9IDoge307XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19wcmltYXJ5LWJ1dHRvbic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX3ByaW1hcnktYnV0dG9uLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgfSksIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IG9uQ2xpY2sgfSwgYXR0cnMpLCBjaGlsZHJlbikpO1xufTtcblxudmFyIFByb2dyZXNzQmFyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHByb2dyZXNzID0gX2EucHJvZ3Jlc3M7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX3Byb2dyZXNzLWJhcic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX3Byb2dyZXNzLWJhci0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pIH0sXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fcHJvZ3Jlc3MtYmFyLXByb2dyZXNzXCIsIHN0eWxlOiB7IHdpZHRoOiBcIlwiLmNvbmNhdChwcm9ncmVzcywgXCIlXCIpIH0gfSxcbiAgICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgICAgXCIlXCIpKSk7XG59O1xuXG52YXIgU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19zZXBhcmF0b3JcIiB9KTsgfTtcblxudmFyIFNwaW5uZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5zaXplLCBzaXplID0gX2IgPT09IHZvaWQgMCA/ICc0cmVtJyA6IF9iLCB0ZXN0SWQgPSBfYS50ZXN0SWQ7XG4gICAgdmFyIF9jID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIHZpc2libGUgPSBfY1swXSwgc2V0VmlzaWJsZSA9IF9jWzFdO1xuICAgIHZhciBhdHRycyA9IHRlc3RJZCA/IHsgJ2RhdGEtdGVzdGlkJzogdGVzdElkIH0gOiB7fTtcbiAgICB2YXIgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHNldFZpc2libGUocGFyYW1zLmlzVmlzaWJsZSk7XG4gICAgfTtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoe1xuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2VkOiBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCxcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgYXR0cnMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fc3Bpbm5lcic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX3NwaW5uZXItLWFuaW1hdGluZyc6IHZpc2libGUsXG4gICAgICAgIH0pLCByZWY6IGNvbnRhaW5lclJlZiwgc3R5bGU6IHsgaGVpZ2h0OiBzaXplLCB3aWR0aDogc2l6ZSB9IH0pKSk7XG59O1xuXG52YXIgU3BsaXR0ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY29uc3RyYWluID0gX2EuY29uc3RyYWluO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIHJlc2l6ZXJSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBsZWZ0U2lkZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIHJpZ2h0U2lkZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIHhSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigwKTtcbiAgICB2YXIgeVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKDApO1xuICAgIHZhciBsZWZ0V2lkdGhSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigwKTtcbiAgICB2YXIgcmVzaXplcldpZHRoUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoMCk7XG4gICAgdmFyIGV2ZW50T3B0aW9ucyA9IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICB9O1xuICAgIHZhciBoYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcmVzaXplckVsZSA9IHJlc2l6ZXJSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGxlZnRTaWRlID0gbGVmdFNpZGVSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHJpZ2h0U2lkZSA9IHJpZ2h0U2lkZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXJlc2l6ZXJFbGUgfHwgIWxlZnRTaWRlIHx8ICFyaWdodFNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzaXplcldpZHRoID0gcmVzaXplcldpZHRoUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBkeCA9IGUuY2xpZW50WCAtIHhSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGZpcnN0SGFsZlNpemUgPSBsZWZ0V2lkdGhSZWYuY3VycmVudCArIChpc1J0bCA/IC1keCA6IGR4KTtcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gcmVzaXplckVsZS5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB2YXIgZmlyc3RIYWxmUGVyY2VudGFnZSA9IChmaXJzdEhhbGZTaXplICogMTAwKSAvIGNvbnRhaW5lcldpZHRoO1xuICAgICAgICByZXNpemVyRWxlLmNsYXNzTGlzdC5hZGQoJ3Jwdi1jb3JlX19zcGxpdHRlci0tcmVzaXppbmcnKTtcbiAgICAgICAgaWYgKGNvbnN0cmFpbikge1xuICAgICAgICAgICAgdmFyIHNlY29uZEhhbGZTaXplID0gY29udGFpbmVyV2lkdGggLSBmaXJzdEhhbGZTaXplIC0gcmVzaXplcldpZHRoO1xuICAgICAgICAgICAgdmFyIHNlY29uZEhhbGZQZXJjZW50YWdlID0gKHNlY29uZEhhbGZTaXplICogMTAwKSAvIGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgaWYgKCFjb25zdHJhaW4oeyBmaXJzdEhhbGZQZXJjZW50YWdlOiBmaXJzdEhhbGZQZXJjZW50YWdlLCBmaXJzdEhhbGZTaXplOiBmaXJzdEhhbGZTaXplLCBzZWNvbmRIYWxmUGVyY2VudGFnZTogc2Vjb25kSGFsZlBlcmNlbnRhZ2UsIHNlY29uZEhhbGZTaXplOiBzZWNvbmRIYWxmU2l6ZSB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZWZ0U2lkZS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGZpcnN0SGFsZlBlcmNlbnRhZ2UsIFwiJVwiKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdycHYtY29yZV9fc3BsaXR0ZXItYm9keS0tcmVzaXppbmcnKTtcbiAgICAgICAgbGVmdFNpZGUuY2xhc3NMaXN0LmFkZCgncnB2LWNvcmVfX3NwbGl0dGVyLXNpYmxpbmctLXJlc2l6aW5nJyk7XG4gICAgICAgIHJpZ2h0U2lkZS5jbGFzc0xpc3QuYWRkKCdycHYtY29yZV9fc3BsaXR0ZXItc2libGluZy0tcmVzaXppbmcnKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHJlc2l6ZXJFbGUgPSByZXNpemVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBsZWZ0U2lkZSA9IGxlZnRTaWRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciByaWdodFNpZGUgPSByaWdodFNpZGVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFyZXNpemVyRWxlIHx8ICFsZWZ0U2lkZSB8fCAhcmlnaHRTaWRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdycHYtY29yZV9fc3BsaXR0ZXItYm9keS0tcmVzaXppbmcnKTtcbiAgICAgICAgcmVzaXplckVsZS5jbGFzc0xpc3QucmVtb3ZlKCdycHYtY29yZV9fc3BsaXR0ZXItLXJlc2l6aW5nJyk7XG4gICAgICAgIGxlZnRTaWRlLmNsYXNzTGlzdC5yZW1vdmUoJ3Jwdi1jb3JlX19zcGxpdHRlci1zaWJsaW5nLS1yZXNpemluZycpO1xuICAgICAgICByaWdodFNpZGUuY2xhc3NMaXN0LnJlbW92ZSgncnB2LWNvcmVfX3NwbGl0dGVyLXNpYmxpbmctLXJlc2l6aW5nJyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXAsIGV2ZW50T3B0aW9ucyk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGxlZnRTaWRlID0gbGVmdFNpZGVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFsZWZ0U2lkZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHhSZWYuY3VycmVudCA9IGUuY2xpZW50WDtcbiAgICAgICAgeVJlZi5jdXJyZW50ID0gZS5jbGllbnRZO1xuICAgICAgICBsZWZ0V2lkdGhSZWYuY3VycmVudCA9IGxlZnRTaWRlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwLCBldmVudE9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzaXplckVsZSA9IHJlc2l6ZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFyZXNpemVyRWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzaXplcldpZHRoUmVmLmN1cnJlbnQgPSByZXNpemVyRWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBsZWZ0U2lkZVJlZi5jdXJyZW50ID0gcmVzaXplckVsZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICByaWdodFNpZGVSZWYuY3VycmVudCA9IHJlc2l6ZXJFbGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByZXNpemVyUmVmLCBjbGFzc05hbWU6IFwicnB2LWNvcmVfX3NwbGl0dGVyXCIsIG9uTW91c2VEb3duOiBoYW5kbGVNb3VzZURvd24gfSk7XG59O1xuXG52YXIgVGV4dEJveCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLmFyaWFMYWJlbCwgYXJpYUxhYmVsID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2IsIF9jID0gX2EuYXV0b0ZvY3VzLCBhdXRvRm9jdXMgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYS5wbGFjZWhvbGRlciwgcGxhY2Vob2xkZXIgPSBfZCA9PT0gdm9pZCAwID8gJycgOiBfZCwgdGVzdElkID0gX2EudGVzdElkLCBfZSA9IF9hLnR5cGUsIHR5cGUgPSBfZSA9PT0gdm9pZCAwID8gJ3RleHQnIDogX2UsIF9mID0gX2EudmFsdWUsIHZhbHVlID0gX2YgPT09IHZvaWQgMCA/ICcnIDogX2YsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIF9nID0gX2Eub25LZXlEb3duLCBvbktleURvd24gPSBfZyA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkgeyB9IDogX2c7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgdGV4dGJveFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICByZWY6IHRleHRib3hSZWYsXG4gICAgICAgICdkYXRhLXRlc3RpZCc6ICcnLFxuICAgICAgICAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fdGV4dGJveCc6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX3RleHRib3gtLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25DaGFuZ2UoZS50YXJnZXQudmFsdWUpOyB9LFxuICAgICAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICB9O1xuICAgIGlmICh0ZXN0SWQpIHtcbiAgICAgICAgYXR0cnNbJ2RhdGEtdGVzdGlkJ10gPSB0ZXN0SWQ7XG4gICAgfVxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgICB2YXIgdGV4dGJveEVsZSA9IHRleHRib3hSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICh0ZXh0Ym94RWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICAgICAgICAgIHRleHRib3hFbGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0JyA/IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9fYXNzaWduKHsgdHlwZTogXCJ0ZXh0XCIgfSwgYXR0cnMpKSA6IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9fYXNzaWduKHsgdHlwZTogXCJwYXNzd29yZFwiIH0sIGF0dHJzKSk7XG59O1xuXG52YXIgQXBpO1xuKGZ1bmN0aW9uIChBcGkpIHtcbiAgICBBcGlbQXBpW1wiRXhpdEZ1bGxTY3JlZW5cIl0gPSAwXSA9IFwiRXhpdEZ1bGxTY3JlZW5cIjtcbiAgICBBcGlbQXBpW1wiRnVsbFNjcmVlbkNoYW5nZVwiXSA9IDFdID0gXCJGdWxsU2NyZWVuQ2hhbmdlXCI7XG4gICAgQXBpW0FwaVtcIkZ1bGxTY3JlZW5FbGVtZW50XCJdID0gMl0gPSBcIkZ1bGxTY3JlZW5FbGVtZW50XCI7XG4gICAgQXBpW0FwaVtcIkZ1bGxTY3JlZW5FbmFibGVkXCJdID0gM10gPSBcIkZ1bGxTY3JlZW5FbmFibGVkXCI7XG4gICAgQXBpW0FwaVtcIlJlcXVlc3RGdWxsU2NyZWVuXCJdID0gNF0gPSBcIlJlcXVlc3RGdWxsU2NyZWVuXCI7XG59KShBcGkgfHwgKEFwaSA9IHt9KSk7XG52YXIgZGVmYXVsdFZlbmRvciA9IHtcbiAgICBFeGl0RnVsbFNjcmVlbjogJ2V4aXRGdWxsc2NyZWVuJyxcbiAgICBGdWxsU2NyZWVuQ2hhbmdlOiAnZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgRnVsbFNjcmVlbkVsZW1lbnQ6ICdmdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgRnVsbFNjcmVlbkVuYWJsZWQ6ICdmdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgUmVxdWVzdEZ1bGxTY3JlZW46ICdyZXF1ZXN0RnVsbHNjcmVlbicsXG59O1xudmFyIHdlYmtpdFZlbmRvciA9IHtcbiAgICBFeGl0RnVsbFNjcmVlbjogJ3dlYmtpdEV4aXRGdWxsc2NyZWVuJyxcbiAgICBGdWxsU2NyZWVuQ2hhbmdlOiAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgRnVsbFNjcmVlbkVsZW1lbnQ6ICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgRnVsbFNjcmVlbkVuYWJsZWQ6ICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgUmVxdWVzdEZ1bGxTY3JlZW46ICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsXG59O1xudmFyIG1zVmVuZG9yID0ge1xuICAgIEV4aXRGdWxsU2NyZWVuOiAnbXNFeGl0RnVsbHNjcmVlbicsXG4gICAgRnVsbFNjcmVlbkNoYW5nZTogJ21zRnVsbHNjcmVlbkNoYW5nZScsXG4gICAgRnVsbFNjcmVlbkVsZW1lbnQ6ICdtc0Z1bGxzY3JlZW5FbGVtZW50JyxcbiAgICBGdWxsU2NyZWVuRW5hYmxlZDogJ21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgIFJlcXVlc3RGdWxsU2NyZWVuOiAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXG59O1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIHZlbmRvciA9IGlzQnJvd3NlclxuICAgID8gKEFwaS5GdWxsU2NyZWVuRW5hYmxlZCBpbiBkb2N1bWVudCAmJiBkZWZhdWx0VmVuZG9yKSB8fFxuICAgICAgICAod2Via2l0VmVuZG9yLkZ1bGxTY3JlZW5FbmFibGVkIGluIGRvY3VtZW50ICYmIHdlYmtpdFZlbmRvcikgfHxcbiAgICAgICAgKG1zVmVuZG9yLkZ1bGxTY3JlZW5FbmFibGVkIGluIGRvY3VtZW50ICYmIG1zVmVuZG9yKSB8fFxuICAgICAgICBkZWZhdWx0VmVuZG9yXG4gICAgOiBkZWZhdWx0VmVuZG9yO1xudmFyIGlzRnVsbFNjcmVlbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB2ZW5kb3IuRnVsbFNjcmVlbkVuYWJsZWQgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnRbdmVuZG9yLkZ1bGxTY3JlZW5FbmFibGVkXSA9PT0gdHJ1ZTtcbn07XG52YXIgYWRkRnVsbFNjcmVlbkNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodmVuZG9yLkZ1bGxTY3JlZW5DaGFuZ2UsIGhhbmRsZXIpO1xuICAgIH1cbn07XG52YXIgcmVtb3ZlRnVsbFNjcmVlbkNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodmVuZG9yLkZ1bGxTY3JlZW5DaGFuZ2UsIGhhbmRsZXIpO1xuICAgIH1cbn07XG52YXIgZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0Jyb3dzZXJcbiAgICAgICAgP1xuICAgICAgICAgICAgZWxlbWVudFt2ZW5kb3IuRXhpdEZ1bGxTY3JlZW5dKClcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoe30pO1xufTtcbnZhciBnZXRGdWxsU2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyID8gZG9jdW1lbnRbdmVuZG9yLkZ1bGxTY3JlZW5FbGVtZW50XSA6IG51bGw7XG59O1xudmFyIHJlcXVlc3RGdWxsU2NyZWVuID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGVsZW1lbnRbdmVuZG9yLlJlcXVlc3RGdWxsU2NyZWVuXSgpO1xuICAgIH1cbn07XG5cbnZhciB1c2VEZWJvdW5jZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB3YWl0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGltZW91dC5jdXJyZW50KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xlYW51cCgpOyB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB0aW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgIH0sIFtjYWxsYmFjaywgd2FpdF0pO1xufTtcblxudmFyIHVzZUlzTW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb3VudGVkUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoZmFsc2UpO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGlzTW91bnRlZFJlZjtcbn07XG5cbnZhciB1c2VQcmV2aW91cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZih2YWx1ZSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH0sIFt2YWx1ZV0pO1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn07XG5cbnZhciBQYWdlUmVuZGVyU3RhdHVzO1xuKGZ1bmN0aW9uIChQYWdlUmVuZGVyU3RhdHVzKSB7XG4gICAgUGFnZVJlbmRlclN0YXR1c1tcIk5vdFJlbmRlcmVkWWV0XCJdID0gXCJOb3RSZW5kZXJlZFlldFwiO1xuICAgIFBhZ2VSZW5kZXJTdGF0dXNbXCJSZW5kZXJpbmdcIl0gPSBcIlJlbmRlcmluZ1wiO1xuICAgIFBhZ2VSZW5kZXJTdGF0dXNbXCJSZW5kZXJlZFwiXSA9IFwiUmVuZGVyZWRcIjtcbn0pKFBhZ2VSZW5kZXJTdGF0dXMgfHwgKFBhZ2VSZW5kZXJTdGF0dXMgPSB7fSkpO1xudmFyIE9VVF9PRl9SQU5HRV9WSVNJQklMSVRZID0gLTk5OTk7XG52YXIgdXNlUmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZG9jID0gX2EuZG9jO1xuICAgIHZhciBudW1QYWdlcyA9IGRvYy5udW1QYWdlcztcbiAgICB2YXIgZG9jSWQgPSBkb2MubG9hZGluZ1Rhc2suZG9jSWQ7XG4gICAgdmFyIGluaXRpYWxQYWdlVmlzaWJpbGl0aWVzID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KG51bVBhZ2VzKVxuICAgICAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF8sIHBhZ2VJbmRleCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgcmVuZGVyU3RhdHVzOiBQYWdlUmVuZGVyU3RhdHVzLk5vdFJlbmRlcmVkWWV0LFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogT1VUX09GX1JBTkdFX1ZJU0lCSUxJVFksXG4gICAgICAgIH0pOyB9KTtcbiAgICB9LCBbZG9jSWRdKTtcbiAgICB2YXIgbGF0ZXN0UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe1xuICAgICAgICBjdXJyZW50UmVuZGVyaW5nUGFnZTogLTEsXG4gICAgICAgIHN0YXJ0UmFuZ2U6IDAsXG4gICAgICAgIGVuZFJhbmdlOiBudW1QYWdlcyAtIDEsXG4gICAgICAgIHZpc2liaWxpdGllczogaW5pdGlhbFBhZ2VWaXNpYmlsaXRpZXMsXG4gICAgfSk7XG4gICAgdmFyIG1hcmtOb3RSZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QYWdlczsgaSsrKSB7XG4gICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbaV0ucmVuZGVyU3RhdHVzID0gUGFnZVJlbmRlclN0YXR1cy5Ob3RSZW5kZXJlZFlldDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG1hcmtSZW5kZXJlZCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpIHtcbiAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzW3BhZ2VJbmRleF0ucmVuZGVyU3RhdHVzID0gUGFnZVJlbmRlclN0YXR1cy5SZW5kZXJlZDtcbiAgICB9O1xuICAgIHZhciBtYXJrUmVuZGVyaW5nID0gZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgICBpZiAobGF0ZXN0UmVmLmN1cnJlbnQuY3VycmVudFJlbmRlcmluZ1BhZ2UgIT09IC0xICYmXG4gICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC5jdXJyZW50UmVuZGVyaW5nUGFnZSAhPT0gcGFnZUluZGV4ICYmXG4gICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbbGF0ZXN0UmVmLmN1cnJlbnQuY3VycmVudFJlbmRlcmluZ1BhZ2VdLnJlbmRlclN0YXR1cyA9PT1cbiAgICAgICAgICAgICAgICBQYWdlUmVuZGVyU3RhdHVzLlJlbmRlcmluZykge1xuICAgICAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzW2xhdGVzdFJlZi5jdXJyZW50LmN1cnJlbnRSZW5kZXJpbmdQYWdlXS5yZW5kZXJTdGF0dXMgPVxuICAgICAgICAgICAgICAgIFBhZ2VSZW5kZXJTdGF0dXMuTm90UmVuZGVyZWRZZXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzW3BhZ2VJbmRleF0ucmVuZGVyU3RhdHVzID0gUGFnZVJlbmRlclN0YXR1cy5SZW5kZXJpbmc7XG4gICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LmN1cnJlbnRSZW5kZXJpbmdQYWdlID0gcGFnZUluZGV4O1xuICAgIH07XG4gICAgdmFyIHNldFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LnN0YXJ0UmFuZ2UgPSBzdGFydEluZGV4O1xuICAgICAgICBsYXRlc3RSZWYuY3VycmVudC5lbmRSYW5nZSA9IGVuZEluZGV4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgc3RhcnRJbmRleCB8fCBpID4gZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbaV0udmlzaWJpbGl0eSA9IE9VVF9PRl9SQU5HRV9WSVNJQklMSVRZO1xuICAgICAgICAgICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LnZpc2liaWxpdGllc1tpXS5yZW5kZXJTdGF0dXMgPSBQYWdlUmVuZGVyU3RhdHVzLk5vdFJlbmRlcmVkWWV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgc2V0T3V0T2ZSYW5nZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpIHtcbiAgICAgICAgc2V0VmlzaWJpbGl0eShwYWdlSW5kZXgsIE9VVF9PRl9SQU5HRV9WSVNJQklMSVRZKTtcbiAgICB9O1xuICAgIHZhciBzZXRWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgdmlzaWJpbGl0eSkge1xuICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbcGFnZUluZGV4XS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICB9O1xuICAgIHZhciBnZXRIaWdoZXN0UHJpb3JpdHlQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlzaWJsZVBhZ2VzID0gbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzXG4gICAgICAgICAgICAuc2xpY2UobGF0ZXN0UmVmLmN1cnJlbnQuc3RhcnRSYW5nZSwgbGF0ZXN0UmVmLmN1cnJlbnQuZW5kUmFuZ2UgKyAxKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS52aXNpYmlsaXR5ID4gT1VUX09GX1JBTkdFX1ZJU0lCSUxJVFk7IH0pO1xuICAgICAgICBpZiAoIXZpc2libGVQYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RWaXNpYmxlUGFnZSA9IHZpc2libGVQYWdlc1swXS5wYWdlSW5kZXg7XG4gICAgICAgIHZhciBsYXN0VmlzaWJsZVBhZ2UgPSB2aXNpYmxlUGFnZXNbdmlzaWJsZVBhZ2VzLmxlbmd0aCAtIDFdLnBhZ2VJbmRleDtcbiAgICAgICAgdmFyIG51bVZpc2libGVQYWdlcyA9IHZpc2libGVQYWdlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmlzaWJsZVBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2aXNpYmxlUGFnZXNbaV0ucmVuZGVyU3RhdHVzID09PSBQYWdlUmVuZGVyU3RhdHVzLlJlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpYmxlUGFnZXNbaV0ucmVuZGVyU3RhdHVzID09PSBQYWdlUmVuZGVyU3RhdHVzLk5vdFJlbmRlcmVkWWV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVQYWdlc1tpXS5wYWdlSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RWaXNpYmxlUGFnZSArIDEgPCBudW1QYWdlcyAmJlxuICAgICAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzW2xhc3RWaXNpYmxlUGFnZSArIDFdLnJlbmRlclN0YXR1cyAhPT0gUGFnZVJlbmRlclN0YXR1cy5SZW5kZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWaXNpYmxlUGFnZSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlyc3RWaXNpYmxlUGFnZSAtIDEgPj0gMCAmJlxuICAgICAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzW2ZpcnN0VmlzaWJsZVBhZ2UgLSAxXS5yZW5kZXJTdGF0dXMgIT09IFBhZ2VSZW5kZXJTdGF0dXMuUmVuZGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdFZpc2libGVQYWdlIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICB2YXIgaXNJblJhbmdlID0gZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgICByZXR1cm4gcGFnZUluZGV4ID49IGxhdGVzdFJlZi5jdXJyZW50LnN0YXJ0UmFuZ2UgJiYgcGFnZUluZGV4IDw9IGxhdGVzdFJlZi5jdXJyZW50LmVuZFJhbmdlO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SGlnaGVzdFByaW9yaXR5UGFnZTogZ2V0SGlnaGVzdFByaW9yaXR5UGFnZSxcbiAgICAgICAgaXNJblJhbmdlOiBpc0luUmFuZ2UsXG4gICAgICAgIG1hcmtOb3RSZW5kZXJlZDogbWFya05vdFJlbmRlcmVkLFxuICAgICAgICBtYXJrUmVuZGVyZWQ6IG1hcmtSZW5kZXJlZCxcbiAgICAgICAgbWFya1JlbmRlcmluZzogbWFya1JlbmRlcmluZyxcbiAgICAgICAgc2V0T3V0T2ZSYW5nZTogc2V0T3V0T2ZSYW5nZSxcbiAgICAgICAgc2V0UmFuZ2U6IHNldFJhbmdlLFxuICAgICAgICBzZXRWaXNpYmlsaXR5OiBzZXRWaXNpYmlsaXR5LFxuICAgIH07XG59O1xuXG52YXIgY29yZSA9IHtcblx0YXNraW5nUGFzc3dvcmQ6IHtcblx0XHRyZXF1aXJlUGFzc3dvcmRUb09wZW46IFwiVGhpcyBkb2N1bWVudCByZXF1aXJlcyBhIHBhc3N3b3JkIHRvIG9wZW5cIixcblx0XHRzdWJtaXQ6IFwiU3VibWl0XCJcblx0fSxcblx0d3JvbmdQYXNzd29yZDoge1xuXHRcdHRyeUFnYWluOiBcIlRoZSBwYXNzd29yZCBpcyB3cm9uZy4gUGxlYXNlIHRyeSBhZ2FpblwiXG5cdH0sXG5cdHBhZ2VMYWJlbDogXCJQYWdlIHt7cGFnZUluZGV4fX1cIlxufTtcbnZhciBlblVzID0ge1xuXHRjb3JlOiBjb3JlXG59O1xuXG52YXIgRGVmYXVsdExvY2FsaXphdGlvbiA9IGVuVXM7XG52YXIgTG9jYWxpemF0aW9uQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dCh7XG4gICAgbDEwbjogRGVmYXVsdExvY2FsaXphdGlvbixcbiAgICBzZXRMMTBuOiBmdW5jdGlvbiAoKSB7IH0sXG59KTtcblxudmFyIGlkID0gMDtcbnZhciB1bmlxdWVJZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkKys7IH07XG5cbnZhciB1c2VDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoY2xvc2VPbkNsaWNrT3V0c2lkZSwgdGFyZ2V0UmVmLCBvbkNsaWNrT3V0c2lkZSkge1xuICAgIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaWNrZWRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKGNsaWNrZWRUYXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGNsaWNrZWRUYXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICAgIGlmIChwYXRocy5sZW5ndGggPiAwICYmICF0YXJnZXQuY29udGFpbnMocGF0aHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgb25DbGlja091dHNpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGFyZ2V0LmNvbnRhaW5zKGNsaWNrZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICBvbkNsaWNrT3V0c2lkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY2xvc2VPbkNsaWNrT3V0c2lkZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBldmVudE9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbnZhciB1c2VFc2NhcGUgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHZhciBrZXlVcEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXlVcEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXlVcEhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbnZhciB1c2VMb2NrU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5vdmVyZmxvdztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IG9yaWdpbmFsU3R5bGU7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcblxudmFyIE1vZGFsQm9keSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhcmlhQ29udHJvbHNTdWZmaXggPSBfYS5hcmlhQ29udHJvbHNTdWZmaXgsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsb3NlT25DbGlja091dHNpZGUgPSBfYS5jbG9zZU9uQ2xpY2tPdXRzaWRlLCBjbG9zZU9uRXNjYXBlID0gX2EuY2xvc2VPbkVzY2FwZSwgb25Ub2dnbGUgPSBfYS5vblRvZ2dsZTtcbiAgICB2YXIgY29udGVudFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB1c2VMb2NrU2Nyb2xsKCk7XG4gICAgdXNlRXNjYXBlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRSZWYuY3VycmVudCAmJiBjbG9zZU9uRXNjYXBlKSB7XG4gICAgICAgICAgICBvblRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdXNlQ2xpY2tPdXRzaWRlKGNsb3NlT25DbGlja091dHNpZGUsIGNvbnRlbnRSZWYsIG9uVG9nZ2xlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRFbGUgPSBjb250ZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGVudEVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCAqIDAuNzU7XG4gICAgICAgIGlmIChjb250ZW50RWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnRlbnRFbGUuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgICAgICAgICBjb250ZW50RWxlLnN0eWxlLm1heEhlaWdodCA9IFwiXCIuY29uY2F0KG1heEhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1tb2RhbFwiOiBcInRydWVcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fbW9kYWwtYm9keSc6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21vZGFsLWJvZHktLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSwgaWQ6IFwicnB2LWNvcmVfX21vZGFsLWJvZHktXCIuY29uY2F0KGFyaWFDb250cm9sc1N1ZmZpeCksIHJlZjogY29udGVudFJlZiwgcm9sZTogXCJkaWFsb2dcIiwgdGFiSW5kZXg6IC0xIH0sIGNoaWxkcmVuKSk7XG59O1xuXG52YXIgTW9kYWxPdmVybGF5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fbW9kYWwtb3ZlcmxheVwiIH0sIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydHMuVG9nZ2xlU3RhdHVzID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChUb2dnbGVTdGF0dXMpIHtcbiAgICBUb2dnbGVTdGF0dXNbXCJDbG9zZVwiXSA9IFwiQ2xvc2VcIjtcbiAgICBUb2dnbGVTdGF0dXNbXCJPcGVuXCJdID0gXCJPcGVuXCI7XG4gICAgVG9nZ2xlU3RhdHVzW1wiVG9nZ2xlXCJdID0gXCJUb2dnbGVcIjtcbn0pKGV4cG9ydHMuVG9nZ2xlU3RhdHVzIHx8IChleHBvcnRzLlRvZ2dsZVN0YXR1cyA9IHt9KSk7XG5cbnZhciB1c2VUb2dnbGUgPSBmdW5jdGlvbiAoaXNPcGVuZWQpIHtcbiAgICB2YXIgX2EgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGlzT3BlbmVkKSwgb3BlbmVkID0gX2FbMF0sIHNldE9wZW5lZCA9IF9hWzFdO1xuICAgIHZhciB0b2dnbGUgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9nZ2xlU3RhdHVzLkNsb3NlOlxuICAgICAgICAgICAgICAgIHNldE9wZW5lZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9nZ2xlU3RhdHVzLk9wZW46XG4gICAgICAgICAgICAgICAgc2V0T3BlbmVkKHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRvZ2dsZVN0YXR1cy5Ub2dnbGU6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNldE9wZW5lZChmdW5jdGlvbiAoaXNPcGVuZWQpIHsgcmV0dXJuICFpc09wZW5lZDsgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IG9wZW5lZDogb3BlbmVkLCB0b2dnbGU6IHRvZ2dsZSB9O1xufTtcblxudmFyIFBvcnRhbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjb250ZW50ID0gX2EuY29udGVudCwgX2IgPSBfYS5pc09wZW5lZCwgaXNPcGVuZWQgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgIHZhciBfYyA9IHVzZVRvZ2dsZShpc09wZW5lZCksIG9wZW5lZCA9IF9jLm9wZW5lZCwgdG9nZ2xlID0gX2MudG9nZ2xlO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIHRhcmdldCAmJiB0YXJnZXQodG9nZ2xlLCBvcGVuZWQpLFxuICAgICAgICBvcGVuZWQgJiYgY29udGVudCh0b2dnbGUpKSk7XG59O1xuXG52YXIgTW9kYWwgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYXJpYUNvbnRyb2xzU3VmZml4ID0gX2EuYXJpYUNvbnRyb2xzU3VmZml4LCBjbG9zZU9uQ2xpY2tPdXRzaWRlID0gX2EuY2xvc2VPbkNsaWNrT3V0c2lkZSwgY2xvc2VPbkVzY2FwZSA9IF9hLmNsb3NlT25Fc2NhcGUsIGNvbnRlbnQgPSBfYS5jb250ZW50LCBfYiA9IF9hLmlzT3BlbmVkLCBpc09wZW5lZCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgdmFyIGNvbnRyb2xzU3VmZml4ID0gYXJpYUNvbnRyb2xzU3VmZml4IHx8IFwiXCIuY29uY2F0KHVuaXF1ZUlkKCkpO1xuICAgIHZhciByZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAodG9nZ2xlLCBvcGVuZWQpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtZXhwYW5kZWRcIjogb3BlbmVkID8gJ3RydWUnIDogJ2ZhbHNlJywgXCJhcmlhLWhhc3BvcHVwXCI6IFwiZGlhbG9nXCIsIFwiYXJpYS1jb250cm9sc1wiOiBcInJwdi1jb3JlX19tb2RhbC1ib2R5LVwiLmNvbmNhdChjb250cm9sc1N1ZmZpeCkgfSwgdGFyZ2V0KHRvZ2dsZSwgb3BlbmVkKSkpOyB9O1xuICAgIHZhciByZW5kZXJDb250ZW50ID0gZnVuY3Rpb24gKHRvZ2dsZSkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChNb2RhbE92ZXJsYXksIG51bGwsXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChNb2RhbEJvZHksIHsgYXJpYUNvbnRyb2xzU3VmZml4OiBjb250cm9sc1N1ZmZpeCwgY2xvc2VPbkNsaWNrT3V0c2lkZTogY2xvc2VPbkNsaWNrT3V0c2lkZSwgY2xvc2VPbkVzY2FwZTogY2xvc2VPbkVzY2FwZSwgb25Ub2dnbGU6IHRvZ2dsZSB9LCBjb250ZW50KHRvZ2dsZSkpKSk7IH07XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3J0YWwsIHsgdGFyZ2V0OiB0YXJnZXQgPyByZW5kZXJUYXJnZXQgOiBudWxsLCBjb250ZW50OiByZW5kZXJDb250ZW50LCBpc09wZW5lZDogaXNPcGVuZWQgfSk7XG59O1xuXG5leHBvcnRzLlBvc2l0aW9uID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xuICAgIFBvc2l0aW9uW1wiVG9wTGVmdFwiXSA9IFwiVE9QX0xFRlRcIjtcbiAgICBQb3NpdGlvbltcIlRvcENlbnRlclwiXSA9IFwiVE9QX0NFTlRFUlwiO1xuICAgIFBvc2l0aW9uW1wiVG9wUmlnaHRcIl0gPSBcIlRPUF9SSUdIVFwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRUb3BcIl0gPSBcIlJJR0hUX1RPUFwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRDZW50ZXJcIl0gPSBcIlJJR0hUX0NFTlRFUlwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRCb3R0b21cIl0gPSBcIlJJR0hUX0JPVFRPTVwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tTGVmdFwiXSA9IFwiQk9UVE9NX0xFRlRcIjtcbiAgICBQb3NpdGlvbltcIkJvdHRvbUNlbnRlclwiXSA9IFwiQk9UVE9NX0NFTlRFUlwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tUmlnaHRcIl0gPSBcIkJPVFRPTV9SSUdIVFwiO1xuICAgIFBvc2l0aW9uW1wiTGVmdFRvcFwiXSA9IFwiTEVGVF9UT1BcIjtcbiAgICBQb3NpdGlvbltcIkxlZnRDZW50ZXJcIl0gPSBcIkxFRlRfQ0VOVEVSXCI7XG4gICAgUG9zaXRpb25bXCJMZWZ0Qm90dG9tXCJdID0gXCJMRUZUX0JPVFRPTVwiO1xufSkoZXhwb3J0cy5Qb3NpdGlvbiB8fCAoZXhwb3J0cy5Qb3NpdGlvbiA9IHt9KSk7XG5cbnZhciBjYWxjdWxhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChjb250ZW50LCB0YXJnZXQsIHBvc2l0aW9uLCBvZmZzZXQpIHtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBoZWlnaHQgPSBjb250ZW50UmVjdC5oZWlnaHQsIHdpZHRoID0gY29udGVudFJlY3Qud2lkdGg7XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLlRvcExlZnQ6XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCAtIGhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLlRvcENlbnRlcjpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLyAyIC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5Ub3BSaWdodDpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUG9zaXRpb24uUmlnaHRUb3A6XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcDtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5SaWdodENlbnRlcjpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5SaWdodEJvdHRvbTpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUG9zaXRpb24uQm90dG9tTGVmdDpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5Cb3R0b21DZW50ZXI6XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLyAyIC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5Cb3R0b21SaWdodDpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAtIHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5MZWZ0VG9wOlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3A7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0IC0gd2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLkxlZnRDZW50ZXI6XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0IC8gMiAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0IC0gd2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLkxlZnRCb3R0b206XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCAtIHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQgKyAob2Zmc2V0LmxlZnQgfHwgMCksXG4gICAgICAgIHRvcDogdG9wICsgKG9mZnNldC50b3AgfHwgMCksXG4gICAgfTtcbn07XG5cbnZhciB1c2VQb3NpdGlvbiA9IGZ1bmN0aW9uIChjb250ZW50UmVmLCB0YXJnZXRSZWYsIGFuY2hvclJlZiwgcG9zaXRpb24sIG9mZnNldCkge1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFyZ2V0RWxlID0gdGFyZ2V0UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBjb250ZW50RWxlID0gY29udGVudFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgYW5jaG9yRWxlID0gYW5jaG9yUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGVudEVsZSB8fCAhdGFyZ2V0RWxlIHx8ICFhbmNob3JFbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5jaG9yUmVjdCA9IGFuY2hvckVsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIF9hID0gY2FsY3VsYXRlUG9zaXRpb24oY29udGVudEVsZSwgdGFyZ2V0RWxlLCBwb3NpdGlvbiwgb2Zmc2V0KSwgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdDtcbiAgICAgICAgY29udGVudEVsZS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AgLSBhbmNob3JSZWN0LnRvcCwgXCJweFwiKTtcbiAgICAgICAgY29udGVudEVsZS5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQobGVmdCAtIGFuY2hvclJlY3QubGVmdCwgXCJweFwiKTtcbiAgICB9LCBbXSk7XG59O1xuXG52YXIgQXJyb3cgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIGN1c3RvbUNsYXNzTmFtZSA9IF9hLmN1c3RvbUNsYXNzTmFtZSwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbjtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcygoX2IgPSB7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tdGwnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5Ub3BMZWZ0LFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLXRjJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uVG9wQ2VudGVyLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLXRyJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uVG9wUmlnaHQsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tcnQnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5SaWdodFRvcCxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93LS1yYyc6IHBvc2l0aW9uID09PSBleHBvcnRzLlBvc2l0aW9uLlJpZ2h0Q2VudGVyLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLXJiJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uUmlnaHRCb3R0b20sXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tYmwnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5Cb3R0b21MZWZ0LFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLWJjJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uQm90dG9tQ2VudGVyLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLWJyJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uQm90dG9tUmlnaHQsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tbHQnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5MZWZ0VG9wLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLWxjJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uTGVmdENlbnRlcixcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93LS1sYic6IHBvc2l0aW9uID09PSBleHBvcnRzLlBvc2l0aW9uLkxlZnRCb3R0b21cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYltcIlwiLmNvbmNhdChjdXN0b21DbGFzc05hbWUpXSA9IGN1c3RvbUNsYXNzTmFtZSAhPT0gJycsXG4gICAgICAgICAgICBfYikpIH0pKTtcbn07XG5cbnZhciBQb3BvdmVyQm9keSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhcmlhQ29udHJvbHNTdWZmaXggPSBfYS5hcmlhQ29udHJvbHNTdWZmaXgsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsb3NlT25DbGlja091dHNpZGUgPSBfYS5jbG9zZU9uQ2xpY2tPdXRzaWRlLCBvZmZzZXQgPSBfYS5vZmZzZXQsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIHRhcmdldFJlZiA9IF9hLnRhcmdldFJlZiwgb25DbG9zZSA9IF9hLm9uQ2xvc2U7XG4gICAgdmFyIGNvbnRlbnRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBpbm5lclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGFuY2hvclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB1c2VDbGlja091dHNpZGUoY2xvc2VPbkNsaWNrT3V0c2lkZSwgY29udGVudFJlZiwgb25DbG9zZSk7XG4gICAgdXNlUG9zaXRpb24oY29udGVudFJlZiwgdGFyZ2V0UmVmLCBhbmNob3JSZWYsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJDb250ZW50RWxlID0gaW5uZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFpbm5lckNvbnRlbnRFbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgKiAwLjc1O1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50RWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudEVsZS5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIGlubmVyQ29udGVudEVsZS5zdHlsZS5tYXhIZWlnaHQgPSBcIlwiLmNvbmNhdChtYXhIZWlnaHQsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIGlubmVySWQgPSBcInJwdi1jb3JlX19wb3BvdmVyLWJvZHktaW5uZXItXCIuY29uY2F0KGFyaWFDb250cm9sc1N1ZmZpeCk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBhbmNob3JSZWYsIHN0eWxlOiB7IGxlZnQ6IDAsIHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IDAgfSB9KSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGlubmVySWQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19wb3BvdmVyLWJvZHknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fcG9wb3Zlci1ib2R5LS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgIH0pLCBpZDogXCJycHYtY29yZV9fcG9wb3Zlci1ib2R5LVwiLmNvbmNhdChhcmlhQ29udHJvbHNTdWZmaXgpLCByZWY6IGNvbnRlbnRSZWYsIHJvbGU6IFwiZGlhbG9nXCIsIHRhYkluZGV4OiAtMSB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFycm93LCB7IGN1c3RvbUNsYXNzTmFtZTogXCJycHYtY29yZV9fcG9wb3Zlci1ib2R5LWFycm93XCIsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGlkOiBpbm5lcklkLCByZWY6IGlubmVyUmVmIH0sIGNoaWxkcmVuKSkpKTtcbn07XG5cbnZhciBQb3BvdmVyT3ZlcmxheSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjbG9zZU9uRXNjYXBlID0gX2EuY2xvc2VPbkVzY2FwZSwgb25DbG9zZSA9IF9hLm9uQ2xvc2U7XG4gICAgdmFyIGNvbnRhaW5lclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdXNlRXNjYXBlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50ICYmIGNsb3NlT25Fc2NhcGUpIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX3BvcG92ZXItb3ZlcmxheVwiLCByZWY6IGNvbnRhaW5lclJlZiB9KTtcbn07XG5cbnZhciBQb3BvdmVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuYXJpYUhhc1BvcHVwLCBhcmlhSGFzUG9wdXAgPSBfYiA9PT0gdm9pZCAwID8gJ2RpYWxvZycgOiBfYiwgYXJpYUNvbnRyb2xzU3VmZml4ID0gX2EuYXJpYUNvbnRyb2xzU3VmZml4LCBjbG9zZU9uQ2xpY2tPdXRzaWRlID0gX2EuY2xvc2VPbkNsaWNrT3V0c2lkZSwgY2xvc2VPbkVzY2FwZSA9IF9hLmNsb3NlT25Fc2NhcGUsIGNvbnRlbnQgPSBfYS5jb250ZW50LCBfYyA9IF9hLmxvY2tTY3JvbGwsIGxvY2tTY3JvbGwgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBvZmZzZXQgPSBfYS5vZmZzZXQsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICB2YXIgX2QgPSB1c2VUb2dnbGUoZmFsc2UpLCBvcGVuZWQgPSBfZC5vcGVuZWQsIHRvZ2dsZSA9IF9kLnRvZ2dsZTtcbiAgICB2YXIgdGFyZ2V0UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgY29udHJvbHNTdWZmaXggPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJpYUNvbnRyb2xzU3VmZml4IHx8IFwiXCIuY29uY2F0KHVuaXF1ZUlkKCkpOyB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRhcmdldFJlZiwgXCJhcmlhLWV4cGFuZGVkXCI6IG9wZW5lZCA/ICd0cnVlJyA6ICdmYWxzZScsIFwiYXJpYS1oYXNwb3B1cFwiOiBhcmlhSGFzUG9wdXAsIFwiYXJpYS1jb250cm9sc1wiOiBcInJwdi1jb3JlX19wb3B2ZXItYm9keS1cIi5jb25jYXQoY29udHJvbHNTdWZmaXgpIH0sXG4gICAgICAgIHRhcmdldCh0b2dnbGUsIG9wZW5lZCksXG4gICAgICAgIG9wZW5lZCAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBsb2NrU2Nyb2xsICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3BvdmVyT3ZlcmxheSwgeyBjbG9zZU9uRXNjYXBlOiBjbG9zZU9uRXNjYXBlLCBvbkNsb3NlOiB0b2dnbGUgfSksXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUG9wb3ZlckJvZHksIHsgYXJpYUNvbnRyb2xzU3VmZml4OiBjb250cm9sc1N1ZmZpeCwgY2xvc2VPbkNsaWNrT3V0c2lkZTogY2xvc2VPbkNsaWNrT3V0c2lkZSwgb2Zmc2V0OiBvZmZzZXQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgdGFyZ2V0UmVmOiB0YXJnZXRSZWYsIG9uQ2xvc2U6IHRvZ2dsZSB9LCBjb250ZW50KHRvZ2dsZSkpKSkpKTtcbn07XG5cbnZhciBUb29sdGlwQm9keSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhcmlhQ29udHJvbHNTdWZmaXggPSBfYS5hcmlhQ29udHJvbHNTdWZmaXgsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNvbnRlbnRSZWYgPSBfYS5jb250ZW50UmVmLCBvZmZzZXQgPSBfYS5vZmZzZXQsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIHRhcmdldFJlZiA9IF9hLnRhcmdldFJlZjtcbiAgICB2YXIgYW5jaG9yUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHVzZVBvc2l0aW9uKGNvbnRlbnRSZWYsIHRhcmdldFJlZiwgYW5jaG9yUmVmLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGFuY2hvclJlZiwgc3R5bGU6IHsgbGVmdDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogMCB9IH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdycHYtY29yZV9fdG9vbHRpcC1ib2R5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX3Rvb2x0aXAtYm9keS0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICB9KSwgaWQ6IFwicnB2LWNvcmVfX3Rvb2x0aXAtYm9keS1cIi5jb25jYXQoYXJpYUNvbnRyb2xzU3VmZml4KSwgcmVmOiBjb250ZW50UmVmLCByb2xlOiBcInRvb2x0aXBcIiB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFycm93LCB7IGN1c3RvbUNsYXNzTmFtZTogXCJycHYtY29yZV9fdG9vbHRpcC1ib2R5LWFycm93XCIsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fdG9vbHRpcC1ib2R5LWNvbnRlbnRcIiB9LCBjaGlsZHJlbikpKSk7XG59O1xuXG52YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhcmlhQ29udHJvbHNTdWZmaXggPSBfYS5hcmlhQ29udHJvbHNTdWZmaXgsIGNvbnRlbnQgPSBfYS5jb250ZW50LCBvZmZzZXQgPSBfYS5vZmZzZXQsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICB2YXIgX2IgPSB1c2VUb2dnbGUoZmFsc2UpLCBvcGVuZWQgPSBfYi5vcGVuZWQsIHRvZ2dsZSA9IF9iLnRvZ2dsZTtcbiAgICB2YXIgdGFyZ2V0UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgY29udGVudFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGNvbnRyb2xzU3VmZml4ID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyaWFDb250cm9sc1N1ZmZpeCB8fCBcIlwiLmNvbmNhdCh1bmlxdWVJZCgpKTsgfSwgW10pO1xuICAgIHVzZUVzY2FwZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YXJnZXRSZWYuY3VycmVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRhcmdldFJlZi5jdXJyZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRvZ2dsZShleHBvcnRzLlRvZ2dsZVN0YXR1cy5PcGVuKTtcbiAgICB9O1xuICAgIHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9nZ2xlKGV4cG9ydHMuVG9nZ2xlU3RhdHVzLkNsb3NlKTtcbiAgICB9O1xuICAgIHZhciBvbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2hvdWxkSGlkZVRvb2x0aXAgPSBlLnJlbGF0ZWRUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5wYXJlbnRFbGVtZW50LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGlmIChzaG91bGRIaWRlVG9vbHRpcCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSZWYuY3VycmVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0YXJnZXRSZWYsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcInJwdi1jb3JlX190b29sdGlwLWJvZHktXCIuY29uY2F0KGNvbnRyb2xzU3VmZml4KSwgb25CbHVyOiBvbkJsdXIsIG9uRm9jdXM6IG9wZW4sIG9uTW91c2VFbnRlcjogb3Blbiwgb25Nb3VzZUxlYXZlOiBjbG9zZSB9LCB0YXJnZXQpLFxuICAgICAgICBvcGVuZWQgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChUb29sdGlwQm9keSwgeyBhcmlhQ29udHJvbHNTdWZmaXg6IGNvbnRyb2xzU3VmZml4LCBjb250ZW50UmVmOiBjb250ZW50UmVmLCBvZmZzZXQ6IG9mZnNldCwgcG9zaXRpb246IHBvc2l0aW9uLCB0YXJnZXRSZWY6IHRhcmdldFJlZiB9LCBjb250ZW50KCkpKSkpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gICAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlIHx8IHt9O1xuICAgIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgKF9hID0ge30sIF9hW2tleV0gPSBkYXRhLCBfYSkpO1xuICAgICAgICAobGlzdGVuZXJzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIoc3RhdGVba2V5XSk7IH0pO1xuICAgIH07XG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoa2V5LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNba2V5XSA9IChsaXN0ZW5lcnNba2V5XSB8fCBbXSkuY29uY2F0KGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGtleSwgaGFuZGxlcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0gPSAobGlzdGVuZXJzW2tleV0gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZiAhPT0gaGFuZGxlcjsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGtleSwgZGF0YSkge1xuICAgICAgICAgICAgdXBkYXRlKGtleSwgZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUN1cnJlbnRWYWx1ZTogZnVuY3Rpb24gKGtleSwgdXBkYXRlcikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKGtleSwgdXBkYXRlcihjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KGtleSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZXhwb3J0cy5GdWxsU2NyZWVuTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoRnVsbFNjcmVlbk1vZGUpIHtcbiAgICBGdWxsU2NyZWVuTW9kZVtcIk5vcm1hbFwiXSA9IFwiTm9ybWFsXCI7XG4gICAgRnVsbFNjcmVlbk1vZGVbXCJFbnRlcmluZ1wiXSA9IFwiRW50ZXJpbmdcIjtcbiAgICBGdWxsU2NyZWVuTW9kZVtcIkVudGVyZWRcIl0gPSBcIkVudGVyZWRcIjtcbiAgICBGdWxsU2NyZWVuTW9kZVtcIkVudGVyZWRDb21wbGV0ZWx5XCJdID0gXCJFbnRlcmVkQ29tcGxldGVseVwiO1xuICAgIEZ1bGxTY3JlZW5Nb2RlW1wiRXhpdHRpbmdcIl0gPSBcIkV4aXR0aW5nXCI7XG4gICAgRnVsbFNjcmVlbk1vZGVbXCJFeGl0ZWRcIl0gPSBcIkV4aXRlZFwiO1xufSkoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZSB8fCAoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZSA9IHt9KSk7XG5cbmV4cG9ydHMuTGF5ZXJSZW5kZXJTdGF0dXMgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKExheWVyUmVuZGVyU3RhdHVzKSB7XG4gICAgTGF5ZXJSZW5kZXJTdGF0dXNbTGF5ZXJSZW5kZXJTdGF0dXNbXCJQcmVSZW5kZXJcIl0gPSAwXSA9IFwiUHJlUmVuZGVyXCI7XG4gICAgTGF5ZXJSZW5kZXJTdGF0dXNbTGF5ZXJSZW5kZXJTdGF0dXNbXCJEaWRSZW5kZXJcIl0gPSAxXSA9IFwiRGlkUmVuZGVyXCI7XG59KShleHBvcnRzLkxheWVyUmVuZGVyU3RhdHVzIHx8IChleHBvcnRzLkxheWVyUmVuZGVyU3RhdHVzID0ge30pKTtcblxuZXhwb3J0cy5QYWdlTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoUGFnZU1vZGUpIHtcbiAgICBQYWdlTW9kZVtcIkF0dGFjaG1lbnRzXCJdID0gXCJVc2VBdHRhY2htZW50c1wiO1xuICAgIFBhZ2VNb2RlW1wiQm9va21hcmtzXCJdID0gXCJVc2VPdXRsaW5lc1wiO1xuICAgIFBhZ2VNb2RlW1wiQ29udGVudEdyb3VwXCJdID0gXCJVc2VPQ1wiO1xuICAgIFBhZ2VNb2RlW1wiRGVmYXVsdFwiXSA9IFwiVXNlck5vbmVcIjtcbiAgICBQYWdlTW9kZVtcIkZ1bGxTY3JlZW5cIl0gPSBcIkZ1bGxTY3JlZW5cIjtcbiAgICBQYWdlTW9kZVtcIlRodW1ibmFpbHNcIl0gPSBcIlVzZVRodW1ic1wiO1xufSkoZXhwb3J0cy5QYWdlTW9kZSB8fCAoZXhwb3J0cy5QYWdlTW9kZSA9IHt9KSk7XG5cbmV4cG9ydHMuUGFzc3dvcmRTdGF0dXMgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFBhc3N3b3JkU3RhdHVzKSB7XG4gICAgUGFzc3dvcmRTdGF0dXNbXCJSZXF1aXJlZFBhc3N3b3JkXCJdID0gXCJSZXF1aXJlZFBhc3N3b3JkXCI7XG4gICAgUGFzc3dvcmRTdGF0dXNbXCJXcm9uZ1Bhc3N3b3JkXCJdID0gXCJXcm9uZ1Bhc3N3b3JkXCI7XG59KShleHBvcnRzLlBhc3N3b3JkU3RhdHVzIHx8IChleHBvcnRzLlBhc3N3b3JkU3RhdHVzID0ge30pKTtcblxuZXhwb3J0cy5Sb3RhdGVEaXJlY3Rpb24gPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFJvdGF0ZURpcmVjdGlvbikge1xuICAgIFJvdGF0ZURpcmVjdGlvbltcIkJhY2t3YXJkXCJdID0gXCJCYWNrd2FyZFwiO1xuICAgIFJvdGF0ZURpcmVjdGlvbltcIkZvcndhcmRcIl0gPSBcIkZvcndhcmRcIjtcbn0pKGV4cG9ydHMuUm90YXRlRGlyZWN0aW9uIHx8IChleHBvcnRzLlJvdGF0ZURpcmVjdGlvbiA9IHt9KSk7XG5cbmV4cG9ydHMuU2Nyb2xsTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoU2Nyb2xsTW9kZSkge1xuICAgIFNjcm9sbE1vZGVbXCJQYWdlXCJdID0gXCJQYWdlXCI7XG4gICAgU2Nyb2xsTW9kZVtcIkhvcml6b250YWxcIl0gPSBcIkhvcml6b250YWxcIjtcbiAgICBTY3JvbGxNb2RlW1wiVmVydGljYWxcIl0gPSBcIlZlcnRpY2FsXCI7XG4gICAgU2Nyb2xsTW9kZVtcIldyYXBwZWRcIl0gPSBcIldyYXBwZWRcIjtcbn0pKGV4cG9ydHMuU2Nyb2xsTW9kZSB8fCAoZXhwb3J0cy5TY3JvbGxNb2RlID0ge30pKTtcblxuZXhwb3J0cy5TcGVjaWFsWm9vbUxldmVsID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChTcGVjaWFsWm9vbUxldmVsKSB7XG4gICAgU3BlY2lhbFpvb21MZXZlbFtcIkFjdHVhbFNpemVcIl0gPSBcIkFjdHVhbFNpemVcIjtcbiAgICBTcGVjaWFsWm9vbUxldmVsW1wiUGFnZUZpdFwiXSA9IFwiUGFnZUZpdFwiO1xuICAgIFNwZWNpYWxab29tTGV2ZWxbXCJQYWdlV2lkdGhcIl0gPSBcIlBhZ2VXaWR0aFwiO1xufSkoZXhwb3J0cy5TcGVjaWFsWm9vbUxldmVsIHx8IChleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwgPSB7fSkpO1xuXG5leHBvcnRzLlZpZXdNb2RlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChWaWV3TW9kZSkge1xuICAgIFZpZXdNb2RlW1wiRHVhbFBhZ2VcIl0gPSBcIkR1YWxQYWdlXCI7XG4gICAgVmlld01vZGVbXCJEdWFsUGFnZVdpdGhDb3ZlclwiXSA9IFwiRHVhbFBhZ2VXaXRoQ292ZXJcIjtcbiAgICBWaWV3TW9kZVtcIlNpbmdsZVBhZ2VcIl0gPSBcIlNpbmdsZVBhZ2VcIjtcbn0pKGV4cG9ydHMuVmlld01vZGUgfHwgKGV4cG9ydHMuVmlld01vZGUgPSB7fSkpO1xuXG52YXIgY2h1bmsgPSBmdW5jdGlvbiAoYXJyLCBzaXplKSB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZSwgaSkgeyByZXR1cm4gKGkgJSBzaXplID8gYWNjW2FjYy5sZW5ndGggLSAxXS5wdXNoKGUpIDogYWNjLnB1c2goW2VdKSwgYWNjKTsgfSwgW10pO1xufTtcblxudmFyIGlzTWFjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gLyhNYWN8aVBob25lfGlQb2R8aVBhZCkvaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZSk7IH07XG5cbnZhciBub3JtYWxpemVEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIGRlc3RBcnJheSkge1xuICAgIHN3aXRjaCAoZGVzdEFycmF5WzFdLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnWFlaJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm90dG9tT2Zmc2V0OiBmdW5jdGlvbiAoXywgdmlld3BvcnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3RBcnJheVszXSA9PT0gbnVsbCA/IHZpZXdwb3J0SGVpZ2h0IDogZGVzdEFycmF5WzNdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGVmdE9mZnNldDogZnVuY3Rpb24gKF8sIF9fKSB7IHJldHVybiAoZGVzdEFycmF5WzJdID09PSBudWxsID8gMCA6IGRlc3RBcnJheVsyXSk7IH0sXG4gICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgc2NhbGVUbzogZGVzdEFycmF5WzRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnRml0JzpcbiAgICAgICAgY2FzZSAnRml0Qic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJvdHRvbU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgIHNjYWxlVG86IGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlRml0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnRml0SCc6XG4gICAgICAgIGNhc2UgJ0ZpdEJIJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm90dG9tT2Zmc2V0OiBkZXN0QXJyYXlbMl0sXG4gICAgICAgICAgICAgICAgbGVmdE9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICBzY2FsZVRvOiBleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwuUGFnZVdpZHRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm90dG9tT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgc2NhbGVUbzogMSxcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcbnZhciBwYWdlT3V0bGluZXNNYXAgPSBuZXcgTWFwKCk7XG52YXIgcGFnZXNNYXAgPSBuZXcgTWFwKCk7XG52YXIgZ2VuZXJhdGVSZWZLZXkgPSBmdW5jdGlvbiAoZG9jLCBvdXRsaW5lKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGRvYy5sb2FkaW5nVGFzay5kb2NJZCwgXCJfX19cIikuY29uY2F0KG91dGxpbmUubnVtLCBcIlJcIikuY29uY2F0KG91dGxpbmUuZ2VuID09PSAwID8gJycgOiBvdXRsaW5lLmdlbik7XG59O1xudmFyIGdldFBhZ2VJbmRleCA9IGZ1bmN0aW9uIChkb2MsIG91dGxpbmUpIHtcbiAgICB2YXIga2V5ID0gZ2VuZXJhdGVSZWZLZXkoZG9jLCBvdXRsaW5lKTtcbiAgICByZXR1cm4gcGFnZU91dGxpbmVzTWFwLmhhcyhrZXkpID8gcGFnZU91dGxpbmVzTWFwLmdldChrZXkpIDogbnVsbDtcbn07XG52YXIgY2FjaGVPdXRsaW5lUmVmID0gZnVuY3Rpb24gKGRvYywgb3V0bGluZSwgcGFnZUluZGV4KSB7XG4gICAgcGFnZU91dGxpbmVzTWFwLnNldChnZW5lcmF0ZVJlZktleShkb2MsIG91dGxpbmUpLCBwYWdlSW5kZXgpO1xufTtcbnZhciBjbGVhclBhZ2VzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGFnZU91dGxpbmVzTWFwLmNsZWFyKCk7XG4gICAgcGFnZXNNYXAuY2xlYXIoKTtcbn07XG52YXIgZ2V0UGFnZSA9IGZ1bmN0aW9uIChkb2MsIHBhZ2VJbmRleCkge1xuICAgIGlmICghZG9jKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnVGhlIGRvY3VtZW50IGlzIG5vdCBsb2FkZWQgeWV0Jyk7XG4gICAgfVxuICAgIHZhciBwYWdlS2V5ID0gXCJcIi5jb25jYXQoZG9jLmxvYWRpbmdUYXNrLmRvY0lkLCBcIl9fX1wiKS5jb25jYXQocGFnZUluZGV4KTtcbiAgICB2YXIgcGFnZSA9IHBhZ2VzTWFwLmdldChwYWdlS2V5KTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIF8pIHtcbiAgICAgICAgZG9jLmdldFBhZ2UocGFnZUluZGV4ICsgMSkudGhlbihmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgcGFnZXNNYXAuc2V0KHBhZ2VLZXksIHBhZ2UpO1xuICAgICAgICAgICAgaWYgKHBhZ2UucmVmKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVPdXRsaW5lUmVmKGRvYywgcGFnZS5yZWYsIHBhZ2VJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHBhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG52YXIgZ2V0RGVzdGluYXRpb24gPSBmdW5jdGlvbiAoZG9jLCBkZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkb2MuZ2V0RGVzdGluYXRpb24oZGVzdCkudGhlbihmdW5jdGlvbiAoZGVzdEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdEFycmF5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRlc3RBcnJheSkge1xuICAgICAgICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgZGVzdEFycmF5WzBdICYmIGRlc3RBcnJheVswXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRsaW5lUmVmXzEgPSBkZXN0QXJyYXlbMF07XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VJbmRleCA9IGdldFBhZ2VJbmRleChkb2MsIG91dGxpbmVSZWZfMSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkb2MuZ2V0UGFnZUluZGV4KG91dGxpbmVSZWZfMSkudGhlbihmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZU91dGxpbmVSZWYoZG9jLCBvdXRsaW5lUmVmXzEsIHBhZ2VJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXREZXN0aW5hdGlvbihkb2MsIGRlc3QpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzKHJlc3VsdCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyhub3JtYWxpemVEZXN0aW5hdGlvbihwYWdlSW5kZXgsIGRlc3RBcnJheSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBub3JtYWxpemVEZXN0aW5hdGlvbihkZXN0QXJyYXlbMF0sIGRlc3RBcnJheSk7XG4gICAgICAgICAgICAgICAgcmVzKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxudmFyIHVzZVJ1bk9uY2UgPSBmdW5jdGlvbiAoY2IsIGNvbmRpdGlvbikge1xuICAgIHZhciBpc0NhbGxlZFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGZhbHNlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiAmJiAhaXNDYWxsZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaXNDYWxsZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfSwgW2NiLCBjb25kaXRpb25dKTtcbn07XG5cbnZhciB1c2VUcmFja1Jlc2l6ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB0YXJnZXRSZWYgPSBfYS50YXJnZXRSZWYsIG9uUmVzaXplID0gX2Eub25SZXNpemU7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbyA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIG9uUmVzaXplKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0YXJnZXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpby5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpby51bm9ic2VydmUoY29udGFpbmVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59O1xuXG52YXIgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZTtcbihmdW5jdGlvbiAoQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSkge1xuICAgIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGVbQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtcIlNvbGlkXCJdID0gMV0gPSBcIlNvbGlkXCI7XG4gICAgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW1wiRGFzaGVkXCJdID0gMl0gPSBcIkRhc2hlZFwiO1xuICAgIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGVbQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtcIkJldmVsZWRcIl0gPSAzXSA9IFwiQmV2ZWxlZFwiO1xuICAgIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGVbQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtcIkluc2V0XCJdID0gNF0gPSBcIkluc2V0XCI7XG4gICAgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW1wiVW5kZXJsaW5lXCJdID0gNV0gPSBcIlVuZGVybGluZVwiO1xufSkoQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSB8fCAoQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IHt9KSk7XG5cbnZhciBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKCdeRDonICtcbiAgICAnKFxcXFxkezR9KScgK1xuICAgICcoXFxcXGR7Mn0pPycgK1xuICAgICcoXFxcXGR7Mn0pPycgK1xuICAgICcoXFxcXGR7Mn0pPycgK1xuICAgICcoXFxcXGR7Mn0pPycgK1xuICAgICcoXFxcXGR7Mn0pPycgK1xuICAgICcoW1p8K3wtXSk/JyArXG4gICAgJyhcXFxcZHsyfSk/JyArXG4gICAgXCInP1wiICtcbiAgICAnKFxcXFxkezJ9KT8nICtcbiAgICBcIic/XCIpO1xudmFyIHBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgcmV0dXJuIHBhcnNlZCA+PSBtaW4gJiYgcGFyc2VkIDw9IG1heCA/IHBhcnNlZCA6IGRlZmF1bHRWYWx1ZTtcbn07XG52YXIgY29udmVydERhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGRhdGVSZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIHZhciBtb250aCA9IHBhcnNlKG1hdGNoZXNbMl0sIDEsIDEyLCAxKSAtIDE7XG4gICAgdmFyIGRheSA9IHBhcnNlKG1hdGNoZXNbM10sIDEsIDMxLCAxKTtcbiAgICB2YXIgaG91ciA9IHBhcnNlKG1hdGNoZXNbNF0sIDAsIDIzLCAwKTtcbiAgICB2YXIgbWludXRlID0gcGFyc2UobWF0Y2hlc1s1XSwgMCwgNTksIDApO1xuICAgIHZhciBzZWNvbmQgPSBwYXJzZShtYXRjaGVzWzZdLCAwLCA1OSwgMCk7XG4gICAgdmFyIHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgJ1onO1xuICAgIHZhciBvZmZzZXRIb3VyID0gcGFyc2UobWF0Y2hlc1s4XSwgMCwgMjMsIDApO1xuICAgIHZhciBvZmZzZXRNaW51dGUgPSBwYXJzZShtYXRjaGVzWzldLCAwLCA1OSwgMCk7XG4gICAgc3dpdGNoICh1bml2ZXJzYWxUaW1lUmVsYXRpb24pIHtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICAgICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbn07XG5cbnZhciBnZXRDb250ZW50cyA9IGZ1bmN0aW9uIChhbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuIGFubm90YXRpb24uY29udGVudHNPYmogPyBhbm5vdGF0aW9uLmNvbnRlbnRzT2JqLnN0ciA6IGFubm90YXRpb24uY29udGVudHMgfHwgJyc7XG59O1xuXG52YXIgZ2V0VGl0bGUgPSBmdW5jdGlvbiAoYW5ub3RhdGlvbikge1xuICAgIHJldHVybiBhbm5vdGF0aW9uLnRpdGxlT2JqID8gYW5ub3RhdGlvbi50aXRsZU9iai5zdHIgOiBhbm5vdGF0aW9uLnRpdGxlIHx8ICcnO1xufTtcblxudmFyIFBvcHVwV3JhcHBlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbjtcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBjb250YWluZXJSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBkYXRlU3RyID0gJyc7XG4gICAgaWYgKGFubm90YXRpb24ubW9kaWZpY2F0aW9uRGF0ZSkge1xuICAgICAgICB2YXIgZGF0ZSA9IGNvbnZlcnREYXRlKGFubm90YXRpb24ubW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgICAgIGRhdGVTdHIgPSBkYXRlID8gXCJcIi5jb25jYXQoZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKSwgXCIsIFwiKS5jb25jYXQoZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoKSkgOiAnJztcbiAgICB9XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyRWxlID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyRWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb25FbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYW5ub3RhdGlvbi1pZD1cXFwiXCIuY29uY2F0KGFubm90YXRpb24uaWQsIFwiXFxcIl1cIikpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25FbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlID0gYW5ub3RhdGlvbkVsZTtcbiAgICAgICAgZWxlLnN0eWxlLnpJbmRleCArPSAxO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWxlLnN0eWxlLnpJbmRleCA9IFwiXCIuY29uY2F0KHBhcnNlSW50KGVsZS5zdHlsZS56SW5kZXgsIDEwKSAtIDEpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyUmVmLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19hbm5vdGF0aW9uLXBvcHVwLXdyYXBwZXInOiB0cnVlLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19hbm5vdGF0aW9uLXBvcHVwLXdyYXBwZXItLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSwgc3R5bGU6IHtcbiAgICAgICAgICAgIHRvcDogYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZSA9PT0gZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5Qb3B1cCA/ICcnIDogJzEwMCUnLFxuICAgICAgICB9IH0sXG4gICAgICAgIHRpdGxlICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9fYW5ub3RhdGlvbi1wb3B1cC10aXRsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9fYW5ub3RhdGlvbi1wb3B1cC10aXRsZS0tbHRyJzogIWlzUnRsLFxuICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fubm90YXRpb24tcG9wdXAtdGl0bGUtLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgICAgIH0pIH0sIHRpdGxlKSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbi1wb3B1cC1kYXRlXCIgfSwgZGF0ZVN0cikpKSxcbiAgICAgICAgY29udGVudHMgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbi1wb3B1cC1jb250ZW50XCIgfSwgY29udGVudHMuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgeyBrZXk6IGluZGV4IH0sXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCkpKTsgfSkpKSkpO1xufTtcblxudmFyIFRvZ2dsZVBvcHVwQnk7XG4oZnVuY3Rpb24gKFRvZ2dsZVBvcHVwQnkpIHtcbiAgICBUb2dnbGVQb3B1cEJ5W1wiQ2xpY2tcIl0gPSBcIkNsaWNrXCI7XG4gICAgVG9nZ2xlUG9wdXBCeVtcIkhvdmVyXCJdID0gXCJIb3ZlclwiO1xufSkoVG9nZ2xlUG9wdXBCeSB8fCAoVG9nZ2xlUG9wdXBCeSA9IHt9KSk7XG52YXIgdXNlVG9nZ2xlUG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdXNlVG9nZ2xlKGZhbHNlKSwgb3BlbmVkID0gX2Eub3BlbmVkLCB0b2dnbGUgPSBfYS50b2dnbGU7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShUb2dnbGVQb3B1cEJ5LkhvdmVyKSwgdG9nZ2xlUG9wdXBCeSA9IF9iWzBdLCBzZXRUb29nbGVQb3B1cEJ5ID0gX2JbMV07XG4gICAgdmFyIHRvZ2dsZU9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodG9nZ2xlUG9wdXBCeSkge1xuICAgICAgICAgICAgY2FzZSBUb2dnbGVQb3B1cEJ5LkNsaWNrOlxuICAgICAgICAgICAgICAgIG9wZW5lZCAmJiBzZXRUb29nbGVQb3B1cEJ5KFRvZ2dsZVBvcHVwQnkuSG92ZXIpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZShleHBvcnRzLlRvZ2dsZVN0YXR1cy5Ub2dnbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUb2dnbGVQb3B1cEJ5LkhvdmVyOlxuICAgICAgICAgICAgICAgIHNldFRvb2dsZVBvcHVwQnkoVG9nZ2xlUG9wdXBCeS5DbGljayk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKGV4cG9ydHMuVG9nZ2xlU3RhdHVzLk9wZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb3Blbk9uSG92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRvZ2dsZVBvcHVwQnkgPT09IFRvZ2dsZVBvcHVwQnkuSG92ZXIgJiYgdG9nZ2xlKGV4cG9ydHMuVG9nZ2xlU3RhdHVzLk9wZW4pO1xuICAgIH07XG4gICAgdmFyIGNsb3NlT25Ib3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9nZ2xlUG9wdXBCeSA9PT0gVG9nZ2xlUG9wdXBCeS5Ib3ZlciAmJiB0b2dnbGUoZXhwb3J0cy5Ub2dnbGVTdGF0dXMuQ2xvc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbmVkOiBvcGVuZWQsXG4gICAgICAgIGNsb3NlT25Ib3ZlcjogY2xvc2VPbkhvdmVyLFxuICAgICAgICBvcGVuT25Ib3Zlcjogb3Blbk9uSG92ZXIsXG4gICAgICAgIHRvZ2dsZU9uQ2xpY2s6IHRvZ2dsZU9uQ2xpY2ssXG4gICAgfTtcbn07XG5cbnZhciBBbm5vdGF0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpZ25vcmVCb3JkZXIgPSBfYS5pZ25vcmVCb3JkZXIsIGhhc1BvcHVwID0gX2EuaGFzUG9wdXAsIGlzUmVuZGVyYWJsZSA9IF9hLmlzUmVuZGVyYWJsZSwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIHJlY3QgPSBhbm5vdGF0aW9uLnJlY3Q7XG4gICAgdmFyIF9iID0gdXNlVG9nZ2xlUG9wdXAoKSwgY2xvc2VPbkhvdmVyID0gX2IuY2xvc2VPbkhvdmVyLCBvcGVuZWQgPSBfYi5vcGVuZWQsIG9wZW5PbkhvdmVyID0gX2Iub3Blbk9uSG92ZXIsIHRvZ2dsZU9uQ2xpY2sgPSBfYi50b2dnbGVPbkNsaWNrO1xuICAgIHZhciBub3JtYWxpemVSZWN0ID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oclswXSwgclsyXSksXG4gICAgICAgIE1hdGgubWluKHJbMV0sIHJbM10pLFxuICAgICAgICBNYXRoLm1heChyWzBdLCByWzJdKSxcbiAgICAgICAgTWF0aC5tYXgoclsxXSwgclszXSksXG4gICAgXTsgfTtcbiAgICB2YXIgYm91bmQgPSBub3JtYWxpemVSZWN0KFtcbiAgICAgICAgcmVjdFswXSxcbiAgICAgICAgcGFnZS52aWV3WzNdICsgcGFnZS52aWV3WzFdIC0gcmVjdFsxXSxcbiAgICAgICAgcmVjdFsyXSxcbiAgICAgICAgcGFnZS52aWV3WzNdICsgcGFnZS52aWV3WzFdIC0gcmVjdFszXSxcbiAgICBdKTtcbiAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICcnLFxuICAgICAgICBib3JkZXJTdHlsZTogJycsXG4gICAgICAgIGJvcmRlcldpZHRoOiAnJyxcbiAgICB9O1xuICAgIGlmICghaWdub3JlQm9yZGVyICYmIGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGggPiAwKSB7XG4gICAgICAgIHN3aXRjaCAoYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRhc2hlZDpcbiAgICAgICAgICAgICAgICBzdHlsZXMuYm9yZGVyU3R5bGUgPSAnZGFzaGVkJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5Tb2xpZDpcbiAgICAgICAgICAgICAgICBzdHlsZXMuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVuZGVybGluZTpcbiAgICAgICAgICAgICAgICBzdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tU3R5bGU6ICdzb2xpZCcsXG4gICAgICAgICAgICAgICAgfSwgc3R5bGVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CZXZlbGVkOlxuICAgICAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkluc2V0OlxuICAgICAgICB9XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgICAgIHN0eWxlcy5ib3JkZXJXaWR0aCA9IFwiXCIuY29uY2F0KGJvcmRlcldpZHRoLCBcInB4XCIpO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS5zdHlsZSAhPT0gQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VbmRlcmxpbmUpIHtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggLSAyICogYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSAyICogYm9yZGVyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jID0gYW5ub3RhdGlvbi5ib3JkZXJTdHlsZSwgaG9yaXpvbnRhbENvcm5lclJhZGl1cyA9IF9jLmhvcml6b250YWxDb3JuZXJSYWRpdXMsIHZlcnRpY2FsQ29ybmVyUmFkaXVzID0gX2MudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICAgIGlmIChob3Jpem9udGFsQ29ybmVyUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbENvcm5lclJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgIHN0eWxlcy5ib3JkZXJSYWRpdXMgPSBcIlwiLmNvbmNhdChob3Jpem9udGFsQ29ybmVyUmFkaXVzLCBcInB4IC8gXCIpLmNvbmNhdCh2ZXJ0aWNhbENvcm5lclJhZGl1cywgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhbm5vdGF0aW9uLmNvbG9yXG4gICAgICAgICAgICA/IChzdHlsZXMuYm9yZGVyQ29sb3IgPSBcInJnYihcIi5jb25jYXQoYW5ub3RhdGlvbi5jb2xvclswXSB8IDAsIFwiLCBcIikuY29uY2F0KGFubm90YXRpb24uY29sb3JbMV0gfCAwLCBcIiwgXCIpLmNvbmNhdChhbm5vdGF0aW9uLmNvbG9yWzJdIHwgMCwgXCIpXCIpKVxuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgIChzdHlsZXMuYm9yZGVyV2lkdGggPSAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCBpc1JlbmRlcmFibGUgJiZcbiAgICAgICAgY2hpbGRyZW4oe1xuICAgICAgICAgICAgcG9wdXA6IHtcbiAgICAgICAgICAgICAgICBvcGVuZWQ6IG9wZW5lZCxcbiAgICAgICAgICAgICAgICBjbG9zZU9uSG92ZXI6IGNsb3NlT25Ib3ZlcixcbiAgICAgICAgICAgICAgICBvcGVuT25Ib3Zlcjogb3Blbk9uSG92ZXIsXG4gICAgICAgICAgICAgICAgdG9nZ2xlT25DbGljazogdG9nZ2xlT25DbGljayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90OiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChib3VuZFswXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCJcIi5jb25jYXQoYm91bmRbMV0sIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwibWF0cml4KFwiLmNvbmNhdCh2aWV3cG9ydC50cmFuc2Zvcm0uam9pbignLCcpLCBcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiLVwiLmNvbmNhdChib3VuZFswXSwgXCJweCAtXCIpLmNvbmNhdChib3VuZFsxXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc3R5bGVzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgaGFzUG9wdXAgJiYgb3BlbmVkICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3B1cFdyYXBwZXIsIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiB9KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSkpO1xufTtcblxudmFyIENhcmV0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1jYXJldFwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSwgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgQ2lyY2xlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIHJlY3QgPSBhbm5vdGF0aW9uLnJlY3Q7XG4gICAgdmFyIHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1jaXJjbGVcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodCksIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3k6IGhlaWdodCAvIDIsIGZpbGw6IFwibm9uZVwiLCByeDogd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyLCByeTogaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMiwgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIHN0cm9rZVdpZHRoOiBib3JkZXJXaWR0aCB8fCAxIH0pKSxcbiAgICAgICAgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgZ2V0RmlsZU5hbWUgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIHN0ciA9IHVybC5zcGxpdCgnLycpLnBvcCgpO1xuICAgIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoJyMnKVswXS5zcGxpdCgnPycpWzBdIDogdXJsO1xufTtcblxudmFyIGRvd25sb2FkRmlsZSA9IGZ1bmN0aW9uICh1cmwsIGRhdGEpIHtcbiAgICB2YXIgYmxvYlVybCA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICcnIDogVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogJycgfSkpO1xuICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmsuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBsaW5rLmhyZWYgPSBibG9iVXJsIHx8IHVybDtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBnZXRGaWxlTmFtZSh1cmwpKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuICAgIGxpbmsuY2xpY2soKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgIGlmIChibG9iVXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgfVxufTtcblxudmFyIEZpbGVBdHRhY2htZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZSAmJiAoISF0aXRsZSB8fCAhIWNvbnRlbnRzKTtcbiAgICB2YXIgZG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlID0gYW5ub3RhdGlvbi5maWxlO1xuICAgICAgICBmaWxlICYmIGRvd25sb2FkRmlsZShmaWxlLmZpbGVuYW1lLCBmaWxlLmNvbnRlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiB0cnVlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tZmlsZS1hdHRhY2htZW50XCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IGRvdWJsZUNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSwgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgRnJlZVRleHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLWZyZWUtdGV4dFwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSwgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgUG9wdXAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhISh0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIGlnbm9yZWRQYXJlbnRzID0gWydDaXJjbGUnLCAnSW5rJywgJ0xpbmUnLCAnUG9seWdvbicsICdQb2x5TGluZScsICdTcXVhcmUnXTtcbiAgICB2YXIgaGFzUG9wdXAgPSAhYW5ub3RhdGlvbi5wYXJlbnRUeXBlIHx8IGlnbm9yZWRQYXJlbnRzLmluZGV4T2YoYW5ub3RhdGlvbi5wYXJlbnRUeXBlKSAhPT0gLTE7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbi5wYXJlbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYW5ub3RhdGlvbi1pZD1cXFwiXCIuY29uY2F0KGFubm90YXRpb24ucGFyZW50SWQsIFwiXFxcIl1cIikpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWFubm90YXRpb24taWQ9XFxcIlwiLmNvbmNhdChhbm5vdGF0aW9uLmlkLCBcIlxcXCJdXCIpKTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0ID0gcGFyc2VGbG9hdChwYXJlbnQuc3R5bGUubGVmdCk7XG4gICAgICAgIHZhciB0b3AgPSBwYXJzZUZsb2F0KHBhcmVudC5zdHlsZS50b3ApICsgcGFyc2VGbG9hdChwYXJlbnQuc3R5bGUuaGVpZ2h0KTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChsZWZ0LCBcInB4XCIpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gXCJcIi5jb25jYXQodG9wLCBcInB4XCIpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCItXCIuY29uY2F0KGxlZnQsIFwicHggLVwiKS5jb25jYXQodG9wLCBcInB4XCIpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiBmYWxzZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1wb3B1cFwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkIH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUG9wdXBXcmFwcGVyLCB7IGFubm90YXRpb246IGFubm90YXRpb24gfSkpKTsgfSkpO1xufTtcblxudmFyIEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgY2hpbGRBbm5vdGF0aW9uID0gX2EuY2hpbGRBbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIGhhc1F1YWRQb2ludHMgPSBhbm5vdGF0aW9uLnF1YWRQb2ludHMgJiYgYW5ub3RhdGlvbi5xdWFkUG9pbnRzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGhhc1F1YWRQb2ludHMpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gYW5ub3RhdGlvbi5xdWFkUG9pbnRzLm1hcChmdW5jdGlvbiAocXVhZFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYW5ub3RhdGlvbiwge1xuICAgICAgICAgICAgICAgIHJlY3Q6IFtxdWFkUG9pbnRbMl0ueCwgcXVhZFBvaW50WzJdLnksIHF1YWRQb2ludFsxXS54LCBxdWFkUG9pbnRbMV0ueV0sXG4gICAgICAgICAgICAgICAgcXVhZFBvaW50czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIGFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYW5uLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChIaWdobGlnaHQsIHsga2V5OiBpbmRleCwgYW5ub3RhdGlvbjogYW5uLCBjaGlsZEFubm90YXRpb246IGNoaWxkQW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0pKTsgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0taGlnaGxpZ2h0XCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSxcbiAgICAgICAgY2hpbGRBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICBjaGlsZEFubm90YXRpb24uYW5ub3RhdGlvblR5cGUgPT09IGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuUG9wdXAgJiZcbiAgICAgICAgICAgIHByb3BzLnBvcHVwLm9wZW5lZCAmJiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUG9wdXAsIHsgYW5ub3RhdGlvbjogY2hpbGRBbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSkpKTsgfSkpO1xufTtcblxudmFyIEluayA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHZhciByZWN0ID0gYW5ub3RhdGlvbi5yZWN0O1xuICAgIHZhciB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBhbm5vdGF0aW9uLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IHRydWUsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0taW5rXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLFxuICAgICAgICBhbm5vdGF0aW9uLmlua0xpc3RzICYmIGFubm90YXRpb24uaW5rTGlzdHMubGVuZ3RoICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdCh3aWR0aCwgXCIgXCIpLmNvbmNhdChoZWlnaHQpLCB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikgfSwgYW5ub3RhdGlvbi5pbmtMaXN0cy5tYXAoZnVuY3Rpb24gKGlua0xpc3QsIGluZGV4KSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgeyBrZXk6IGluZGV4LCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIHN0cm9rZVdpZHRoOiBib3JkZXJXaWR0aCB8fCAxLCBwb2ludHM6IGlua0xpc3QubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBcIlwiLmNvbmNhdChpdGVtLnggLSByZWN0WzBdLCBcIixcIikuY29uY2F0KHJlY3RbM10gLSBpdGVtLnkpOyB9KS5qb2luKCcgJykgfSkpOyB9KSkpLFxuICAgICAgICBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBMaW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIHJlY3QgPSBhbm5vdGF0aW9uLnJlY3Q7XG4gICAgdmFyIHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1saW5lXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdCh3aWR0aCwgXCIgXCIpLmNvbmNhdChoZWlnaHQpLCB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikgfSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRoIHx8IDEsIHgxOiByZWN0WzJdIC0gYW5ub3RhdGlvbi5saW5lQ29vcmRpbmF0ZXNbMF0sIHgyOiByZWN0WzJdIC0gYW5ub3RhdGlvbi5saW5lQ29vcmRpbmF0ZXNbMl0sIHkxOiByZWN0WzNdIC0gYW5ub3RhdGlvbi5saW5lQ29vcmRpbmF0ZXNbMV0sIHkyOiByZWN0WzNdIC0gYW5ub3RhdGlvbi5saW5lQ29vcmRpbmF0ZXNbM10gfSkpLFxuICAgICAgICBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBJTlZBTElEX1BST1RPQ09MID0gL14oW15cXHddKikoamF2YXNjcmlwdHxkYXRhfHZic2NyaXB0KS9pbTtcbnZhciBIVE1MX0VOVElUSUVTID0gLyYjKFxcdyspKF5cXHd8Oyk/L2c7XG52YXIgQ1RSTF9DSEFSUyA9IC9bXFx1MDAwMC1cXHUwMDFGXFx1MDA3Ri1cXHUwMDlGXFx1MjAwMC1cXHUyMDBEXFx1RkVGRl0vZ2ltO1xudmFyIFVSTF9TQ0hFTUUgPSAvXihbXjpdKyk6L2dtO1xudmFyIGRlY29kZUh0bWxFbnRpdGllcyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRU5USVRJRVMsIGZ1bmN0aW9uIChfLCBkZWMpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjKTsgfSk7IH07XG52YXIgc2FuaXRpemVVcmwgPSBmdW5jdGlvbiAodXJsLCBkZWZhdWx0VXJsKSB7XG4gICAgaWYgKGRlZmF1bHRVcmwgPT09IHZvaWQgMCkgeyBkZWZhdWx0VXJsID0gJ2Fib3V0OmJsYW5rJzsgfVxuICAgIHZhciByZXN1bHQgPSBkZWNvZGVIdG1sRW50aXRpZXModXJsIHx8ICcnKVxuICAgICAgICAucmVwbGFjZShDVFJMX0NIQVJTLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFVybDtcbiAgICB9XG4gICAgdmFyIGZpcnN0Q2hhciA9IHJlc3VsdFswXTtcbiAgICBpZiAoZmlyc3RDaGFyID09PSAnLicgfHwgZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHBhcnNlZFVybFNjaGVtZSA9IHJlc3VsdC5tYXRjaChVUkxfU0NIRU1FKTtcbiAgICBpZiAoIXBhcnNlZFVybFNjaGVtZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgc2NoZW1lID0gcGFyc2VkVXJsU2NoZW1lWzBdO1xuICAgIHJldHVybiBJTlZBTElEX1BST1RPQ09MLnRlc3Qoc2NoZW1lKSA/IGRlZmF1bHRVcmwgOiByZXN1bHQ7XG59O1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIGFubm90YXRpb25Db250YWluZXJSZWYgPSBfYS5hbm5vdGF0aW9uQ29udGFpbmVyUmVmLCBkb2MgPSBfYS5kb2MsIG91dGxpbmVzID0gX2Eub3V0bGluZXMsIHBhZ2UgPSBfYS5wYWdlLCBwYWdlSW5kZXggPSBfYS5wYWdlSW5kZXgsIHNjYWxlID0gX2Euc2NhbGUsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQsIG9uRXhlY3V0ZU5hbWVkQWN0aW9uID0gX2Eub25FeGVjdXRlTmFtZWRBY3Rpb24sIG9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbiA9IF9hLm9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbiwgb25KdW1wVG9EZXN0ID0gX2Eub25KdW1wVG9EZXN0O1xuICAgIHZhciBlbGVtZW50UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgdGl0bGUgPSBvdXRsaW5lcyAmJiBvdXRsaW5lcy5sZW5ndGggJiYgYW5ub3RhdGlvbi5kZXN0ICYmIHR5cGVvZiBhbm5vdGF0aW9uLmRlc3QgPT09ICdzdHJpbmcnXG4gICAgICAgID8gKF9iID0gb3V0bGluZXMuZmluZChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5kZXN0ID09PSBhbm5vdGF0aW9uLmRlc3Q7IH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGl0bGVcbiAgICAgICAgOiAnJztcbiAgICB2YXIgbGluayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYW5ub3RhdGlvbi5hY3Rpb25cbiAgICAgICAgICAgID8gb25FeGVjdXRlTmFtZWRBY3Rpb24oYW5ub3RhdGlvbi5hY3Rpb24pXG4gICAgICAgICAgICA6IGdldERlc3RpbmF0aW9uKGRvYywgYW5ub3RhdGlvbi5kZXN0KS50aGVuKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkNvbnRhaW5lciA9IGFubm90YXRpb25Db250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBhbm5vdGF0aW9uQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25Db250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25Db250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25MYXllclJlY3QgPSBhbm5vdGF0aW9uQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSAobGlua1JlY3QubGVmdCAtIGFubm90YXRpb25MYXllclJlY3QubGVmdCkgLyBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbU9mZnNldCA9IChhbm5vdGF0aW9uTGF5ZXJSZWN0LmJvdHRvbSAtIGxpbmtSZWN0LmJvdHRvbSArIGxpbmtSZWN0LmhlaWdodCkgLyBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbU9mZnNldDogYm90dG9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdE9mZnNldDogbGVmdE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25KdW1wVG9EZXN0KHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLnVybCB8fCBhbm5vdGF0aW9uLmRlc3QgfHwgYW5ub3RhdGlvbi5hY3Rpb24gfHwgYW5ub3RhdGlvbi51bnNhZmVVcmwpO1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIGlmIChhbm5vdGF0aW9uLnVybCB8fCBhbm5vdGF0aW9uLnVuc2FmZVVybCkge1xuICAgICAgICB2YXIgdGFyZ2V0VXJsID0gc2FuaXRpemVVcmwoYW5ub3RhdGlvbi51cmwgfHwgYW5ub3RhdGlvbi51bnNhZmVVcmwsICcnKTtcbiAgICAgICAgaWYgKHRhcmdldFVybCkge1xuICAgICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgJ2RhdGEtdGFyZ2V0JzogJ2V4dGVybmFsJyxcbiAgICAgICAgICAgICAgICBocmVmOiB0YXJnZXRVcmwsXG4gICAgICAgICAgICAgICAgcmVsOiAnbm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvdycsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhbm5vdGF0aW9uLm5ld1dpbmRvdyA/ICdfYmxhbmsnIDogJycsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRhcmdldFVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc1JlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICBocmVmOiAnJyxcbiAgICAgICAgICAgICdkYXRhLWFubm90YXRpb24tbGluayc6IGFubm90YXRpb24uaWQsXG4gICAgICAgICAgICBvbkNsaWNrOiBsaW5rLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRycywge1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aXRsZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGZhbHNlLCBpZ25vcmVCb3JkZXI6IGZhbHNlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLWxpbmtcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgXCJkYXRhLXRlc3RpZFwiOiBcImNvcmVfX2Fubm90YXRpb24tLWxpbmstXCIuY29uY2F0KGFubm90YXRpb24uaWQpIH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fYXNzaWduKHsgcmVmOiBlbGVtZW50UmVmIH0sIGF0dHJzKSkpKTsgfSkpO1xufTtcblxudmFyIFBvbHlnb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgcmVjdCA9IGFubm90YXRpb24ucmVjdDtcbiAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgdmFyIGJvcmRlcldpZHRoID0gYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXBvbHlnb25cIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksXG4gICAgICAgIGFubm90YXRpb24udmVydGljZXMgJiYgYW5ub3RhdGlvbi52ZXJ0aWNlcy5sZW5ndGggJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodCksIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicG9seWdvblwiLCB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRoIHx8IDEsIHBvaW50czogYW5ub3RhdGlvbi52ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBcIlwiLmNvbmNhdChpdGVtLnggLSByZWN0WzBdLCBcIixcIikuY29uY2F0KHJlY3RbM10gLSBpdGVtLnkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpIH0pKSksXG4gICAgICAgIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIFBvbHlsaW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIHJlY3QgPSBhbm5vdGF0aW9uLnJlY3Q7XG4gICAgdmFyIHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1wb2x5bGluZVwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSxcbiAgICAgICAgYW5ub3RhdGlvbi52ZXJ0aWNlcyAmJiBhbm5vdGF0aW9uLnZlcnRpY2VzLmxlbmd0aCAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCBcIi5jb25jYXQod2lkdGgsIFwiIFwiKS5jb25jYXQoaGVpZ2h0KSwgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRoIHx8IDEsIHBvaW50czogYW5ub3RhdGlvbi52ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBcIlwiLmNvbmNhdChpdGVtLnggLSByZWN0WzBdLCBcIixcIikuY29uY2F0KHJlY3RbM10gLSBpdGVtLnkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpIH0pKSksXG4gICAgICAgIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIFNxdWFyZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHZhciByZWN0ID0gYW5ub3RhdGlvbi5yZWN0O1xuICAgIHZhciB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBhbm5vdGF0aW9uLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IHRydWUsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tc3F1YXJlXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdCh3aWR0aCwgXCIgXCIpLmNvbmNhdChoZWlnaHQpLCB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikgfSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgeyBoZWlnaHQ6IGhlaWdodCAtIGJvcmRlcldpZHRoLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIHN0cm9rZVdpZHRoOiBib3JkZXJXaWR0aCB8fCAxLCB4OiBib3JkZXJXaWR0aCAvIDIsIHk6IGJvcmRlcldpZHRoIC8gMiwgd2lkdGg6IHdpZHRoIC0gYm9yZGVyV2lkdGggfSkpLFxuICAgICAgICBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBTcXVpZ2dseSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IHRydWUsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tc3F1aWdnbHlcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIFN0YW1wID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1zdGFtcFwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSwgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgU3RyaWtlT3V0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1zdHJpa2Utb3V0XCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBDb21tZW50SWNvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSWNvbiwgeyBzaXplOiAxNiB9LFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0uNSwxNi41YTEsMSwwLDAsMCwxLDFoMnY0bDQtNGgxNWExLDEsMCwwLDAsMS0xVjMuNWExLDEsMCwwLDAtMS0xSDEuNWExLDEsMCwwLDAtMSwxWlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk03LjI1LDkuNzVBLjI1LjI1LDAsMSwxLDcsMTBhLjI1LjI1LDAsMCwxLC4yNS0uMjVcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTIsOS43NWEuMjUuMjUsMCwxLDEtLjI1LjI1QS4yNS4yNSwwLDAsMSwxMiw5Ljc1XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE2Ljc1LDkuNzVhLjI1LjI1LDAsMSwxLS4yNS4yNS4yNS4yNSwwLDAsMSwuMjUtLjI1XCIgfSkpKTsgfTtcblxudmFyIEhlbHBJY29uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJY29uLCB7IHNpemU6IDE2IH0sXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNTAwIDEyLjAwMSBBMTEuNTAwIDExLjUwMCAwIDEgMCAyMy41MDAgMTIuMDAxIEExMS41MDAgMTEuNTAwIDAgMSAwIDAuNTAwIDEyLjAwMSBaXCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYuMDAwIDEyLjAwMSBBNi4wMDAgNi4wMDAgMCAxIDAgMTguMDAwIDEyLjAwMSBBNi4wMDAgNi4wMDAgMCAxIDAgNi4wMDAgMTIuMDAxIFpcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjEuNDIzIDUuNDA2TDE3LjQxNSA5LjQxNFwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xNC41ODcgNi41ODVMMTguNjA3IDIuNTY1XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTUuNDA1IDIxLjQyNEw5LjQxMyAxNy40MTZcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNi41ODUgMTQuNTg4TDIuNTc3IDE4LjU5NlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOC42MDIgMjEuNDE5TDE0LjU5NSAxNy40MTJcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTcuNDE5IDE0LjU4TDIxLjQyOCAxOC41ODlcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMi41ODIgNS4zOTlMNi41ODggOS40MDZcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNOS40MjEgNi41ODFMNS40MTIgMi41NzJcIiB9KSkpOyB9O1xuXG52YXIgS2V5SWNvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSWNvbiwgeyBzaXplOiAxNiB9LFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk00LjAwMCAxOC41MDAgQTEuNTAwIDEuNTAwIDAgMSAwIDcuMDAwIDE4LjUwMCBBMS41MDAgMS41MDAgMCAxIDAgNC4wMDAgMTguNTAwIFpcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjAuNS41bC05Ljc4Miw5Ljc4M2E3LDcsMCwxLDAsMywzTDE3LDEwaDEuNVY4LjVMMTksOGgxLjVWNi41TDIxLDZoMS41VjQuNWwxLTFWLjVaXCIgfSkpKTsgfTtcblxudmFyIE5vdGVJY29uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJY29uLCB7IHNpemU6IDE2IH0sXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTIuMDAwIDIuNTAwIEwyMi4wMDAgMi41MDAgTDIyLjAwMCAyMy41MDAgTDIuMDAwIDIzLjUwMCBaXCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYgNC41TDYgMC41XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDQuNUwxOCAwLjVcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTAgNC41TDEwIDAuNVwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xNCA0LjVMMTQgMC41XCIgfSkpKTsgfTtcblxudmFyIFBhcmFncmFwaEljb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEljb24sIHsgc2l6ZTogMTYgfSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTcuNSAwLjQ5OEwxNy41IDIzLjQ5OFwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMC41IDAuNDk4TDEwLjUgMjMuNDk4XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTIzLjUuNUg2LjVhNiw2LDAsMCwwLDAsMTJoNFwiIH0pKSk7IH07XG5cbnZhciBUcmlhbmdsZUljb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEljb24sIHsgc2l6ZTogMTYgfSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMi41IDIyLjk5NUwxMiA2LjAwNSAyMS41IDIyLjk5NSAyLjUgMjIuOTk1elwiIH0pKSk7IH07XG5cbnZhciBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBjaGlsZEFubm90YXRpb24gPSBfYS5jaGlsZEFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgbmFtZSA9IGFubm90YXRpb24ubmFtZSA/IGFubm90YXRpb24ubmFtZS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogZmFsc2UsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXRleHRcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksXG4gICAgICAgICAgICBuYW1lICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24tdGV4dC1pY29uXCIgfSxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnY2hlY2snICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDaGVja0ljb24sIG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdjb21tZW50JyAmJiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ29tbWVudEljb24sIG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdoZWxwJyAmJiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSGVscEljb24sIG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdpbnNlcnQnICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChUcmlhbmdsZUljb24sIG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdrZXknICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChLZXlJY29uLCBudWxsKSxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnbm90ZScgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE5vdGVJY29uLCBudWxsKSxcbiAgICAgICAgICAgICAgICAobmFtZSA9PT0gJ25ld3BhcmFncmFwaCcgfHwgbmFtZSA9PT0gJ3BhcmFncmFwaCcpICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQYXJhZ3JhcGhJY29uLCBudWxsKSkpLFxuICAgICAgICAgICAgcHJvcHMuc2xvdC5jaGlsZHJlbiksXG4gICAgICAgIGNoaWxkQW5ub3RhdGlvbiAmJlxuICAgICAgICAgICAgY2hpbGRBbm5vdGF0aW9uLmFubm90YXRpb25UeXBlID09PSBleHBvcnRzLkFubm90YXRpb25UeXBlLlBvcHVwICYmXG4gICAgICAgICAgICBwcm9wcy5wb3B1cC5vcGVuZWQgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBvcHVwLCB7IGFubm90YXRpb246IGNoaWxkQW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0pKSk7IH0pKTtcbn07XG5cbnZhciBVbmRlcmxpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXVuZGVybGluZVwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSwgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgQW5ub3RhdGlvbkxheWVyQm9keSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9ucyA9IF9hLmFubm90YXRpb25zLCBkb2MgPSBfYS5kb2MsIG91dGxpbmVzID0gX2Eub3V0bGluZXMsIHBhZ2UgPSBfYS5wYWdlLCBwYWdlSW5kZXggPSBfYS5wYWdlSW5kZXgsIHBsdWdpbnMgPSBfYS5wbHVnaW5zLCByb3RhdGlvbiA9IF9hLnJvdGF0aW9uLCBzY2FsZSA9IF9hLnNjYWxlLCBvbkV4ZWN1dGVOYW1lZEFjdGlvbiA9IF9hLm9uRXhlY3V0ZU5hbWVkQWN0aW9uLCBvbkp1bXBGcm9tTGlua0Fubm90YXRpb24gPSBfYS5vbkp1bXBGcm9tTGlua0Fubm90YXRpb24sIG9uSnVtcFRvRGVzdCA9IF9hLm9uSnVtcFRvRGVzdDtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgcm90YXRpb246IHJvdGF0aW9uLCBzY2FsZTogc2NhbGUgfSk7XG4gICAgdmFyIGNsb25lZFZpZXdQb3J0ID0gdmlld3BvcnQuY2xvbmUoeyBkb250RmxpcDogdHJ1ZSB9KTtcbiAgICB2YXIgZmlsdGVyQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFubm90YXRpb24pIHsgcmV0dXJuICFhbm5vdGF0aW9uLnBhcmVudElkOyB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLm9uQW5ub3RhdGlvbkxheWVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLm9uQW5ub3RhdGlvbkxheWVyUmVuZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZpbHRlckFubm90YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lclJlZiwgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uLWxheWVyXCIsIFwiZGF0YS10ZXN0aWRcIjogXCJjb3JlX19hbm5vdGF0aW9uLWxheWVyLVwiLmNvbmNhdChwYWdlSW5kZXgpIH0sIGZpbHRlckFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgY2hpbGRBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnMuZmluZChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5wYXJlbnRJZCA9PT0gYW5ub3RhdGlvbi5pZDsgfSk7XG4gICAgICAgIHN3aXRjaCAoYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkNhcmV0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KENhcmV0LCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5DaXJjbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ2lyY2xlLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5GaWxlQXR0YWNobWVudDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGaWxlQXR0YWNobWVudCwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuRnJlZVRleHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRnJlZVRleHQsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkhpZ2hsaWdodDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChIaWdobGlnaHQsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBjaGlsZEFubm90YXRpb246IGNoaWxkQW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5Jbms6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSW5rLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5MaW5lOlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExpbmUsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkxpbms6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTGluaywgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIGFubm90YXRpb25Db250YWluZXJSZWY6IGNvbnRhaW5lclJlZiwgZG9jOiBkb2MsIG91dGxpbmVzOiBvdXRsaW5lcywgcGFnZTogcGFnZSwgcGFnZUluZGV4OiBwYWdlSW5kZXgsIHNjYWxlOiBzY2FsZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0LCBvbkV4ZWN1dGVOYW1lZEFjdGlvbjogb25FeGVjdXRlTmFtZWRBY3Rpb24sIG9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbjogb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uLCBvbkp1bXBUb0Rlc3Q6IG9uSnVtcFRvRGVzdCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuUG9seWdvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb2x5Z29uLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5Qb2x5bGluZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb2x5bGluZSwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuUG9wdXA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUG9wdXAsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLlNxdWFyZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChTcXVhcmUsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLlNxdWlnZ2x5OlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFNxdWlnZ2x5LCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5TdGFtcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChTdGFtcCwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuU3RyaWtlT3V0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFN0cmlrZU91dCwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuVGV4dDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChUZXh0LCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgY2hpbGRBbm5vdGF0aW9uOiBjaGlsZEFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuVW5kZXJsaW5lOlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFVuZGVybGluZSwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgeyBrZXk6IGFubm90YXRpb24uaWQgfSk7XG4gICAgICAgIH1cbiAgICB9KSkpO1xufTtcblxudmFyIEFubm90YXRpb25Mb2FkZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcGFnZSA9IF9hLnBhZ2UsIHJlbmRlckFubm90YXRpb25zID0gX2EucmVuZGVyQW5ub3RhdGlvbnM7XG4gICAgdmFyIGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICAgIHZhciBfYiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICBhbm5vdGF0aW9uczogW10sXG4gICAgfSksIHN0YXR1cyA9IF9iWzBdLCBzZXRTdGF0dXMgPSBfYlsxXTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhZ2UuZ2V0QW5ub3RhdGlvbnMoeyBpbnRlbnQ6ICdkaXNwbGF5JyB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogcmVzdWx0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHN0YXR1cy5sb2FkaW5nID8gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwpIDogcmVuZGVyQW5ub3RhdGlvbnMoc3RhdHVzLmFubm90YXRpb25zKTtcbn07XG5cbnZhciBBbm5vdGF0aW9uTGF5ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZG9jID0gX2EuZG9jLCBvdXRsaW5lcyA9IF9hLm91dGxpbmVzLCBwYWdlID0gX2EucGFnZSwgcGFnZUluZGV4ID0gX2EucGFnZUluZGV4LCBwbHVnaW5zID0gX2EucGx1Z2lucywgcm90YXRpb24gPSBfYS5yb3RhdGlvbiwgc2NhbGUgPSBfYS5zY2FsZSwgb25FeGVjdXRlTmFtZWRBY3Rpb24gPSBfYS5vbkV4ZWN1dGVOYW1lZEFjdGlvbiwgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uID0gX2Eub25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uLCBvbkp1bXBUb0Rlc3QgPSBfYS5vbkp1bXBUb0Rlc3Q7XG4gICAgdmFyIHJlbmRlckFubm90YXRpb25zID0gZnVuY3Rpb24gKGFubm90YXRpb25zKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb25MYXllckJvZHksIHsgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zLCBkb2M6IGRvYywgb3V0bGluZXM6IG91dGxpbmVzLCBwYWdlOiBwYWdlLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgcGx1Z2luczogcGx1Z2lucywgcm90YXRpb246IHJvdGF0aW9uLCBzY2FsZTogc2NhbGUsIG9uRXhlY3V0ZU5hbWVkQWN0aW9uOiBvbkV4ZWN1dGVOYW1lZEFjdGlvbiwgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uOiBvbkp1bXBGcm9tTGlua0Fubm90YXRpb24sIG9uSnVtcFRvRGVzdDogb25KdW1wVG9EZXN0IH0pKTsgfTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb25Mb2FkZXIsIHsgcGFnZTogcGFnZSwgcmVuZGVyQW5ub3RhdGlvbnM6IHJlbmRlckFubm90YXRpb25zIH0pO1xufTtcblxudmFyIGZsb2F0VG9SYXRpbyA9IGZ1bmN0aW9uICh4LCBsaW1pdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKE1hdGguZmxvb3IoeCkgPT09IHgpIHtcbiAgICAgICAgcmV0dXJuIFt4LCAxXTtcbiAgICB9XG4gICAgdmFyIHkgPSAxIC8geDtcbiAgICBpZiAoeSA+IGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbMSwgbGltaXRdO1xuICAgIH1cbiAgICBpZiAoTWF0aC5mbG9vcih5KSA9PT0geSkge1xuICAgICAgICByZXR1cm4gWzEsIHldO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSB4ID4gMSA/IHkgOiB4O1xuICAgIHZhciBhID0gMDtcbiAgICB2YXIgYiA9IDE7XG4gICAgdmFyIGMgPSAxO1xuICAgIHZhciBkID0gMTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbnVtZXJhdG9yID0gYSArIGM7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IGIgKyBkO1xuICAgICAgICBpZiAoZGVub21pbmF0b3IgPiBsaW1pdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPD0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgPyAoX2EgPSBbbnVtZXJhdG9yLCBkZW5vbWluYXRvcl0sIGMgPSBfYVswXSwgZCA9IF9hWzFdLCBfYSkgOiAoX2IgPSBbbnVtZXJhdG9yLCBkZW5vbWluYXRvcl0sIGEgPSBfYlswXSwgYiA9IF9iWzFdLCBfYik7XG4gICAgfVxuICAgIHZhciBtaWRkbGUgPSAoYSAvIGIgKyBjIC8gZCkgLyAyO1xuICAgIHJldHVybiB2YWx1ZSA8IG1pZGRsZSA/ICh2YWx1ZSA9PT0geCA/IFthLCBiXSA6IFtiLCBhXSkgOiB2YWx1ZSA9PT0geCA/IFtjLCBkXSA6IFtkLCBjXTtcbn07XG5cbnZhciByb3VuZFRvRGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgcmVtYWluZGVyID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlbWFpbmRlciA9PT0gMCA/IGEgOiBNYXRoLmZsb29yKGEgLSByZW1haW5kZXIpO1xufTtcblxudmFyIE1BWF9DQU5WQVNfU0laRSA9IDQwOTYgKiA0MDk2O1xudmFyIENhbnZhc0xheWVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNhbnZhc0xheWVyUmVmID0gX2EuY2FudmFzTGF5ZXJSZWYsIGhlaWdodCA9IF9hLmhlaWdodCwgcGFnZSA9IF9hLnBhZ2UsIHBhZ2VJbmRleCA9IF9hLnBhZ2VJbmRleCwgcGx1Z2lucyA9IF9hLnBsdWdpbnMsIHJvdGF0aW9uID0gX2Eucm90YXRpb24sIHNjYWxlID0gX2Euc2NhbGUsIHdpZHRoID0gX2Eud2lkdGgsIG9uUmVuZGVyQ2FudmFzQ29tcGxldGVkID0gX2Eub25SZW5kZXJDYW52YXNDb21wbGV0ZWQ7XG4gICAgdmFyIHJlbmRlclRhc2sgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFzayA9IHJlbmRlclRhc2suY3VycmVudDtcbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgIHRhc2suY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbnZhc0VsZSA9IGNhbnZhc0xheWVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNhbnZhc0VsZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGVzdGlkJyk7XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLm9uQ2FudmFzTGF5ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ub25DYW52YXNMYXllclJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgIGVsZTogY2FudmFzRWxlLFxuICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogZXhwb3J0cy5MYXllclJlbmRlclN0YXR1cy5QcmVSZW5kZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvdXRwdXRTY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIHZhciBtYXhTY2FsZSA9IE1hdGguc3FydChNQVhfQ0FOVkFTX1NJWkUgLyAodmlld3BvcnQud2lkdGggKiB2aWV3cG9ydC5oZWlnaHQpKTtcbiAgICAgICAgdmFyIHNob3VsZFNjYWxlQnlDU1MgPSBvdXRwdXRTY2FsZSA+IG1heFNjYWxlO1xuICAgICAgICBzaG91bGRTY2FsZUJ5Q1NTID8gKGNhbnZhc0VsZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKDEsIDEpXCIpIDogY2FudmFzRWxlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgdmFyIHBvc3NpYmxlU2NhbGUgPSBNYXRoLm1pbihtYXhTY2FsZSwgb3V0cHV0U2NhbGUpO1xuICAgICAgICB2YXIgX2EgPSBmbG9hdFRvUmF0aW8ocG9zc2libGVTY2FsZSwgOCksIHggPSBfYVswXSwgeSA9IF9hWzFdO1xuICAgICAgICBjYW52YXNFbGUud2lkdGggPSByb3VuZFRvRGl2aWRlKHZpZXdwb3J0LndpZHRoICogcG9zc2libGVTY2FsZSwgeCk7XG4gICAgICAgIGNhbnZhc0VsZS5oZWlnaHQgPSByb3VuZFRvRGl2aWRlKHZpZXdwb3J0LmhlaWdodCAqIHBvc3NpYmxlU2NhbGUsIHgpO1xuICAgICAgICBjYW52YXNFbGUuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChyb3VuZFRvRGl2aWRlKHZpZXdwb3J0LndpZHRoLCB5KSwgXCJweFwiKTtcbiAgICAgICAgY2FudmFzRWxlLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHJvdW5kVG9EaXZpZGUodmlld3BvcnQuaGVpZ2h0LCB5KSwgXCJweFwiKTtcbiAgICAgICAgY2FudmFzRWxlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHZhciBjYW52YXNDb250ZXh0ID0gY2FudmFzRWxlLmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogZmFsc2UgfSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBzaG91bGRTY2FsZUJ5Q1NTIHx8IG91dHB1dFNjYWxlICE9PSAxID8gW3Bvc3NpYmxlU2NhbGUsIDAsIDAsIHBvc3NpYmxlU2NhbGUsIDAsIDBdIDogbnVsbDtcbiAgICAgICAgcmVuZGVyVGFzay5jdXJyZW50ID0gcGFnZS5yZW5kZXIoeyBjYW52YXNDb250ZXh0OiBjYW52YXNDb250ZXh0LCB0cmFuc2Zvcm06IHRyYW5zZm9ybSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0pO1xuICAgICAgICByZW5kZXJUYXNrLmN1cnJlbnQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbnZhc0VsZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbnZhc0VsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGVzdGlkJywgXCJjb3JlX19jYW52YXMtbGF5ZXItXCIuY29uY2F0KHBhZ2VJbmRleCkpO1xuICAgICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLm9uQ2FudmFzTGF5ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm9uQ2FudmFzTGF5ZXJSZW5kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBjYW52YXNFbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogZXhwb3J0cy5MYXllclJlbmRlclN0YXR1cy5EaWRSZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25SZW5kZXJDYW52YXNDb21wbGV0ZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25SZW5kZXJDYW52YXNDb21wbGV0ZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzRWxlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzRWxlLndpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBjYW52YXNFbGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2NhbnZhcy1sYXllclwiLCBzdHlsZToge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXG4gICAgICAgIH0gfSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHsgcmVmOiBjYW52YXNMYXllclJlZiB9KSkpO1xufTtcblxudmFyIFN2Z0xheWVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodCwgcGFnZSA9IF9hLnBhZ2UsIHJvdGF0aW9uID0gX2Eucm90YXRpb24sIHNjYWxlID0gX2Euc2NhbGUsIHdpZHRoID0gX2Eud2lkdGg7XG4gICAgdmFyIGNvbnRhaW5lclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyRWxlID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyRWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyRWxlLmlubmVySFRNTCA9ICcnO1xuICAgIH07XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXJFbGUgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHJvdGF0aW9uOiByb3RhdGlvbiwgc2NhbGU6IHNjYWxlIH0pO1xuICAgICAgICBwYWdlLmdldE9wZXJhdG9yTGlzdCgpLnRoZW4oZnVuY3Rpb24gKG9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgICAgZW1wdHkoKTtcbiAgICAgICAgICAgIHZhciBncmFwaGljID0gbmV3IFBkZkpzQXBpX19uYW1lc3BhY2UuU1ZHR3JhcGhpY3MocGFnZS5jb21tb25PYmpzLCBwYWdlLm9ianMpO1xuICAgICAgICAgICAgZ3JhcGhpYy5nZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydCkudGhlbihmdW5jdGlvbiAoc3ZnKSB7XG4gICAgICAgICAgICAgICAgc3ZnLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBzdmcuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbGUuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fc3ZnLWxheWVyXCIsIHJlZjogY29udGFpbmVyUmVmIH0pO1xufTtcblxudmFyIFRleHRMYXllciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjb250YWluZXJSZWYgPSBfYS5jb250YWluZXJSZWYsIHBhZ2UgPSBfYS5wYWdlLCBwYWdlSW5kZXggPSBfYS5wYWdlSW5kZXgsIHBsdWdpbnMgPSBfYS5wbHVnaW5zLCByb3RhdGlvbiA9IF9hLnJvdGF0aW9uLCBzY2FsZSA9IF9hLnNjYWxlLCBvblJlbmRlclRleHRDb21wbGV0ZWQgPSBfYS5vblJlbmRlclRleHRDb21wbGV0ZWQ7XG4gICAgdmFyIHJlbmRlclRhc2sgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsZSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lckVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcGFucyA9IFtdLnNsaWNlLmNhbGwoY29udGFpbmVyRWxlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5ycHYtY29yZV9fdGV4dC1sYXllci10ZXh0JykpO1xuICAgICAgICBzcGFucy5mb3JFYWNoKGZ1bmN0aW9uIChzcGFuKSB7IHJldHVybiBjb250YWluZXJFbGUucmVtb3ZlQ2hpbGQoc3Bhbik7IH0pO1xuICAgICAgICB2YXIgYnJlYWtzID0gW10uc2xpY2UuY2FsbChjb250YWluZXJFbGUucXVlcnlTZWxlY3RvckFsbCgnYnJbcm9sZT1cInByZXNlbnRhdGlvblwiXScpKTtcbiAgICAgICAgYnJlYWtzLmZvckVhY2goZnVuY3Rpb24gKGJyKSB7IHJldHVybiBjb250YWluZXJFbGUucmVtb3ZlQ2hpbGQoYnIpOyB9KTtcbiAgICB9O1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFzayA9IHJlbmRlclRhc2suY3VycmVudDtcbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgIHRhc2suY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRhaW5lckVsZSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lckVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lckVsZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGVzdGlkJyk7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyByb3RhdGlvbjogcm90YXRpb24sIHNjYWxlOiBzY2FsZSB9KTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ub25UZXh0TGF5ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ub25UZXh0TGF5ZXJSZW5kZXIoe1xuICAgICAgICAgICAgICAgICAgICBlbGU6IGNvbnRhaW5lckVsZSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBleHBvcnRzLkxheWVyUmVuZGVyU3RhdHVzLlByZVJlbmRlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhZ2UuZ2V0VGV4dENvbnRlbnQoKS50aGVuKGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgZW1wdHkoKTtcbiAgICAgICAgICAgIHJlbmRlclRhc2suY3VycmVudCA9IFBkZkpzQXBpX19uYW1lc3BhY2UucmVuZGVyVGV4dExheWVyKHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lckVsZSxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnRTb3VyY2U6IHRleHRDb250ZW50LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVuZGVyVGFzay5jdXJyZW50LnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlLnNldEF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnLCBcImNvcmVfX3RleHQtbGF5ZXItXCIuY29uY2F0KHBhZ2VJbmRleCkpO1xuICAgICAgICAgICAgICAgIHZhciBzcGFucyA9IFtdLnNsaWNlLmNhbGwoY29udGFpbmVyRWxlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBzcGFucy5mb3JFYWNoKGZ1bmN0aW9uIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Bhbi5jbGFzc0xpc3QuY29udGFpbnMoJ3Jwdi1jb3JlX190ZXh0LWxheWVyLXRleHQtLW5vdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3Jwdi1jb3JlX190ZXh0LWxheWVyLXRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ub25UZXh0TGF5ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5vblRleHRMYXllclJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBjb250YWluZXJFbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogZXhwb3J0cy5MYXllclJlbmRlclN0YXR1cy5EaWRSZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uUmVuZGVyVGV4dENvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGVzdGlkJyk7XG4gICAgICAgICAgICAgICAgb25SZW5kZXJUZXh0Q29tcGxldGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBlbXB0eSgpO1xuICAgICAgICAgICAgKF9hID0gcmVuZGVyVGFzay5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsKCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX3RleHQtbGF5ZXJcIiwgcmVmOiBjb250YWluZXJSZWYgfSk7XG59O1xuXG52YXIgUGFnZUxheWVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGRvYyA9IF9hLmRvYywgbWVhc3VyZVJlZiA9IF9hLm1lYXN1cmVSZWYsIG91dGxpbmVzID0gX2Eub3V0bGluZXMsIHBhZ2VJbmRleCA9IF9hLnBhZ2VJbmRleCwgcGFnZVJvdGF0aW9uID0gX2EucGFnZVJvdGF0aW9uLCBwYWdlU2l6ZSA9IF9hLnBhZ2VTaXplLCBwbHVnaW5zID0gX2EucGx1Z2lucywgcmVuZGVyUGFnZSA9IF9hLnJlbmRlclBhZ2UsIHJlbmRlclF1ZXVlS2V5ID0gX2EucmVuZGVyUXVldWVLZXksIHJvdGF0aW9uID0gX2Eucm90YXRpb24sIHNjYWxlID0gX2Euc2NhbGUsIHNob3VsZFJlbmRlciA9IF9hLnNob3VsZFJlbmRlciwgdmlld01vZGUgPSBfYS52aWV3TW9kZSwgb25FeGVjdXRlTmFtZWRBY3Rpb24gPSBfYS5vbkV4ZWN1dGVOYW1lZEFjdGlvbiwgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uID0gX2Eub25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uLCBvbkp1bXBUb0Rlc3QgPSBfYS5vbkp1bXBUb0Rlc3QsIG9uUmVuZGVyQ29tcGxldGVkID0gX2Eub25SZW5kZXJDb21wbGV0ZWQsIG9uUm90YXRlUGFnZSA9IF9hLm9uUm90YXRlUGFnZTtcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShudWxsKSwgcGFnZSA9IF9iWzBdLCBzZXRQYWdlID0gX2JbMV07XG4gICAgdmFyIF9jID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIGNhbnZhc0xheWVyUmVuZGVyZWQgPSBfY1swXSwgc2V0Q2FudmFzTGF5ZXJSZW5kZXJlZCA9IF9jWzFdO1xuICAgIHZhciBfZCA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoZmFsc2UpLCB0ZXh0TGF5ZXJSZW5kZXJlZCA9IF9kWzBdLCBzZXRUZXh0TGF5ZXJSZW5kZXJlZCA9IF9kWzFdO1xuICAgIHZhciBjYW52YXNMYXllclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIHRleHRMYXllclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGlzVmVydGljYWwgPSBNYXRoLmFicyhyb3RhdGlvbiArIHBhZ2VSb3RhdGlvbikgJSAxODAgPT09IDA7XG4gICAgdmFyIHNjYWxlZFdpZHRoID0gcGFnZVNpemUucGFnZVdpZHRoICogc2NhbGU7XG4gICAgdmFyIHNjYWxlZEhlaWdodCA9IHBhZ2VTaXplLnBhZ2VIZWlnaHQgKiBzY2FsZTtcbiAgICB2YXIgdyA9IGlzVmVydGljYWwgPyBzY2FsZWRXaWR0aCA6IHNjYWxlZEhlaWdodDtcbiAgICB2YXIgaCA9IGlzVmVydGljYWwgPyBzY2FsZWRIZWlnaHQgOiBzY2FsZWRXaWR0aDtcbiAgICB2YXIgcm90YXRpb25WYWx1ZSA9IChwYWdlU2l6ZS5yb3RhdGlvbiArIHJvdGF0aW9uICsgcGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgICB2YXIgcmVuZGVyUXVldWVLZXlSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigwKTtcbiAgICB2YXIgZGV0ZXJtaW5lUGFnZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBnZXRQYWdlKGRvYywgcGFnZUluZGV4KS50aGVuKGZ1bmN0aW9uIChwZGZQYWdlKSB7XG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJRdWV1ZUtleVJlZi5jdXJyZW50ID0gcmVuZGVyUXVldWVLZXk7XG4gICAgICAgICAgICAgICAgc2V0UGFnZShwZGZQYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdFBhZ2VSZW5kZXJlciA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICBwcm9wcy5jYW52YXNMYXllci5jaGlsZHJlbixcbiAgICAgICAgcHJvcHMudGV4dExheWVyLmNoaWxkcmVuLFxuICAgICAgICBwcm9wcy5hbm5vdGF0aW9uTGF5ZXIuY2hpbGRyZW4pKTsgfTtcbiAgICB2YXIgcmVuZGVyUGFnZUxheWVyID0gcmVuZGVyUGFnZSB8fCBkZWZhdWx0UGFnZVJlbmRlcmVyO1xuICAgIHZhciBoYW5kbGVSZW5kZXJDYW52YXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgc2V0Q2FudmFzTGF5ZXJSZW5kZXJlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZVJlbmRlclRleHRDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgc2V0VGV4dExheWVyUmVuZGVyZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0UGFnZShudWxsKTtcbiAgICAgICAgc2V0Q2FudmFzTGF5ZXJSZW5kZXJlZChmYWxzZSk7XG4gICAgICAgIHNldFRleHRMYXllclJlbmRlcmVkKGZhbHNlKTtcbiAgICB9LCBbcGFnZVJvdGF0aW9uLCByb3RhdGlvbiwgc2NhbGVdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW5kZXIgJiYgaXNNb3VudGVkLmN1cnJlbnQgJiYgIXBhZ2UpIHtcbiAgICAgICAgICAgIGRldGVybWluZVBhZ2VJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgfSwgW3Nob3VsZFJlbmRlciwgcGFnZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNhbnZhc0xheWVyUmVuZGVyZWQgJiYgdGV4dExheWVyUmVuZGVyZWQpIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXJRdWV1ZUtleSAhPT0gcmVuZGVyUXVldWVLZXlSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFBhZ2UobnVsbCk7XG4gICAgICAgICAgICAgICAgc2V0Q2FudmFzTGF5ZXJSZW5kZXJlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2V0VGV4dExheWVyUmVuZGVyZWQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25SZW5kZXJDb21wbGV0ZWQocGFnZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjYW52YXNMYXllclJlbmRlcmVkLCB0ZXh0TGF5ZXJSZW5kZXJlZF0pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fcGFnZS1sYXllcic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX3BhZ2UtbGF5ZXItLWR1YWwnOiB2aWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fcGFnZS1sYXllci0tZHVhbC1jb3Zlcic6IHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19wYWdlLWxheWVyLS1zaW5nbGUnOiB2aWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5TaW5nbGVQYWdlLFxuICAgICAgICB9KSwgXCJkYXRhLXRlc3RpZFwiOiBcImNvcmVfX3BhZ2UtbGF5ZXItXCIuY29uY2F0KHBhZ2VJbmRleCksIHJlZjogbWVhc3VyZVJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaCwgXCJweFwiKSxcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3LCBcInB4XCIpLFxuICAgICAgICB9IH0sICFwYWdlID8gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChTcGlubmVyLCB7IHRlc3RJZDogXCJjb3JlX19wYWdlLWxheWVyLWxvYWRpbmctXCIuY29uY2F0KHBhZ2VJbmRleCkgfSkpIDogKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICByZW5kZXJQYWdlTGF5ZXIoe1xuICAgICAgICAgICAgYW5ub3RhdGlvbkxheWVyOiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb25MYXllciwgeyBkb2M6IGRvYywgb3V0bGluZXM6IG91dGxpbmVzLCBwYWdlOiBwYWdlLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgcGx1Z2luczogcGx1Z2lucywgcm90YXRpb246IHJvdGF0aW9uVmFsdWUsIHNjYWxlOiBzY2FsZSwgb25FeGVjdXRlTmFtZWRBY3Rpb246IG9uRXhlY3V0ZU5hbWVkQWN0aW9uLCBvbkp1bXBGcm9tTGlua0Fubm90YXRpb246IG9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbiwgb25KdW1wVG9EZXN0OiBvbkp1bXBUb0Rlc3QgfSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbnZhc0xheWVyOiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KENhbnZhc0xheWVyLCB7IGNhbnZhc0xheWVyUmVmOiBjYW52YXNMYXllclJlZiwgaGVpZ2h0OiBoLCBwYWdlOiBwYWdlLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgcGx1Z2luczogcGx1Z2lucywgcm90YXRpb246IHJvdGF0aW9uVmFsdWUsIHNjYWxlOiBzY2FsZSwgd2lkdGg6IHcsIG9uUmVuZGVyQ2FudmFzQ29tcGxldGVkOiBoYW5kbGVSZW5kZXJDYW52YXNDb21wbGV0ZWQgfSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbnZhc0xheWVyUmVuZGVyZWQ6IGNhbnZhc0xheWVyUmVuZGVyZWQsXG4gICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uVmFsdWUsXG4gICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICBzdmdMYXllcjoge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChTdmdMYXllciwgeyBoZWlnaHQ6IGgsIHBhZ2U6IHBhZ2UsIHJvdGF0aW9uOiByb3RhdGlvblZhbHVlLCBzY2FsZTogc2NhbGUsIHdpZHRoOiB3IH0pKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0TGF5ZXI6IHtcbiAgICAgICAgICAgICAgICBhdHRyczoge30sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoVGV4dExheWVyLCB7IGNvbnRhaW5lclJlZjogdGV4dExheWVyUmVmLCBwYWdlOiBwYWdlLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgcGx1Z2luczogcGx1Z2lucywgcm90YXRpb246IHJvdGF0aW9uVmFsdWUsIHNjYWxlOiBzY2FsZSwgb25SZW5kZXJUZXh0Q29tcGxldGVkOiBoYW5kbGVSZW5kZXJUZXh0Q29tcGxldGVkIH0pKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0TGF5ZXJSZW5kZXJlZDogdGV4dExheWVyUmVuZGVyZWQsXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIG1hcmtSZW5kZXJlZDogb25SZW5kZXJDb21wbGV0ZWQsXG4gICAgICAgICAgICBvblJvdGF0ZVBhZ2U6IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHsgcmV0dXJuIG9uUm90YXRlUGFnZShwYWdlSW5kZXgsIGRpcmVjdGlvbik7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBwbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW4ucmVuZGVyUGFnZUxheWVyID8gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCB7IGtleTogaWR4IH0sIHBsdWdpbi5yZW5kZXJQYWdlTGF5ZXIoe1xuICAgICAgICAgICAgICAgIGNhbnZhc0xheWVyUmVmOiBjYW52YXNMYXllclJlZixcbiAgICAgICAgICAgICAgICBjYW52YXNMYXllclJlbmRlcmVkOiBjYW52YXNMYXllclJlbmRlcmVkLFxuICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgdGV4dExheWVyUmVmOiB0ZXh0TGF5ZXJSZWYsXG4gICAgICAgICAgICAgICAgdGV4dExheWVyUmVuZGVyZWQ6IHRleHRMYXllclJlbmRlcmVkLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgfSkpKSA6IChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgeyBrZXk6IGlkeCB9KSk7XG4gICAgICAgIH0pKSkpKTtcbn07XG5cbnZhciBnZXRGaWxlRXh0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHZhciBzdHIgPSB1cmwuc3BsaXQoL1xcLi8pLnBvcCgpO1xuICAgIHJldHVybiBzdHIgPyBzdHIudG9Mb3dlckNhc2UoKSA6ICcnO1xufTtcblxudmFyIHJlY3RSZWR1Y2VyID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICB2YXIgcmVjdCA9IGFjdGlvbi5yZWN0O1xuICAgIHJldHVybiBzdGF0ZS5oZWlnaHQgIT09IHJlY3QuaGVpZ2h0IHx8IHN0YXRlLndpZHRoICE9PSByZWN0LndpZHRoID8gcmVjdCA6IHN0YXRlO1xufTtcbnZhciB1c2VNZWFzdXJlUmVjdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBlbGVtZW50UmVmID0gX2EuZWxlbWVudFJlZjtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGVsZW1lbnRSZWYuY3VycmVudCksIGVsZW1lbnQgPSBfYlswXSwgc2V0RWxlbWVudCA9IF9iWzFdO1xuICAgIHZhciBpbml0aWFsaXplZFJlY3RSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihmYWxzZSk7XG4gICAgdmFyIF9jID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWR1Y2VyKHJlY3RSZWR1Y2VyLCB7IGhlaWdodDogMCwgd2lkdGg6IDAgfSksIHJlY3QgPSBfY1swXSwgZGlzcGF0Y2ggPSBfY1sxXTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgc2V0RWxlbWVudChlbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICFpbml0aWFsaXplZFJlY3RSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZWRSZWN0UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9hID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHJlY3Q6IHsgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNrZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMsIF9fKSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbnRyeS5jb250ZW50UmVjdCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7IGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGggfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFja2VyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFja2VyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIHJldHVybiByZWN0O1xufTtcblxudmFyIFNjcm9sbERpcmVjdGlvbjtcbihmdW5jdGlvbiAoU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgU2Nyb2xsRGlyZWN0aW9uW1wiSG9yaXpvbnRhbFwiXSA9IFwiSG9yaXpvbnRhbFwiO1xuICAgIFNjcm9sbERpcmVjdGlvbltcIlZlcnRpY2FsXCJdID0gXCJWZXJ0aWNhbFwiO1xuICAgIFNjcm9sbERpcmVjdGlvbltcIkJvdGhcIl0gPSBcIkJvdGhcIjtcbn0pKFNjcm9sbERpcmVjdGlvbiB8fCAoU2Nyb2xsRGlyZWN0aW9uID0ge30pKTtcblxudmFyIGVhc2VPdXRRdWFydCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDQpOyB9O1xuXG52YXIgRVBTID0gMC4wMDAxO1xudmFyIHNtb290aFNjcm9sbCA9IGZ1bmN0aW9uIChlbGUsIHNjcm9sbERpcmVjdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGR1cmF0aW9uLCBlYXNpbmcsIG9uUmVhY2hUYXJnZXQpIHtcbiAgICBpZiAoZWFzaW5nID09PSB2b2lkIDApIHsgZWFzaW5nID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07IH1cbiAgICBpZiAob25SZWFjaFRhcmdldCA9PT0gdm9pZCAwKSB7IG9uUmVhY2hUYXJnZXQgPSBmdW5jdGlvbiAoKSB7IH07IH1cbiAgICB2YXIgdG9wID0gMDtcbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgdmFyIHJlYWNoVGFyZ2V0ID0gZmFsc2U7XG4gICAgc3dpdGNoIChzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbDpcbiAgICAgICAgICAgIGxlZnQgPSBlbGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkJvdGg6XG4gICAgICAgICAgICBsZWZ0ID0gZWxlLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB0b3AgPSBlbGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLlZlcnRpY2FsOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICB0b3AgPSBlbGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtYXJrVGFyZ2V0UmVhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZWFjaFRhcmdldCkge1xuICAgICAgICAgICAgcmVhY2hUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgZWxlLnNjcm9sbExlZnQgPSB0YXJnZXRQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgZWxlLnNjcm9sbFRvcCA9IHRhcmdldFBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgIG9uUmVhY2hUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKE1hdGguYWJzKHRvcCAtIHRhcmdldFBvc2l0aW9uLnRvcCkgPD0gRVBTICYmIHNjcm9sbERpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLlZlcnRpY2FsKSB7XG4gICAgICAgIG1hcmtUYXJnZXRSZWFjaGVkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGxlZnQgLSB0YXJnZXRQb3NpdGlvbi5sZWZ0KSA8PSBFUFMgJiYgc2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbCkge1xuICAgICAgICBtYXJrVGFyZ2V0UmVhY2hlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFydFRpbWUgPSAtMTtcbiAgICB2YXIgcmVxdWVzdElkO1xuICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IGxlZnQgLSB0YXJnZXRQb3NpdGlvbi5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIHRhcmdldFBvc2l0aW9uLnRvcCxcbiAgICB9O1xuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IC0xKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZSA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICB2YXIgcGVyY2VudCA9IE1hdGgubWluKHRpbWUgLyBkdXJhdGlvbiwgMSk7XG4gICAgICAgIHZhciBlYXNlZFBlcmNlbnQgPSBlYXNpbmcocGVyY2VudCk7XG4gICAgICAgIHZhciB1cGRhdGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSBvZmZzZXQubGVmdCAqIGVhc2VkUGVyY2VudCxcbiAgICAgICAgICAgIHRvcDogdG9wIC0gb2Zmc2V0LnRvcCAqIGVhc2VkUGVyY2VudCxcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgZWxlLnNjcm9sbExlZnQgPSB1cGRhdGVQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uQm90aDpcbiAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsTGVmdCA9IHVwZGF0ZVBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICAgICAgZWxlLnNjcm9sbFRvcCA9IHVwZGF0ZVBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLlZlcnRpY2FsOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsVG9wID0gdXBkYXRlUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyh1cGRhdGVQb3NpdGlvbi50b3AgLSB0YXJnZXRQb3NpdGlvbi50b3ApIDw9IEVQUyAmJlxuICAgICAgICAgICAgTWF0aC5hYnModXBkYXRlUG9zaXRpb24ubGVmdCAtIHRhcmdldFBvc2l0aW9uLmxlZnQpIDw9IEVQUyAmJlxuICAgICAgICAgICAgIXJlYWNoVGFyZ2V0KSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIG1hcmtUYXJnZXRSZWFjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgcmVxdWVzdElkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0SWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xufTtcblxudmFyIFpFUk9fT0ZGU0VUJDYgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIFNDUk9MTF9FVkVOVF9PUFRJT05TID0ge1xuICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgIHBhc3NpdmU6IHRydWUsXG59O1xudmFyIFNDUk9MTF9EVVJBVElPTiA9IDQwMDtcbnZhciB1c2VTY3JvbGwgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZWxlbWVudFJlZiA9IF9hLmVsZW1lbnRSZWYsIGVuYWJsZVNtb290aFNjcm9sbCA9IF9hLmVuYWJsZVNtb290aFNjcm9sbCwgaXNSdGwgPSBfYS5pc1J0bCwgc2Nyb2xsRGlyZWN0aW9uID0gX2Euc2Nyb2xsRGlyZWN0aW9uLCBvblNtb290aFNjcm9sbCA9IF9hLm9uU21vb3RoU2Nyb2xsO1xuICAgIHZhciBfYiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoWkVST19PRkZTRVQkNiksIHNjcm9sbE9mZnNldCA9IF9iWzBdLCBzZXRTY3JvbGxPZmZzZXQgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGVsZW1lbnRSZWYuY3VycmVudCksIGVsZW1lbnQgPSBfY1swXSwgc2V0RWxlbWVudCA9IF9jWzFdO1xuICAgIHZhciBmYWN0b3IgPSBpc1J0bCA/IC0xIDogMTtcbiAgICB2YXIgbGF0ZXN0UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoc2Nyb2xsRGlyZWN0aW9uKTtcbiAgICBsYXRlc3RSZWYuY3VycmVudCA9IHNjcm9sbERpcmVjdGlvbjtcbiAgICB2YXIgbGF0ZXN0T2Zmc2V0UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoWkVST19PRkZTRVQkNik7XG4gICAgdmFyIGlzU21vb3RoU2Nyb2xsaW5nRG9uZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHRydWUpO1xuICAgIHZhciBoYW5kbGVTbW9vdGhTY3JvbGxpbmdDb21wbGV0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpc1Ntb290aFNjcm9sbGluZ0RvbmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGlmIChlbmFibGVTbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgICAgIHNldFNjcm9sbE9mZnNldChsYXRlc3RPZmZzZXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgb25TbW9vdGhTY3JvbGwoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgaGFuZGxlU2Nyb2xsID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobGF0ZXN0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2Zmc2V0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhY3RvciAqIGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Cb3RoOlxuICAgICAgICAgICAgICAgIGxhdGVzdE9mZnNldFJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmYWN0b3IgKiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogZWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLlZlcnRpY2FsOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsYXRlc3RPZmZzZXRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5hYmxlU21vb3RoU2Nyb2xsIHx8IGlzU21vb3RoU2Nyb2xsaW5nRG9uZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTY3JvbGxPZmZzZXQobGF0ZXN0T2Zmc2V0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgW2VsZW1lbnRdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0RWxlbWVudChlbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCwgU0NST0xMX0VWRU5UX09QVElPTlMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwsIFNDUk9MTF9FVkVOVF9PUFRJT05TKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIHZhciBzY3JvbGxUbyA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRhcmdldFBvc2l0aW9uLCB3aXRoU21vb3RoU2Nyb2xsKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChsYXRlc3RSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbDpcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbi5sZWZ0ID0gZmFjdG9yICogdGFyZ2V0UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkJvdGg6XG4gICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24ubGVmdCA9IGZhY3RvciAqIHRhcmdldFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24udG9wID0gdGFyZ2V0UG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uLnRvcCA9IHRhcmdldFBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAod2l0aFNtb290aFNjcm9sbCkge1xuICAgICAgICAgICAgaXNTbW9vdGhTY3JvbGxpbmdEb25lUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uU21vb3RoU2Nyb2xsKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCBfKSB7XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsKGVsZSwgbGF0ZXN0UmVmLmN1cnJlbnQsIHVwZGF0ZVBvc2l0aW9uLCBTQ1JPTExfRFVSQVRJT04sIGVhc2VPdXRRdWFydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTbW9vdGhTY3JvbGxpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIF8pIHtcbiAgICAgICAgICAgIHN3aXRjaCAobGF0ZXN0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsTGVmdCA9IHVwZGF0ZVBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkJvdGg6XG4gICAgICAgICAgICAgICAgICAgIGVsZS5zY3JvbGxMZWZ0ID0gdXBkYXRlUG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZWxlLnNjcm9sbFRvcCA9IHVwZGF0ZVBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZWxlLnNjcm9sbFRvcCA9IHVwZGF0ZVBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtlbGVtZW50UmVmXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0OiBzY3JvbGxPZmZzZXQsXG4gICAgICAgIHNjcm9sbFRvOiBzY3JvbGxUbyxcbiAgICB9O1xufTtcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB2YWx1ZSkgeyByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7IH07XG5cbnZhciBpbmRleE9mTWF4ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyciwgaSwgYSkgeyByZXR1cm4gKGN1cnIgPiBhW3ByZXZdID8gaSA6IHByZXYpOyB9LCAwKTsgfTtcblxudmFyIGJ1aWxkQ29udGFpbmVyU3R5bGVzID0gZnVuY3Rpb24gKHRvdGFsU2l6ZSwgc2Nyb2xsTW9kZSkge1xuICAgIHN3aXRjaCAoc2Nyb2xsTW9kZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQodG90YWxTaXplLndpZHRoLCBcInB4XCIpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWw6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQodG90YWxTaXplLmhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59O1xuXG52YXIgYnVpbGRJdGVtQ29udGFpbmVyU3R5bGVzID0gZnVuY3Rpb24gKGl0ZW0sIHBhcmVudFJlY3QsIHNjcm9sbE1vZGUpIHtcbiAgICByZXR1cm4gc2Nyb2xsTW9kZSAhPT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2VcbiAgICAgICAgPyB7fVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQocGFyZW50UmVjdC5oZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWShcIi5jb25jYXQoaXRlbS5zdGFydC50b3AsIFwicHgpXCIpLFxuICAgICAgICB9O1xufTtcblxudmFyIGhhc0RpZmZlcmVudFNpemVzID0gZnVuY3Rpb24gKHNpemVzKSB7XG4gICAgdmFyIG51bWJlck9mSXRlbXMgPSBzaXplcy5sZW5ndGg7XG4gICAgaWYgKG51bWJlck9mSXRlbXMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bWJlck9mSXRlbXM7IGkrKykge1xuICAgICAgICBpZiAoc2l6ZXNbaV0uaGVpZ2h0ICE9PSBzaXplc1swXS5oZWlnaHQgfHwgc2l6ZXNbaV0ud2lkdGggIT09IHNpemVzWzBdLndpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGdldE1pbldpZHRoT2ZDb3ZlciA9IGZ1bmN0aW9uIChzaXplcywgdmlld01vZGUpIHtcbiAgICBpZiAodmlld01vZGUgIT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghaGFzRGlmZmVyZW50U2l6ZXMoc2l6ZXMpKSB7XG4gICAgICAgIHJldHVybiAyICogc2l6ZXNbMF0ud2lkdGg7XG4gICAgfVxuICAgIHZhciBjaHVua1dpZHRocyA9IGNodW5rKHNpemVzLnNsaWNlKDEpLCAyKS5tYXAoZnVuY3Rpb24gKGVhY2hDaHVuaykge1xuICAgICAgICByZXR1cm4gZWFjaENodW5rLmxlbmd0aCA9PT0gMiA/IGVhY2hDaHVua1swXS53aWR0aCArIGVhY2hDaHVua1sxXS53aWR0aCA6IGVhY2hDaHVua1swXS53aWR0aDtcbiAgICB9KTtcbiAgICB2YXIgd2lkdGhzID0gW3NpemVzWzBdLndpZHRoXS5jb25jYXQoY2h1bmtXaWR0aHMpO1xuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCB3aWR0aHMpO1xufTtcbnZhciBidWlsZEl0ZW1TdHlsZXMgPSBmdW5jdGlvbiAoaXRlbSwgaXNSdGwsIHNpemVzLCB2aWV3TW9kZSwgc2Nyb2xsTW9kZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICB2YXIgc2lkZVByb3BlcnR5ID0gaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIHZhciBmYWN0b3IgPSBpc1J0bCA/IC0xIDogMTtcbiAgICB2YXIgbnVtYmVyT2ZJdGVtcyA9IHNpemVzLmxlbmd0aDtcbiAgICB2YXIgbGVmdCA9IGl0ZW0uc3RhcnQubGVmdCAqIGZhY3RvcjtcbiAgICB2YXIgX2ggPSBpdGVtLnNpemUsIGhlaWdodCA9IF9oLmhlaWdodCwgd2lkdGggPSBfaC53aWR0aDtcbiAgICBpZiAodmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVRvcCA9IHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlID8gMCA6IGl0ZW0uc3RhcnQudG9wO1xuICAgICAgICBpZiAoaXRlbS5pbmRleCA9PT0gMCB8fCAobnVtYmVyT2ZJdGVtcyAlIDIgPT09IDAgJiYgaXRlbS5pbmRleCA9PT0gbnVtYmVyT2ZJdGVtcyAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gX2EgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogXCJcIi5jb25jYXQoZ2V0TWluV2lkdGhPZkNvdmVyKHNpemVzLCB2aWV3TW9kZSksIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9hW3NpZGVQcm9wZXJ0eV0gPSAwLFxuICAgICAgICAgICAgICAgIF9hLnBvc2l0aW9uID0gJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBfYS50b3AgPSAwLFxuICAgICAgICAgICAgICAgIF9hLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChsZWZ0LCBcInB4LCBcIikuY29uY2F0KHRyYW5zZm9ybVRvcCwgXCJweClcIiksXG4gICAgICAgICAgICAgICAgX2E7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9iID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iW3NpZGVQcm9wZXJ0eV0gPSAwLFxuICAgICAgICAgICAgX2IucG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgX2IudG9wID0gMCxcbiAgICAgICAgICAgIF9iLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChsZWZ0LCBcInB4LCBcIikuY29uY2F0KHRyYW5zZm9ybVRvcCwgXCJweClcIiksXG4gICAgICAgICAgICBfYjtcbiAgICB9XG4gICAgaWYgKHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlKSB7XG4gICAgICAgIHJldHVybiBfYyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY1tzaWRlUHJvcGVydHldID0gMCxcbiAgICAgICAgICAgIF9jLnBvc2l0aW9uID0gJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIF9jLnRvcCA9IDAsXG4gICAgICAgICAgICBfYy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQobGVmdCwgXCJweCwgXCIpLmNvbmNhdChzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSA/IDAgOiBpdGVtLnN0YXJ0LnRvcCwgXCJweClcIiksXG4gICAgICAgICAgICBfYztcbiAgICB9XG4gICAgc3dpdGNoIChzY3JvbGxNb2RlKSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICByZXR1cm4gX2QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9kW3NpZGVQcm9wZXJ0eV0gPSAwLFxuICAgICAgICAgICAgICAgIF9kLnBvc2l0aW9uID0gJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBfZC50b3AgPSAwLFxuICAgICAgICAgICAgICAgIF9kLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWChcIi5jb25jYXQobGVmdCwgXCJweClcIiksXG4gICAgICAgICAgICAgICAgX2Q7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2U6XG4gICAgICAgICAgICByZXR1cm4gX2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lW3NpZGVQcm9wZXJ0eV0gPSAwLFxuICAgICAgICAgICAgICAgIF9lLnBvc2l0aW9uID0gJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBfZS50b3AgPSAwLFxuICAgICAgICAgICAgICAgIF9lO1xuICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5XcmFwcGVkOlxuICAgICAgICAgICAgcmV0dXJuIF9mID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZltzaWRlUHJvcGVydHldID0gMCxcbiAgICAgICAgICAgICAgICBfZi5wb3NpdGlvbiA9ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgX2YudG9wID0gMCxcbiAgICAgICAgICAgICAgICBfZi50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQobGVmdCwgXCJweCwgXCIpLmNvbmNhdChpdGVtLnN0YXJ0LnRvcCwgXCJweClcIiksXG4gICAgICAgICAgICAgICAgX2Y7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLlZlcnRpY2FsOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIF9nID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2dbc2lkZVByb3BlcnR5XSA9IDAsXG4gICAgICAgICAgICAgICAgX2cucG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIF9nLnRvcCA9IDAsXG4gICAgICAgICAgICAgICAgX2cudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdChpdGVtLnN0YXJ0LnRvcCwgXCJweClcIiksXG4gICAgICAgICAgICAgICAgX2c7XG4gICAgfVxufTtcblxudmFyIGZpbmROZWFyZXN0ID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgdmFsdWUsIGdldEl0ZW1WYWx1ZSkge1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICB2YXIgbWlkZGxlID0gKChsb3cgKyBoaWdoKSAvIDIpIHwgMDtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGdldEl0ZW1WYWx1ZShtaWRkbGUpO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93ID4gMCA/IGxvdyAtIDEgOiAwO1xufTtcblxudmFyIGNhbGN1bGF0ZVJhbmdlID0gZnVuY3Rpb24gKHNjcm9sbERpcmVjdGlvbiwgbWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCkge1xuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gMDtcbiAgICBzd2l0Y2ggKHNjcm9sbERpcmVjdGlvbikge1xuICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgY3VycmVudE9mZnNldCA9IHNjcm9sbE9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLlZlcnRpY2FsOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY3VycmVudE9mZnNldCA9IHNjcm9sbE9mZnNldC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHNpemUgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHN3aXRjaCAoc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0LmxlZnQ7XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Cb3RoOlxuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0LnRvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0YXJ0ID0gZmluZE5lYXJlc3QoMCwgc2l6ZSwgY3VycmVudE9mZnNldCwgZ2V0T2Zmc2V0KTtcbiAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uQm90aCkge1xuICAgICAgICB2YXIgc3RhcnRUb3AgPSBtZWFzdXJlbWVudHNbc3RhcnRdLnN0YXJ0LnRvcDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0IC0gMSA+PSAwICYmXG4gICAgICAgICAgICBtZWFzdXJlbWVudHNbc3RhcnQgLSAxXS5zdGFydC50b3AgPT09IHN0YXJ0VG9wICYmXG4gICAgICAgICAgICBtZWFzdXJlbWVudHNbc3RhcnQgLSAxXS5zdGFydC5sZWZ0ID49IHNjcm9sbE9mZnNldC5sZWZ0KSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBlbmQgPSBzdGFydDtcbiAgICB3aGlsZSAoZW5kIDw9IHNpemUpIHtcbiAgICAgICAgdmFyIHRvcExlZnRDb3JuZXIgPSB7XG4gICAgICAgICAgICB0b3A6IG1lYXN1cmVtZW50c1tlbmRdLnN0YXJ0LnRvcCAtIHNjcm9sbE9mZnNldC50b3AsXG4gICAgICAgICAgICBsZWZ0OiBtZWFzdXJlbWVudHNbZW5kXS5zdGFydC5sZWZ0IC0gc2Nyb2xsT2Zmc2V0LmxlZnQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2aXNpYmxlU2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogb3V0ZXJTaXplLmhlaWdodCAtIHRvcExlZnRDb3JuZXIudG9wLFxuICAgICAgICAgICAgd2lkdGg6IG91dGVyU2l6ZS53aWR0aCAtIHRvcExlZnRDb3JuZXIubGVmdCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjcm9sbERpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLkhvcml6b250YWwgJiYgdmlzaWJsZVNpemUud2lkdGggPCAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWwgJiYgdmlzaWJsZVNpemUuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbERpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLkJvdGggJiYgKHZpc2libGVTaXplLndpZHRoIDwgMCB8fCB2aXNpYmxlU2l6ZS5oZWlnaHQgPCAwKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZW5kKys7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgfTtcbn07XG5cbnZhciBaRVJPX09GRlNFVCQ1ID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxufTtcbnZhciBtZWFzdXJlID0gZnVuY3Rpb24gKG51bWJlck9mSXRlbXMsIHBhcmVudFJlY3QsIHNpemVzLCBzY3JvbGxNb2RlKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IFtdO1xuICAgIHZhciB0b3RhbFdpZHRoID0gMDtcbiAgICB2YXIgZmlyc3RPZlJvdyA9IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgIH07XG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gWkVST19PRkZTRVQkNTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSXRlbXM7IGkrKykge1xuICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2ldO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdG90YWxXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBmaXJzdE9mUm93ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChzY3JvbGxNb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuV3JhcHBlZDpcbiAgICAgICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCA8IHBhcmVudFJlY3Qud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1lYXN1cmVtZW50c1tpIC0gMV0uZW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBmaXJzdE9mUm93LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmlyc3RPZlJvdy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZmlyc3RPZlJvdy50b3AgKyBtYXhIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RPZlJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzdGFydC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogc3RhcnQudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWw6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZWFzdXJlbWVudHNbaSAtIDFdLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0LmxlZnQgKyBzaXplLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBzdGFydC50b3AgKyBzaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiAtMSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbn07XG5cbnZhciBaRVJPX09GRlNFVCQ0ID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxufTtcbnZhciBtZWFzdXJlRHVhbFBhZ2UgPSBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcywgcGFyZW50UmVjdCwgc2l6ZXMsIHNjcm9sbE1vZGUpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnRzID0gW107XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gWkVST19PRkZTRVQkNDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSXRlbXM7IGkrKykge1xuICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UgPyBNYXRoLm1heChwYXJlbnRSZWN0LmhlaWdodCwgc2l6ZXNbaV0uaGVpZ2h0KSA6IHNpemVzW2ldLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heChwYXJlbnRSZWN0LndpZHRoIC8gMiwgc2l6ZXNbaV0ud2lkdGgpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGkgJSAyID09PSAwID8gMCA6IHNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmZsb29yKGkgLyAyKSAqIHNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRvcCArIG1heEhlaWdodDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBpID09PSBudW1iZXJPZkl0ZW1zIC0gMSA/IHNpemVzW2ldLmhlaWdodCA6IE1hdGgubWF4KHNpemVzW2ldLmhlaWdodCwgc2l6ZXNbaSArIDFdLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWVhc3VyZW1lbnRzW2kgLSAxXS5lbmQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0ge1xuICAgICAgICAgICAgbGVmdDogc3RhcnQubGVmdCArIHNpemUud2lkdGgsXG4gICAgICAgICAgICB0b3A6IHN0YXJ0LnRvcCArIHNpemUuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBtZWFzdXJlbWVudHNbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IC0xLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xufTtcblxudmFyIFpFUk9fT0ZGU0VUJDMgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIG1lYXN1cmVEdWFsUGFnZVdpdGhDb3ZlciA9IGZ1bmN0aW9uIChudW1iZXJPZkl0ZW1zLCBwYXJlbnRSZWN0LCBzaXplcywgc2Nyb2xsTW9kZSkge1xuICAgIHZhciBtZWFzdXJlbWVudHMgPSBbXTtcbiAgICB2YXIgdG9wID0gMDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcbiAgICB2YXIgc3RhcnQgPSBaRVJPX09GRlNFVCQzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgICAgIHZhciBzaXplID0gaSA9PT0gMFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZVxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KHBhcmVudFJlY3QuaGVpZ2h0LCBzaXplc1tpXS5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIDogc2l6ZXNbaV0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSA/IE1hdGgubWF4KHBhcmVudFJlY3Qud2lkdGgsIHNpemVzW2ldLndpZHRoKSA6IHNpemVzW2ldLndpZHRoLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZVxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KHBhcmVudFJlY3QuaGVpZ2h0LCBzaXplc1tpXS5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIDogc2l6ZXNbaV0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heChwYXJlbnRSZWN0LndpZHRoIC8gMiwgc2l6ZXNbaV0ud2lkdGgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlKSB7XG4gICAgICAgICAgICBzdGFydCA9XG4gICAgICAgICAgICAgICAgaSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IFpFUk9fT0ZGU0VUJDNcbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBpICUgMiA9PT0gMCA/IHNpemUud2lkdGggOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBNYXRoLmZsb29yKChpIC0gMSkgLyAyKSAqIHNpemUuaGVpZ2h0ICsgbWVhc3VyZW1lbnRzWzBdLmVuZC50b3AsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gWkVST19PRkZTRVQkMztcbiAgICAgICAgICAgICAgICB0b3AgPSBzaXplc1swXS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gdG9wICsgbWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGkgPT09IG51bWJlck9mSXRlbXMgLSAxID8gc2l6ZXNbaV0uaGVpZ2h0IDogTWF0aC5tYXgoc2l6ZXNbaV0uaGVpZ2h0LCBzaXplc1tpICsgMV0uaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtZWFzdXJlbWVudHNbaSAtIDFdLmVuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlbmQgPSB7XG4gICAgICAgICAgICBsZWZ0OiBzdGFydC5sZWZ0ICsgc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHRvcDogc3RhcnQudG9wICsgc2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogLTEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG59O1xuXG52YXIgWkVST19PRkZTRVQkMiA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbn07XG52YXIgbWVhc3VyZVNpbmdsZVBhZ2UgPSBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcywgcGFyZW50UmVjdCwgc2l6ZXMpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICAgICAgdmFyIHNpemUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KHBhcmVudFJlY3QuaGVpZ2h0LCBzaXplc1tpXS5oZWlnaHQpLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHBhcmVudFJlY3Qud2lkdGgsIHNpemVzW2ldLndpZHRoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaSA9PT0gMCA/IFpFUk9fT0ZGU0VUJDIgOiBtZWFzdXJlbWVudHNbaSAtIDFdLmVuZDtcbiAgICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0LmxlZnQgKyBzaXplLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBzdGFydC50b3AgKyBzaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiAtMSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbn07XG5cbnZhciBaRVJPX1JFQ1QkMiA9IHtcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG59O1xudmFyIFpFUk9fT0ZGU0VUJDEgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIENPTVBBUkVfRVBTSUxPTiA9IDAuMDAwMDAwMDAwMDAxO1xudmFyIFZJUlRVQUxfSU5ERVhfQVRUUiA9ICdkYXRhLXZpcnR1YWwtaW5kZXgnO1xudmFyIElPX1RIUkVTSE9MRCA9IFswLCAwLjEsIDAuMiwgMC4zLCAwLjQsIDAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxXTtcbnZhciB1c2VWaXJ0dWFsID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGVuYWJsZVNtb290aFNjcm9sbCA9IF9hLmVuYWJsZVNtb290aFNjcm9sbCwgaXNSdGwgPSBfYS5pc1J0bCwgbnVtYmVyT2ZJdGVtcyA9IF9hLm51bWJlck9mSXRlbXMsIHBhcmVudFJlZiA9IF9hLnBhcmVudFJlZiwgc2V0UmVuZGVyUmFuZ2UgPSBfYS5zZXRSZW5kZXJSYW5nZSwgc2l6ZXMgPSBfYS5zaXplcywgc2Nyb2xsTW9kZSA9IF9hLnNjcm9sbE1vZGUsIHZpZXdNb2RlID0gX2Eudmlld01vZGU7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIGlzU21vb3RoU2Nyb2xsaW5nID0gX2JbMF0sIHNldFNtb290aFNjcm9sbGluZyA9IF9iWzFdO1xuICAgIHZhciBvblNtb290aFNjcm9sbCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlzU21vb3RoU2Nyb2xsaW5nKSB7IHJldHVybiBzZXRTbW9vdGhTY3JvbGxpbmcoaXNTbW9vdGhTY3JvbGxpbmcpOyB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbE1vZGVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihzY3JvbGxNb2RlKTtcbiAgICBzY3JvbGxNb2RlUmVmLmN1cnJlbnQgPSBzY3JvbGxNb2RlO1xuICAgIHZhciB2aWV3TW9kZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHZpZXdNb2RlKTtcbiAgICB2aWV3TW9kZVJlZi5jdXJyZW50ID0gdmlld01vZGU7XG4gICAgdmFyIHNjcm9sbERpcmVjdGlvbiA9IHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5XcmFwcGVkIHx8IHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyIHx8IHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlXG4gICAgICAgID8gU2Nyb2xsRGlyZWN0aW9uLkJvdGhcbiAgICAgICAgOiBzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuSG9yaXpvbnRhbFxuICAgICAgICAgICAgPyBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbFxuICAgICAgICAgICAgOiBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw7XG4gICAgdmFyIF9jID0gdXNlU2Nyb2xsKHtcbiAgICAgICAgZWxlbWVudFJlZjogcGFyZW50UmVmLFxuICAgICAgICBlbmFibGVTbW9vdGhTY3JvbGw6IGVuYWJsZVNtb290aFNjcm9sbCxcbiAgICAgICAgaXNSdGw6IGlzUnRsLFxuICAgICAgICBzY3JvbGxEaXJlY3Rpb246IHNjcm9sbERpcmVjdGlvbixcbiAgICAgICAgb25TbW9vdGhTY3JvbGw6IG9uU21vb3RoU2Nyb2xsLFxuICAgIH0pLCBzY3JvbGxPZmZzZXQgPSBfYy5zY3JvbGxPZmZzZXQsIHNjcm9sbFRvID0gX2Muc2Nyb2xsVG87XG4gICAgdmFyIHBhcmVudFJlY3QgPSB1c2VNZWFzdXJlUmVjdCh7XG4gICAgICAgIGVsZW1lbnRSZWY6IHBhcmVudFJlZixcbiAgICB9KTtcbiAgICB2YXIgbGF0ZXN0UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe1xuICAgICAgICBzY3JvbGxPZmZzZXQ6IFpFUk9fT0ZGU0VUJDEsXG4gICAgICAgIG1lYXN1cmVtZW50czogW10sXG4gICAgfSk7XG4gICAgbGF0ZXN0UmVmLmN1cnJlbnQuc2Nyb2xsT2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0O1xuICAgIHZhciBkZWZhdWx0VmlzaWJpbGl0aWVzID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KG51bWJlck9mSXRlbXMpLmZpbGwoLTEpOyB9LCBbXSk7XG4gICAgdmFyIF9kID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShkZWZhdWx0VmlzaWJpbGl0aWVzKSwgdmlzaWJpbGl0aWVzID0gX2RbMF0sIHNldFZpc2liaWxpdGllcyA9IF9kWzFdO1xuICAgIHZhciBpbnRlcnNlY3Rpb25UcmFja2VyID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgPyBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA6IC0xO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbnRyeS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QXR0cmlidXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShWSVJUVUFMX0lOREVYX0FUVFIpO1xuICAgICAgICAgICAgICAgIGlmICghaW5kZXhBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChpbmRleEF0dHJpYnV0ZSwgMTApO1xuICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgbnVtYmVyT2ZJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBzZXRWaXNpYmlsaXRpZXMoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkW2luZGV4XSA9IHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW10sIG9sZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aHJlc2hvbGQ6IElPX1RIUkVTSE9MRCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbztcbiAgICB9LCBbXSk7XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSAmJiB2aWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5TaW5nbGVQYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVhc3VyZVNpbmdsZVBhZ2UobnVtYmVyT2ZJdGVtcywgcGFyZW50UmVjdCwgc2l6ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVEdWFsUGFnZVdpdGhDb3ZlcihudW1iZXJPZkl0ZW1zLCBwYXJlbnRSZWN0LCBzaXplcywgc2Nyb2xsTW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVhc3VyZUR1YWxQYWdlKG51bWJlck9mSXRlbXMsIHBhcmVudFJlY3QsIHNpemVzLCBzY3JvbGxNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVhc3VyZShudW1iZXJPZkl0ZW1zLCBwYXJlbnRSZWN0LCBzaXplcywgc2Nyb2xsTW9kZSk7XG4gICAgfSwgW3Njcm9sbE1vZGUsIHNpemVzLCB2aWV3TW9kZSwgcGFyZW50UmVjdF0pO1xuICAgIHZhciB0b3RhbFNpemUgPSBtZWFzdXJlbWVudHNbbnVtYmVyT2ZJdGVtcyAtIDFdXG4gICAgICAgID8ge1xuICAgICAgICAgICAgaGVpZ2h0OiBtZWFzdXJlbWVudHNbbnVtYmVyT2ZJdGVtcyAtIDFdLmVuZC50b3AsXG4gICAgICAgICAgICB3aWR0aDogbWVhc3VyZW1lbnRzW251bWJlck9mSXRlbXMgLSAxXS5lbmQubGVmdCxcbiAgICAgICAgfVxuICAgICAgICA6IFpFUk9fUkVDVCQyO1xuICAgIGxhdGVzdFJlZi5jdXJyZW50Lm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICB2YXIgX2UgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBjYWxjdWxhdGVSYW5nZShzY3JvbGxEaXJlY3Rpb24sIG1lYXN1cmVtZW50cywgcGFyZW50UmVjdCwgc2Nyb2xsT2Zmc2V0KSwgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kO1xuICAgICAgICB2YXIgdmlzaWJsZVBhZ2VWaXNpYmlsaXRpZXMgPSB2aXNpYmlsaXRpZXMuc2xpY2UoY2xhbXAoMCwgbnVtYmVyT2ZJdGVtcywgc3RhcnQpLCBjbGFtcCgwLCBudW1iZXJPZkl0ZW1zLCBlbmQpKTtcbiAgICAgICAgdmFyIG1heFZpc2JpbGl0eUl0ZW0gPSBzdGFydCArIGluZGV4T2ZNYXgodmlzaWJsZVBhZ2VWaXNpYmlsaXRpZXMpO1xuICAgICAgICBtYXhWaXNiaWxpdHlJdGVtID0gY2xhbXAoMCwgbnVtYmVyT2ZJdGVtcyAtIDEsIG1heFZpc2JpbGl0eUl0ZW0pO1xuICAgICAgICB2YXIgbWF4VmlzYmlsaXR5SW5kZXggPSBtYXhWaXNiaWxpdHlJdGVtO1xuICAgICAgICB2YXIgX2IgPSBzZXRSZW5kZXJSYW5nZSh7XG4gICAgICAgICAgICBlbmRQYWdlOiBlbmQsXG4gICAgICAgICAgICBudW1QYWdlczogbnVtYmVyT2ZJdGVtcyxcbiAgICAgICAgICAgIHN0YXJ0UGFnZTogc3RhcnQsXG4gICAgICAgIH0pLCBzdGFydFBhZ2UgPSBfYi5zdGFydFBhZ2UsIGVuZFBhZ2UgPSBfYi5lbmRQYWdlO1xuICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heChzdGFydFBhZ2UsIDApO1xuICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oZW5kUGFnZSwgbnVtYmVyT2ZJdGVtcyAtIDEpO1xuICAgICAgICBzd2l0Y2ggKHZpZXdNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXI6XG4gICAgICAgICAgICAgICAgaWYgKG1heFZpc2JpbGl0eUl0ZW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFZpc2JpbGl0eUluZGV4ID0gbWF4VmlzYmlsaXR5SXRlbSAlIDIgPT09IDEgPyBtYXhWaXNiaWxpdHlJdGVtIDogbWF4VmlzYmlsaXR5SXRlbSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0UGFnZSA9IHN0YXJ0UGFnZSA9PT0gMCA/IDAgOiBzdGFydFBhZ2UgJSAyID09PSAxID8gc3RhcnRQYWdlIDogc3RhcnRQYWdlIC0gMTtcbiAgICAgICAgICAgICAgICBlbmRQYWdlID0gZW5kUGFnZSAlIDIgPT09IDEgPyBlbmRQYWdlIC0gMSA6IGVuZFBhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlck9mSXRlbXMgLSBlbmRQYWdlIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kUGFnZSA9IG51bWJlck9mSXRlbXMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZTpcbiAgICAgICAgICAgICAgICBtYXhWaXNiaWxpdHlJbmRleCA9IG1heFZpc2JpbGl0eUl0ZW0gJSAyID09PSAwID8gbWF4VmlzYmlsaXR5SXRlbSA6IG1heFZpc2JpbGl0eUl0ZW0gLSAxO1xuICAgICAgICAgICAgICAgIHN0YXJ0UGFnZSA9IHN0YXJ0UGFnZSAlIDIgPT09IDAgPyBzdGFydFBhZ2UgOiBzdGFydFBhZ2UgLSAxO1xuICAgICAgICAgICAgICAgIGVuZFBhZ2UgPSBlbmRQYWdlICUgMiA9PT0gMSA/IGVuZFBhZ2UgOiBlbmRQYWdlIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5WaWV3TW9kZS5TaW5nbGVQYWdlOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtYXhWaXNiaWxpdHlJbmRleCA9IG1heFZpc2JpbGl0eUl0ZW07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0UGFnZTogc3RhcnRQYWdlLFxuICAgICAgICAgICAgZW5kUGFnZTogZW5kUGFnZSxcbiAgICAgICAgICAgIG1heFZpc2JpbGl0eUluZGV4OiBtYXhWaXNiaWxpdHlJbmRleCxcbiAgICAgICAgfTtcbiAgICB9LCBbbWVhc3VyZW1lbnRzLCBwYXJlbnRSZWN0LCBzY3JvbGxPZmZzZXQsIHZpZXdNb2RlLCB2aXNpYmlsaXRpZXNdKSwgc3RhcnRQYWdlID0gX2Uuc3RhcnRQYWdlLCBlbmRQYWdlID0gX2UuZW5kUGFnZSwgbWF4VmlzYmlsaXR5SW5kZXggPSBfZS5tYXhWaXNiaWxpdHlJbmRleDtcbiAgICB2YXIgdmlydHVhbEl0ZW1zID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciB2aXJ0dWFsSXRlbSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtKSwgeyB2aXNpYmlsaXR5OiB2aXNpYmlsaXRpZXNbaV0gIT09IHVuZGVmaW5lZCA/IHZpc2liaWxpdGllc1tpXSA6IC0xLCBtZWFzdXJlUmVmOiBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlLnNldEF0dHJpYnV0ZShWSVJUVUFMX0lOREVYX0FUVFIsIFwiXCIuY29uY2F0KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uVHJhY2tlci5vYnNlcnZlKGVsZSk7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgIHZpcnR1YWxJdGVtcy5wdXNoKHZpcnR1YWxJdGVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0UGFnZTsgaSA8PSBlbmRQYWdlOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJdGVtcztcbiAgICB9LCBbc3RhcnRQYWdlLCBlbmRQYWdlLCB2aXNpYmlsaXRpZXMsIG1lYXN1cmVtZW50c10pO1xuICAgIHZhciBzY3JvbGxUb0l0ZW0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtZWFzdXJlbWVudHMgPSBsYXRlc3RSZWYuY3VycmVudC5tZWFzdXJlbWVudHM7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5kZXggPSBjbGFtcCgwLCBudW1iZXJPZkl0ZW1zIC0gMSwgaW5kZXgpO1xuICAgICAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbbm9ybWFsaXplZEluZGV4XTtcbiAgICAgICAgdmFyIHdpdGhPZmZzZXQgPSBzY3JvbGxNb2RlUmVmLmN1cnJlbnQgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlID8gWkVST19PRkZTRVQkMSA6IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50XG4gICAgICAgICAgICA/IHNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB3aXRoT2Zmc2V0LmxlZnQgKyBtZWFzdXJlbWVudC5zdGFydC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogd2l0aE9mZnNldC50b3AgKyBtZWFzdXJlbWVudC5zdGFydC50b3AsXG4gICAgICAgICAgICB9LCBlbmFibGVTbW9vdGhTY3JvbGwpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sIFtzY3JvbGxUbywgZW5hYmxlU21vb3RoU2Nyb2xsXSk7XG4gICAgdmFyIHNjcm9sbFRvU21hbGxlc3RJdGVtQWJvdmUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtZWFzdXJlbWVudHMgPSBsYXRlc3RSZWYuY3VycmVudC5tZWFzdXJlbWVudHM7XG4gICAgICAgIHZhciBzdGFydCA9IG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQ7XG4gICAgICAgIHZhciBuZXh0SXRlbSA9IG1lYXN1cmVtZW50cy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnN0YXJ0LnRvcCAtIHN0YXJ0LnRvcCA+IENPTVBBUkVfRVBTSUxPTjsgfSk7XG4gICAgICAgIGlmICghbmV4dEl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dEluZGV4ID0gbmV4dEl0ZW0uaW5kZXg7XG4gICAgICAgIHN3aXRjaCAodmlld01vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlOlxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IG5leHRJbmRleCAlIDIgPT09IDAgPyBuZXh0SW5kZXggOiBuZXh0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyOlxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IG5leHRJbmRleCAlIDIgPT09IDEgPyBuZXh0SW5kZXggOiBuZXh0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY3JvbGxUb0l0ZW0obmV4dEluZGV4LCBvZmZzZXQpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2Nyb2xsVG9CaWdnZXN0SXRlbUJlbG93ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCkge1xuICAgICAgICB2YXIgbWVhc3VyZW1lbnRzID0gbGF0ZXN0UmVmLmN1cnJlbnQubWVhc3VyZW1lbnRzO1xuICAgICAgICB2YXIgc3RhcnQgPSBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gbnVtYmVyT2ZJdGVtcyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQudG9wIC0gbWVhc3VyZW1lbnRzW2ldLnN0YXJ0LnRvcCA+IENPTVBBUkVfRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggPSBtZWFzdXJlbWVudHNbaV0uaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmlld01vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlOlxuICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IHByZXZJbmRleCAlIDIgPT09IDAgPyBwcmV2SW5kZXggOiBwcmV2SW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyOlxuICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IHByZXZJbmRleCAlIDIgPT09IDAgPyBwcmV2SW5kZXggLSAxIDogcHJldkluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjcm9sbFRvSXRlbShwcmV2SW5kZXgsIG9mZnNldCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxUb05leHRJdGVtID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCkge1xuICAgICAgICBpZiAodmlld01vZGVSZWYuY3VycmVudCA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3ZlciB8fCB2aWV3TW9kZVJlZi5jdXJyZW50ID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9TbWFsbGVzdEl0ZW1BYm92ZShpbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHNjcm9sbE1vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuV3JhcHBlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9TbWFsbGVzdEl0ZW1BYm92ZShpbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbFRvSXRlbShpbmRleCArIDEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbFRvUHJldmlvdXNJdGVtID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCkge1xuICAgICAgICBpZiAodmlld01vZGVSZWYuY3VycmVudCA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3ZlciB8fCB2aWV3TW9kZVJlZi5jdXJyZW50ID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9CaWdnZXN0SXRlbUJlbG93KGluZGV4LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2Nyb2xsTW9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5XcmFwcGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb0JpZ2dlc3RJdGVtQmVsb3coaW5kZXgsIG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWw6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb0l0ZW0oaW5kZXggLSAxLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBnZXRDb250YWluZXJTdHlsZXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1aWxkQ29udGFpbmVyU3R5bGVzKHRvdGFsU2l6ZSwgc2Nyb2xsTW9kZVJlZi5jdXJyZW50KTsgfSwgW3RvdGFsU2l6ZV0pO1xuICAgIHZhciBnZXRJdGVtQ29udGFpbmVyU3R5bGVzID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYnVpbGRJdGVtQ29udGFpbmVyU3R5bGVzKGl0ZW0sIHBhcmVudFJlY3QsIHNjcm9sbE1vZGVSZWYuY3VycmVudCk7IH0sIFtwYXJlbnRSZWN0XSk7XG4gICAgdmFyIGdldEl0ZW1TdHlsZXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBidWlsZEl0ZW1TdHlsZXMoaXRlbSwgaXNSdGwsIHNpemVzLCB2aWV3TW9kZVJlZi5jdXJyZW50LCBzY3JvbGxNb2RlUmVmLmN1cnJlbnQpOyB9LCBbaXNSdGwsIHNpemVzXSk7XG4gICAgdmFyIHpvb20gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzY2FsZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gbGF0ZXN0UmVmLmN1cnJlbnQsIG1lYXN1cmVtZW50cyA9IF9hLm1lYXN1cmVtZW50cywgc2Nyb2xsT2Zmc2V0ID0gX2Euc2Nyb2xsT2Zmc2V0O1xuICAgICAgICB2YXIgbm9ybWFsaXplZEluZGV4ID0gY2xhbXAoMCwgbnVtYmVyT2ZJdGVtcyAtIDEsIGluZGV4KTtcbiAgICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW25vcm1hbGl6ZWRJbmRleF07XG4gICAgICAgIGlmIChtZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZU9mZnNldCA9IHNjcm9sbE1vZGVSZWYuY3VycmVudCA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2VcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWVhc3VyZW1lbnQuc3RhcnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBtZWFzdXJlbWVudC5zdGFydC50b3AsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzY3JvbGxPZmZzZXQubGVmdCAqIHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNjcm9sbE9mZnNldC50b3AgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNjcm9sbFRvKHVwZGF0ZU9mZnNldCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uVHJhY2tlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdDogcGFyZW50UmVjdCxcbiAgICAgICAgaXNTbW9vdGhTY3JvbGxpbmc6IGlzU21vb3RoU2Nyb2xsaW5nLFxuICAgICAgICBzdGFydFBhZ2U6IHN0YXJ0UGFnZSxcbiAgICAgICAgZW5kUGFnZTogZW5kUGFnZSxcbiAgICAgICAgbWF4VmlzYmlsaXR5SW5kZXg6IG1heFZpc2JpbGl0eUluZGV4LFxuICAgICAgICB2aXJ0dWFsSXRlbXM6IHZpcnR1YWxJdGVtcyxcbiAgICAgICAgZ2V0Q29udGFpbmVyU3R5bGVzOiBnZXRDb250YWluZXJTdHlsZXMsXG4gICAgICAgIGdldEl0ZW1Db250YWluZXJTdHlsZXM6IGdldEl0ZW1Db250YWluZXJTdHlsZXMsXG4gICAgICAgIGdldEl0ZW1TdHlsZXM6IGdldEl0ZW1TdHlsZXMsXG4gICAgICAgIHNjcm9sbFRvSXRlbTogc2Nyb2xsVG9JdGVtLFxuICAgICAgICBzY3JvbGxUb05leHRJdGVtOiBzY3JvbGxUb05leHRJdGVtLFxuICAgICAgICBzY3JvbGxUb1ByZXZpb3VzSXRlbTogc2Nyb2xsVG9QcmV2aW91c0l0ZW0sXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgfTtcbn07XG5cbnZhciBTQ1JPTExfQkFSX1dJRFRIID0gMTc7XG52YXIgUEFHRV9QQURESU5HID0gODtcbnZhciBjYWxjdWxhdGVTY2FsZSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHBhZ2VIZWlnaHQsIHBhZ2VXaWR0aCwgc2NhbGUsIHZpZXdNb2RlLCBudW1QYWdlcykge1xuICAgIHZhciB3ID0gcGFnZVdpZHRoO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyICYmIG51bVBhZ2VzID49IDM6XG4gICAgICAgIGNhc2Ugdmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2UgJiYgbnVtUGFnZXMgPj0gMzpcbiAgICAgICAgICAgIHcgPSAyICogcGFnZVdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB3ID0gcGFnZVdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoc2NhbGUpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwuQWN0dWFsU2l6ZTpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlIGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlRml0OlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKChjb250YWluZXIuY2xpZW50V2lkdGggLSBTQ1JPTExfQkFSX1dJRFRIKSAvIHcsIChjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gMiAqIFBBR0VfUEFERElORykgLyBwYWdlSGVpZ2h0KTtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwuUGFnZVdpZHRoOlxuICAgICAgICAgICAgcmV0dXJuIChjb250YWluZXIuY2xpZW50V2lkdGggLSBTQ1JPTExfQkFSX1dJRFRIKSAvIHc7XG4gICAgfVxufTtcblxudmFyIHVzZVN0YWNrID0gZnVuY3Rpb24gKG1heExlbmd0aCkge1xuICAgIHZhciBzdGFja1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKFtdKTtcbiAgICB2YXIgbWFwID0gZnVuY3Rpb24gKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiBzdGFja1JlZi5jdXJyZW50Lm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHJhbnNmb3JtZXIoaXRlbSk7IH0pO1xuICAgIH07XG4gICAgdmFyIHBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHNpemUgPSBzdGFjay5sZW5ndGg7XG4gICAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdEl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2tSZWYuY3VycmVudCA9IHN0YWNrO1xuICAgICAgICByZXR1cm4gbGFzdEl0ZW07XG4gICAgfTtcbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHN0YWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggKyAxID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goaXRlbSk7XG4gICAgICAgIHN0YWNrUmVmLmN1cnJlbnQgPSBzdGFjaztcbiAgICB9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVzaDogcHVzaCxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHBvcDogcG9wLFxuICAgIH07XG59O1xuXG52YXIgdXNlUXVldWUgPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgdmFyIHF1ZXVlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoW10pO1xuICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVldWUgPSBxdWV1ZVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgc2l6ZSA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdEl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBxdWV1ZVJlZi5jdXJyZW50ID0gcXVldWU7XG4gICAgICAgIHJldHVybiBmaXJzdEl0ZW0gfHwgbnVsbDtcbiAgICB9O1xuICAgIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gcXVldWVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCArIDEgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlUmVmLmN1cnJlbnQgPSBbaXRlbV0uY29uY2F0KHF1ZXVlKTtcbiAgICB9O1xuICAgIHZhciBtYXAgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlUmVmLmN1cnJlbnQubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiB0cmFuc2Zvcm1lcihpdGVtKTsgfSk7XG4gICAgfTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBxdWV1ZVJlZi5jdXJyZW50ID0gW107XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlcXVldWU6IGRlcXVldWUsXG4gICAgICAgIGVucXVldWU6IGVucXVldWUsXG4gICAgICAgIG1hcDogbWFwLFxuICAgIH07XG59O1xuXG52YXIgTUFYX1FVRVVFX0xFTkdUSCA9IDUwO1xudmFyIHVzZURlc3RpbmF0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGdldEN1cnJlbnRQYWdlID0gX2EuZ2V0Q3VycmVudFBhZ2U7XG4gICAgdmFyIHByZXZpb3VzRGVzdGluYXRpb25zID0gdXNlU3RhY2soTUFYX1FVRVVFX0xFTkdUSCk7XG4gICAgdmFyIG5leHREZXN0aW5hdGlvbnMgPSB1c2VRdWV1ZShNQVhfUVVFVUVfTEVOR1RIKTtcbiAgICB2YXIgZ2V0TmV4dERlc3RpbmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dERlc3QgPSBuZXh0RGVzdGluYXRpb25zLmRlcXVldWUoKTtcbiAgICAgICAgaWYgKG5leHREZXN0KSB7XG4gICAgICAgICAgICBwcmV2aW91c0Rlc3RpbmF0aW9ucy5wdXNoKG5leHREZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dERlc3QgJiYgbmV4dERlc3QucGFnZUluZGV4ID09PSBnZXRDdXJyZW50UGFnZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dERlc3RpbmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHREZXN0O1xuICAgIH07XG4gICAgdmFyIGdldFByZXZpb3VzRGVzdGluYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2RGVzdCA9IHByZXZpb3VzRGVzdGluYXRpb25zLnBvcCgpO1xuICAgICAgICBpZiAocHJldkRlc3QpIHtcbiAgICAgICAgICAgIG5leHREZXN0aW5hdGlvbnMuZW5xdWV1ZShwcmV2RGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZEZXN0ICYmIHByZXZEZXN0LnBhZ2VJbmRleCA9PT0gZ2V0Q3VycmVudFBhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFByZXZpb3VzRGVzdGluYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldkRlc3Q7XG4gICAgfTtcbiAgICB2YXIgbWFya1Zpc2l0ZWREZXN0aW5hdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHByZXZpb3VzRGVzdGluYXRpb25zLnB1c2goZGVzdGluYXRpb24pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXROZXh0RGVzdGluYXRpb246IGdldE5leHREZXN0aW5hdGlvbixcbiAgICAgICAgZ2V0UHJldmlvdXNEZXN0aW5hdGlvbjogZ2V0UHJldmlvdXNEZXN0aW5hdGlvbixcbiAgICAgICAgbWFya1Zpc2l0ZWREZXN0aW5hdGlvbjogbWFya1Zpc2l0ZWREZXN0aW5hdGlvbixcbiAgICB9O1xufTtcblxudmFyIGZsYXRlcm5TaW5nbGVPdXRsaW5lID0gZnVuY3Rpb24gKG91dGxpbmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKG91dGxpbmUuaXRlbXMgJiYgb3V0bGluZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdGVybk91dGxpbmVzKG91dGxpbmUuaXRlbXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZmxhdGVybk91dGxpbmVzID0gZnVuY3Rpb24gKG91dGxpbmVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG91dGxpbmVzLm1hcChmdW5jdGlvbiAob3V0bGluZSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KG91dGxpbmUpLmNvbmNhdChmbGF0ZXJuU2luZ2xlT3V0bGluZShvdXRsaW5lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgdXNlT3V0bGluZXMgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICAgIHZhciBfYSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoW10pLCBvdXRsaW5lcyA9IF9hWzBdLCBzZXRPdXRsaW5lcyA9IF9hWzFdO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jLmdldE91dGxpbmUoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBmbGF0ZXJuT3V0bGluZXMocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBzZXRPdXRsaW5lcyhpdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gb3V0bGluZXM7XG59O1xuXG52YXIgUkVTSVpFX0VWRU5UX09QVElPTlMgPSB7XG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgcGFzc2l2ZTogdHJ1ZSxcbn07XG52YXIgWkVST19SRUNUJDEgPSB7XG4gICAgaGVpZ2h0OiAwLFxuICAgIHdpZHRoOiAwLFxufTtcbnZhciB1c2VXaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShaRVJPX1JFQ1QkMSksIHdpbmRvd1JlY3QgPSBfYVswXSwgc2V0V2luZG93UmVjdCA9IF9hWzFdO1xuICAgIHZhciBoYW5kbGVSZXNpemUgPSB1c2VEZWJvdW5jZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0V2luZG93UmVjdCh7XG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgfSk7XG4gICAgfSwgMTAwKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSwgUkVTSVpFX0VWRU5UX09QVElPTlMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSwgUkVTSVpFX0VWRU5UX09QVElPTlMpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gd2luZG93UmVjdDtcbn07XG5cbnZhciBaRVJPX1JFQ1QgPSB7XG4gICAgaGVpZ2h0OiAwLFxuICAgIHdpZHRoOiAwLFxufTtcbnZhciB1c2VGdWxsU2NyZWVuID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGdldEN1cnJlbnRQYWdlID0gX2EuZ2V0Q3VycmVudFBhZ2UsIGdldEN1cnJlbnRTY3JvbGxNb2RlID0gX2EuZ2V0Q3VycmVudFNjcm9sbE1vZGUsIGp1bXBUb1BhZ2UgPSBfYS5qdW1wVG9QYWdlLCB0YXJnZXRSZWYgPSBfYS50YXJnZXRSZWY7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLk5vcm1hbCksIGZ1bGxTY3JlZW5Nb2RlID0gX2JbMF0sIHNldEZ1bGxTY3JlZW5Nb2RlID0gX2JbMV07XG4gICAgdmFyIHdpbmRvd1JlY3QgPSB1c2VXaW5kb3dSZXNpemUoKTtcbiAgICB2YXIgX2MgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFpFUk9fUkVDVCksIHRhcmdldFJlY3QgPSBfY1swXSwgc2V0VGFyZ2V0UmVjdCA9IF9jWzFdO1xuICAgIHZhciB3aW5kb3dTaXplQmVmb3JlRnVsbFNjcmVlblJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKFpFUk9fUkVDVCk7XG4gICAgdmFyIHRhcmdldFBhZ2VSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihnZXRDdXJyZW50UGFnZSgpKTtcbiAgICB2YXIgZnVsbFNjcmVlblNpemVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihaRVJPX1JFQ1QpO1xuICAgIHZhciBfZCA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUodGFyZ2V0UmVmLmN1cnJlbnQpLCBlbGVtZW50ID0gX2RbMF0sIHNldEVsZW1lbnQgPSBfZFsxXTtcbiAgICB2YXIgZnVsbFNjcmVlbkVsZW1lbnRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGFyZ2V0UmVmLmN1cnJlbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNldEVsZW1lbnQodGFyZ2V0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbnRyeS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGhlaWdodCA9IF9hLmhlaWdodCwgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgICAgICAgICBzZXRUYXJnZXRSZWN0KHsgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlvLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIHZhciBjbG9zZU90aGVyRnVsbFNjcmVlbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgY3VycmVudEZ1bGxTY3JlZW5FbGUgPSBnZXRGdWxsU2NyZWVuRWxlbWVudCgpO1xuICAgICAgICBpZiAoY3VycmVudEZ1bGxTY3JlZW5FbGUgJiYgY3VycmVudEZ1bGxTY3JlZW5FbGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5Ob3JtYWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXRGdWxsU2NyZWVuKGN1cnJlbnRGdWxsU2NyZWVuRWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBlbnRlckZ1bGxTY3JlZW5Nb2RlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICFpc0Z1bGxTY3JlZW5FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRFbGVtZW50KHRhcmdldCk7XG4gICAgICAgIGNsb3NlT3RoZXJGdWxsU2NyZWVuKHRhcmdldCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdWxsU2NyZWVuRWxlbWVudFJlZi5jdXJyZW50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmluZyk7XG4gICAgICAgICAgICByZXF1ZXN0RnVsbFNjcmVlbih0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGV4aXRGdWxsU2NyZWVuTW9kZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudEZ1bGxTY3JlZW5FbGUgPSBnZXRGdWxsU2NyZWVuRWxlbWVudCgpO1xuICAgICAgICBpZiAoY3VycmVudEZ1bGxTY3JlZW5FbGUpIHtcbiAgICAgICAgICAgIHNldEZ1bGxTY3JlZW5Nb2RlKGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRXhpdHRpbmcpO1xuICAgICAgICAgICAgZXhpdEZ1bGxTY3JlZW4oZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBoYW5kbGVGdWxsU2NyZWVuQ2hhbmdlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50RnVsbFNjcmVlbkVsZSA9IGdldEZ1bGxTY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbFNjcmVlbkVsZSAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FeGl0dGluZyk7XG4gICAgICAgIH1cbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChmdWxsU2NyZWVuTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyaW5nOlxuICAgICAgICAgICAgICAgIGlmIChmdWxsU2NyZWVuRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTY3JlZW5FbGVtZW50UmVmLmN1cnJlbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgICAgICAgICAgICAgICAgICAgICd2YXIoLS1ycHYtY29yZV9fZnVsbC1zY3JlZW4tdGFyZ2V0LWJhY2tncm91bmQtY29sb3IpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0UGFnZVJlZi5jdXJyZW50ID0gZ2V0Q3VycmVudFBhZ2UoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3dTaXplQmVmb3JlRnVsbFNjcmVlblJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJlZDpcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q3VycmVudFNjcm9sbE1vZGUoKSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAganVtcFRvUGFnZSh0YXJnZXRQYWdlUmVmLmN1cnJlbnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkQ29tcGxldGVseSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkQ29tcGxldGVseSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkV4aXR0aW5nOlxuICAgICAgICAgICAgICAgIGlmIChmdWxsU2NyZWVuRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTY3JlZW5FbGVtZW50UmVmLmN1cnJlbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTY3JlZW5FbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRQYWdlUmVmLmN1cnJlbnQgPSBnZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkV4aXRlZDpcbiAgICAgICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLk5vcm1hbCk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEN1cnJlbnRTY3JvbGxNb2RlKCkgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGp1bXBUb1BhZ2UodGFyZ2V0UGFnZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LCBbZnVsbFNjcmVlbk1vZGVdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5Ob3JtYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJpbmcgJiZcbiAgICAgICAgICAgIHdpbmRvd1JlY3QuaGVpZ2h0ID09PSB0YXJnZXRSZWN0LmhlaWdodCAmJlxuICAgICAgICAgICAgd2luZG93UmVjdC53aWR0aCA9PT0gdGFyZ2V0UmVjdC53aWR0aCAmJlxuICAgICAgICAgICAgd2luZG93UmVjdC5oZWlnaHQgPiAwICYmXG4gICAgICAgICAgICB3aW5kb3dSZWN0LndpZHRoID4gMCAmJlxuICAgICAgICAgICAgKGZ1bGxTY3JlZW5TaXplUmVmLmN1cnJlbnQuaGVpZ2h0ID09PSAwIHx8IHdpbmRvd1JlY3QuaGVpZ2h0ID09IGZ1bGxTY3JlZW5TaXplUmVmLmN1cnJlbnQuaGVpZ2h0KSkge1xuICAgICAgICAgICAgZnVsbFNjcmVlblNpemVSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRXhpdHRpbmcgJiZcbiAgICAgICAgICAgIHdpbmRvd1NpemVCZWZvcmVGdWxsU2NyZWVuUmVmLmN1cnJlbnQuaGVpZ2h0ID09PSB3aW5kb3dSZWN0LmhlaWdodCAmJlxuICAgICAgICAgICAgd2luZG93U2l6ZUJlZm9yZUZ1bGxTY3JlZW5SZWYuY3VycmVudC53aWR0aCA9PT0gd2luZG93UmVjdC53aWR0aCAmJlxuICAgICAgICAgICAgd2luZG93UmVjdC5oZWlnaHQgPiAwICYmXG4gICAgICAgICAgICB3aW5kb3dSZWN0LndpZHRoID4gMCkge1xuICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FeGl0ZWQpO1xuICAgICAgICB9XG4gICAgfSwgW2Z1bGxTY3JlZW5Nb2RlLCB3aW5kb3dSZWN0LCB0YXJnZXRSZWN0XSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRGdWxsU2NyZWVuQ2hhbmdlTGlzdGVuZXIoaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1vdmVGdWxsU2NyZWVuQ2hhbmdlTGlzdGVuZXIoaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfSwgW2VsZW1lbnRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRlckZ1bGxTY3JlZW5Nb2RlOiBlbnRlckZ1bGxTY3JlZW5Nb2RlLFxuICAgICAgICBleGl0RnVsbFNjcmVlbk1vZGU6IGV4aXRGdWxsU2NyZWVuTW9kZSxcbiAgICAgICAgZnVsbFNjcmVlbk1vZGU6IGZ1bGxTY3JlZW5Nb2RlLFxuICAgIH07XG59O1xuXG52YXIgREVGQVVMVF9QQUdFX0xBWU9VVCA9IHtcbiAgICBidWlsZFBhZ2VTdHlsZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7fSk7IH0sXG4gICAgdHJhbnNmb3JtU2l6ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBzaXplID0gX2Euc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfSxcbn07XG52YXIgWkVST19PRkZTRVQgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIElubmVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGN1cnJlbnRGaWxlID0gX2EuY3VycmVudEZpbGUsIGRlZmF1bHRTY2FsZSA9IF9hLmRlZmF1bHRTY2FsZSwgZG9jID0gX2EuZG9jLCBlbmFibGVTbW9vdGhTY3JvbGwgPSBfYS5lbmFibGVTbW9vdGhTY3JvbGwsIGluaXRpYWxQYWdlID0gX2EuaW5pdGlhbFBhZ2UsIGluaXRpYWxSb3RhdGlvbiA9IF9hLmluaXRpYWxSb3RhdGlvbiwgaW5pdGlhbFNjYWxlID0gX2EuaW5pdGlhbFNjYWxlLCBwYWdlTGF5b3V0ID0gX2EucGFnZUxheW91dCwgcGFnZVNpemVzID0gX2EucGFnZVNpemVzLCBwbHVnaW5zID0gX2EucGx1Z2lucywgcmVuZGVyUGFnZSA9IF9hLnJlbmRlclBhZ2UsIHNjcm9sbE1vZGUgPSBfYS5zY3JvbGxNb2RlLCBzZXRSZW5kZXJSYW5nZSA9IF9hLnNldFJlbmRlclJhbmdlLCB2aWV3TW9kZSA9IF9hLnZpZXdNb2RlLCB2aWV3ZXJTdGF0ZSA9IF9hLnZpZXdlclN0YXRlLCBvbkRvY3VtZW50TG9hZCA9IF9hLm9uRG9jdW1lbnRMb2FkLCBvbk9wZW5GaWxlID0gX2Eub25PcGVuRmlsZSwgb25QYWdlQ2hhbmdlID0gX2Eub25QYWdlQ2hhbmdlLCBvblJvdGF0ZSA9IF9hLm9uUm90YXRlLCBvblJvdGF0ZVBhZ2UgPSBfYS5vblJvdGF0ZVBhZ2UsIG9uWm9vbSA9IF9hLm9uWm9vbTtcbiAgICB2YXIgbnVtUGFnZXMgPSBkb2MubnVtUGFnZXM7XG4gICAgdmFyIGRvY0lkID0gZG9jLmxvYWRpbmdUYXNrLmRvY0lkO1xuICAgIHZhciBsMTBuID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KExvY2FsaXphdGlvbkNvbnRleHQpLmwxMG47XG4gICAgdmFyIHRoZW1lQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICAgIHZhciBpc1J0bCA9IHRoZW1lQ29udGV4dC5kaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgcGFnZXNSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBfYiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoaW5pdGlhbFBhZ2UpLCBjdXJyZW50UGFnZSA9IF9iWzBdLCBzZXRDdXJyZW50UGFnZSA9IF9iWzFdO1xuICAgIHZhciBtb3N0UmVjZW50VmlzaXRlZFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG51bGwpO1xuICAgIHZhciBkZXN0aW5hdGlvbk1hbmFnZXIgPSB1c2VEZXN0aW5hdGlvbih7XG4gICAgICAgIGdldEN1cnJlbnRQYWdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDsgfSxcbiAgICB9KTtcbiAgICB2YXIgX2MgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGluaXRpYWxSb3RhdGlvbiksIHJvdGF0aW9uID0gX2NbMF0sIHNldFJvdGF0aW9uID0gX2NbMV07XG4gICAgdmFyIHByZXZpb3VzUm90YXRpb24gPSB1c2VQcmV2aW91cyhyb3RhdGlvbik7XG4gICAgdmFyIF9kID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIHBhZ2VzUm90YXRpb25DaGFuZ2VkID0gX2RbMF0sIHNldFBhZ2VzUm90YXRpb25DaGFuZ2VkID0gX2RbMV07XG4gICAgdmFyIF9lID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShuZXcgTWFwKCkpLCBwYWdlc1JvdGF0aW9uID0gX2VbMF0sIHNldFBhZ2VzUm90YXRpb24gPSBfZVsxXTtcbiAgICB2YXIgX2YgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHNjcm9sbE1vZGUpLCBjdXJyZW50U2Nyb2xsTW9kZSA9IF9mWzBdLCBzZXRDdXJyZW50U2Nyb2xsTW9kZSA9IF9mWzFdO1xuICAgIHZhciBwcmV2aW91c1Njcm9sbE1vZGUgPSB1c2VQcmV2aW91cyhjdXJyZW50U2Nyb2xsTW9kZSk7XG4gICAgdmFyIF9nID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh2aWV3TW9kZSksIGN1cnJlbnRWaWV3TW9kZSA9IF9nWzBdLCBzZXRDdXJyZW50Vmlld01vZGUgPSBfZ1sxXTtcbiAgICB2YXIgcHJldmlvdXNWaWV3TW9kZSA9IHVzZVByZXZpb3VzKGN1cnJlbnRWaWV3TW9kZSk7XG4gICAgdmFyIG91dGxpbmVzID0gdXNlT3V0bGluZXMoZG9jKTtcbiAgICB2YXIgX2ggPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGluaXRpYWxTY2FsZSksIHNjYWxlID0gX2hbMF0sIHNldFNjYWxlID0gX2hbMV07XG4gICAgdmFyIHByZXZpb3VzU2NhbGUgPSB1c2VQcmV2aW91cyhzY2FsZSk7XG4gICAgdmFyIHN0YXRlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYodmlld2VyU3RhdGUpO1xuICAgIHZhciBrZWVwU3BlY2lhbFpvb21MZXZlbFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHR5cGVvZiBkZWZhdWx0U2NhbGUgPT09ICdzdHJpbmcnID8gZGVmYXVsdFNjYWxlIDogbnVsbCk7XG4gICAgdmFyIGZvcmNlVGFyZ2V0RnVsbFNjcmVlblJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKC0xKTtcbiAgICB2YXIgZm9yY2VUYXJnZXRab29tUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoLTEpO1xuICAgIHZhciBmb3JjZVRhcmdldEluaXRpYWxQYWdlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoaW5pdGlhbFBhZ2UpO1xuICAgIHZhciBmdWxsU2NyZWVuID0gdXNlRnVsbFNjcmVlbih7XG4gICAgICAgIGdldEN1cnJlbnRQYWdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDsgfSxcbiAgICAgICAgZ2V0Q3VycmVudFNjcm9sbE1vZGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlUmVmLmN1cnJlbnQuc2Nyb2xsTW9kZTsgfSxcbiAgICAgICAganVtcFRvUGFnZTogZnVuY3Rpb24gKHBhZ2VJbmRleCkgeyByZXR1cm4ganVtcFRvUGFnZShwYWdlSW5kZXgpOyB9LFxuICAgICAgICB0YXJnZXRSZWY6IHBhZ2VzUmVmLFxuICAgIH0pO1xuICAgIHZhciBfaiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoLTEpLCByZW5kZXJQYWdlSW5kZXggPSBfalswXSwgc2V0UmVuZGVyUGFnZUluZGV4ID0gX2pbMV07XG4gICAgdmFyIF9rID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgwKSwgcmVuZGVyUXVldWVLZXkgPSBfa1swXSwgc2V0UmVuZGVyUXVldWVLZXkgPSBfa1sxXTtcbiAgICB2YXIgcmVuZGVyUXVldWUgPSB1c2VSZW5kZXJRdWV1ZSh7IGRvYzogZG9jIH0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyUGFnZXNDYWNoZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtkb2NJZF0pO1xuICAgIHZhciBsYXlvdXRCdWlsZGVyID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUEFHRV9MQVlPVVQsIHBhZ2VMYXlvdXQpOyB9LCBbXSk7XG4gICAgdmFyIHNpemVzID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KG51bVBhZ2VzKVxuICAgICAgICAgICAgLmZpbGwoMClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF8sIHBhZ2VJbmRleCkge1xuICAgICAgICAgICAgdmFyIHBhZ2VTaXplID0gW3BhZ2VTaXplc1twYWdlSW5kZXhdLnBhZ2VIZWlnaHQsIHBhZ2VTaXplc1twYWdlSW5kZXhdLnBhZ2VXaWR0aF07XG4gICAgICAgICAgICB2YXIgcmVjdCA9IE1hdGguYWJzKHJvdGF0aW9uKSAlIDE4MCA9PT0gMFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhZ2VTaXplWzBdLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcGFnZVNpemVbMV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhZ2VTaXplWzFdLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcGFnZVNpemVbMF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwYWdlUmVjdCA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0QnVpbGRlci50cmFuc2Zvcm1TaXplKHsgbnVtUGFnZXM6IG51bVBhZ2VzLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgc2l6ZTogcGFnZVJlY3QgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtyb3RhdGlvbiwgc2NhbGVdKTtcbiAgICB2YXIgdmlydHVhbGl6ZXIgPSB1c2VWaXJ0dWFsKHtcbiAgICAgICAgZW5hYmxlU21vb3RoU2Nyb2xsOiBlbmFibGVTbW9vdGhTY3JvbGwsXG4gICAgICAgIGlzUnRsOiBpc1J0bCxcbiAgICAgICAgbnVtYmVyT2ZJdGVtczogbnVtUGFnZXMsXG4gICAgICAgIHBhcmVudFJlZjogcGFnZXNSZWYsXG4gICAgICAgIHNjcm9sbE1vZGU6IGN1cnJlbnRTY3JvbGxNb2RlLFxuICAgICAgICBzZXRSZW5kZXJSYW5nZTogc2V0UmVuZGVyUmFuZ2UsXG4gICAgICAgIHNpemVzOiBzaXplcyxcbiAgICAgICAgdmlld01vZGU6IGN1cnJlbnRWaWV3TW9kZSxcbiAgICB9KTtcbiAgICB2YXIgaGFuZGxlUGFnZXNSZXNpemUgPSB1c2VEZWJvdW5jZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFrZWVwU3BlY2lhbFpvb21MZXZlbFJlZi5jdXJyZW50IHx8XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LmZ1bGxTY3JlZW5Nb2RlICE9PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLk5vcm1hbCB8fFxuICAgICAgICAgICAgKGluaXRpYWxQYWdlID4gMCAmJiBmb3JjZVRhcmdldEluaXRpYWxQYWdlUmVmLmN1cnJlbnQgPT09IGluaXRpYWxQYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHpvb20oa2VlcFNwZWNpYWxab29tTGV2ZWxSZWYuY3VycmVudCk7XG4gICAgfSwgMjAwKTtcbiAgICB1c2VUcmFja1Jlc2l6ZSh7XG4gICAgICAgIHRhcmdldFJlZjogcGFnZXNSZWYsXG4gICAgICAgIG9uUmVzaXplOiBoYW5kbGVQYWdlc1Jlc2l6ZSxcbiAgICB9KTtcbiAgICB2YXIgc2V0Vmlld2VyU3RhdGUgPSBmdW5jdGlvbiAodmlld2VyU3RhdGUpIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gdmlld2VyU3RhdGU7XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLm9uVmlld2VyU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHBsdWdpbi5vblZpZXdlclN0YXRlQ2hhbmdlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBuZXdTdGF0ZTtcbiAgICB9O1xuICAgIHZhciBnZXRQYWdlc0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhZ2VzUmVmLmN1cnJlbnQ7IH07XG4gICAgdmFyIGdldFZpZXdlclN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGVSZWYuY3VycmVudDsgfTtcbiAgICB2YXIgaGFuZGxlSnVtcEZyb21MaW5rQW5ub3RhdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uTWFuYWdlci5tYXJrVmlzaXRlZERlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGhhbmRsZUp1bXBUb0Rlc3RpbmF0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIHBhZ2VJbmRleCA9IGRlc3RpbmF0aW9uLnBhZ2VJbmRleCwgYm90dG9tT2Zmc2V0ID0gZGVzdGluYXRpb24uYm90dG9tT2Zmc2V0LCBsZWZ0T2Zmc2V0ID0gZGVzdGluYXRpb24ubGVmdE9mZnNldCwgc2NhbGVUbyA9IGRlc3RpbmF0aW9uLnNjYWxlVG87XG4gICAgICAgIHZhciBwYWdlc0NvbnRhaW5lciA9IHBhZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXBhZ2VzQ29udGFpbmVyIHx8ICFjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIF8pIHtcbiAgICAgICAgICAgIGdldFBhZ2UoZG9jLCBwYWdlSW5kZXgpLnRoZW4oZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9ICh0eXBlb2YgYm90dG9tT2Zmc2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gYm90dG9tT2Zmc2V0KHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIDogYm90dG9tT2Zmc2V0KSB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gKHR5cGVvZiBsZWZ0T2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gbGVmdE9mZnNldCh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KSA6IGxlZnRPZmZzZXQpIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVNjYWxlID0gY3VycmVudFN0YXRlLnNjYWxlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NhbGVUbykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlRml0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgem9vbShleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwuUGFnZUZpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwuUGFnZVdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2NhbGUgPSBjYWxjdWxhdGVTY2FsZShwYWdlc0NvbnRhaW5lciwgcGFnZVNpemVzW3BhZ2VJbmRleF0ucGFnZUhlaWdodCwgcGFnZVNpemVzW3BhZ2VJbmRleF0ucGFnZVdpZHRoLCBleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwuUGFnZVdpZHRoLCB2aWV3TW9kZSwgbnVtUGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gKHZpZXdwb3J0LmhlaWdodCAtIGJvdHRvbSkgKiB1cGRhdGVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0ICogdXBkYXRlU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tKHVwZGF0ZVNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gKHZpZXdwb3J0LmhlaWdodCAtIGJvdHRvbSkgKiB1cGRhdGVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0ICogdXBkYXRlU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50U3RhdGUuc2Nyb2xsTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlydHVhbGl6ZXIuc2Nyb2xsVG9JdGVtKHBhZ2VJbmRleCwgeyBsZWZ0OiBsZWZ0LCB0b3A6IDAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWw6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsaXplci5zY3JvbGxUb0l0ZW0ocGFnZUluZGV4LCB7IGxlZnQ6IDAsIHRvcDogdG9wIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICB2YXIganVtcFRvRGVzdGluYXRpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgICBkZXN0aW5hdGlvbk1hbmFnZXIubWFya1Zpc2l0ZWREZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICAgIHJldHVybiBoYW5kbGVKdW1wVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgfSwgW10pO1xuICAgIHZhciBqdW1wVG9OZXh0RGVzdGluYXRpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHREZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uTWFuYWdlci5nZXROZXh0RGVzdGluYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIG5leHREZXN0aW5hdGlvbiA/IGhhbmRsZUp1bXBUb0Rlc3RpbmF0aW9uKG5leHREZXN0aW5hdGlvbikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGp1bXBUb1ByZXZpb3VzRGVzdGluYXRpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3REZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uTWFuYWdlci5nZXRQcmV2aW91c0Rlc3RpbmF0aW9uKCk7XG4gICAgICAgIHJldHVybiBsYXN0RGVzdGluYXRpb24gPyBoYW5kbGVKdW1wVG9EZXN0aW5hdGlvbihsYXN0RGVzdGluYXRpb24pIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBqdW1wVG9OZXh0UGFnZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlydHVhbGl6ZXIuc2Nyb2xsVG9OZXh0SXRlbShzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleCwgWkVST19PRkZTRVQpOyB9LCBbXSk7XG4gICAgdmFyIGp1bXBUb1BhZ2UgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDAgPD0gcGFnZUluZGV4ICYmIHBhZ2VJbmRleCA8IG51bVBhZ2VzXG4gICAgICAgICAgICA/IHZpcnR1YWxpemVyLnNjcm9sbFRvSXRlbShwYWdlSW5kZXgsIFpFUk9fT0ZGU0VUKVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGp1bXBUb1ByZXZpb3VzUGFnZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlydHVhbGl6ZXIuc2Nyb2xsVG9QcmV2aW91c0l0ZW0oc3RhdGVSZWYuY3VycmVudC5wYWdlSW5kZXgsIFpFUk9fT0ZGU0VUKTsgfSwgW10pO1xuICAgIHZhciBvcGVuRmlsZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgaWYgKGdldEZpbGVFeHQoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpICE9PSAncGRmJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShieXRlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBvbk9wZW5GaWxlKGZpbGUubmFtZSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtvbk9wZW5GaWxlXSk7XG4gICAgdmFyIHJvdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZGVncmVlcyA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5Sb3RhdGVEaXJlY3Rpb24uQmFja3dhcmQgPyAtOTAgOiA5MDtcbiAgICAgICAgdmFyIGN1cnJlbnRSb3RhdGlvbiA9IHN0YXRlUmVmLmN1cnJlbnQucm90YXRpb247XG4gICAgICAgIHZhciB1cGRhdGVSb3RhdGlvbiA9IGN1cnJlbnRSb3RhdGlvbiA9PT0gMzYwIHx8IGN1cnJlbnRSb3RhdGlvbiA9PT0gLTM2MCA/IGRlZ3JlZXMgOiBjdXJyZW50Um90YXRpb24gKyBkZWdyZWVzO1xuICAgICAgICByZW5kZXJRdWV1ZS5tYXJrTm90UmVuZGVyZWQoKTtcbiAgICAgICAgc2V0Um90YXRpb24odXBkYXRlUm90YXRpb24pO1xuICAgICAgICBzZXRWaWV3ZXJTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGVSZWYuY3VycmVudCksIHsgcm90YXRpb246IHVwZGF0ZVJvdGF0aW9uIH0pKTtcbiAgICAgICAgb25Sb3RhdGUoeyBkaXJlY3Rpb246IGRpcmVjdGlvbiwgZG9jOiBkb2MsIHJvdGF0aW9uOiB1cGRhdGVSb3RhdGlvbiB9KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJvdGF0ZVBhZ2UgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlSW5kZXgsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZGVncmVlcyA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5Sb3RhdGVEaXJlY3Rpb24uQmFja3dhcmQgPyAtOTAgOiA5MDtcbiAgICAgICAgdmFyIHJvdGF0aW9ucyA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZXNSb3RhdGlvbjtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlUm90YXRpb24gPSByb3RhdGlvbnMuaGFzKHBhZ2VJbmRleCkgPyByb3RhdGlvbnMuZ2V0KHBhZ2VJbmRleCkgOiBpbml0aWFsUm90YXRpb247XG4gICAgICAgIHZhciBmaW5hbFJvdGF0aW9uID0gY3VycmVudFBhZ2VSb3RhdGlvbiArIGRlZ3JlZXM7XG4gICAgICAgIHZhciB1cGRhdGVSb3RhdGlvbnMgPSByb3RhdGlvbnMuc2V0KHBhZ2VJbmRleCwgZmluYWxSb3RhdGlvbik7XG4gICAgICAgIHNldFBhZ2VzUm90YXRpb24odXBkYXRlUm90YXRpb25zKTtcbiAgICAgICAgc2V0UGFnZXNSb3RhdGlvbkNoYW5nZWQoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhdmFsdWU7IH0pO1xuICAgICAgICBzZXRWaWV3ZXJTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGVSZWYuY3VycmVudCksIHsgcGFnZXNSb3RhdGlvbjogdXBkYXRlUm90YXRpb25zLCByb3RhdGVkUGFnZTogcGFnZUluZGV4IH0pKTtcbiAgICAgICAgb25Sb3RhdGVQYWdlKHsgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGRvYzogZG9jLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgcm90YXRpb246IGZpbmFsUm90YXRpb24gfSk7XG4gICAgICAgIHJlbmRlclF1ZXVlLm1hcmtSZW5kZXJpbmcocGFnZUluZGV4KTtcbiAgICAgICAgc2V0UmVuZGVyUGFnZUluZGV4KHBhZ2VJbmRleCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzd2l0Y2hTY3JvbGxNb2RlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoc2Nyb2xsTW9kZSkge1xuICAgICAgICBzZXRWaWV3ZXJTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGVSZWYuY3VycmVudCksIHsgc2Nyb2xsTW9kZTogc2Nyb2xsTW9kZSB9KSk7XG4gICAgICAgIHNldEN1cnJlbnRTY3JvbGxNb2RlKHNjcm9sbE1vZGUpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc3dpdGNoVmlld01vZGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2aWV3TW9kZSkge1xuICAgICAgICBzZXRWaWV3ZXJTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGVSZWYuY3VycmVudCksIHsgdmlld01vZGU6IHZpZXdNb2RlIH0pKTtcbiAgICAgICAgc2V0Q3VycmVudFZpZXdNb2RlKHZpZXdNb2RlKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHpvb20gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuZXdTY2FsZSkge1xuICAgICAgICB2YXIgcGFnZXNFbGUgPSBwYWdlc1JlZi5jdXJyZW50O1xuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDtcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlIDwgMCB8fCBjdXJyZW50UGFnZSA+PSBudW1QYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50UGFnZUhlaWdodCA9IHBhZ2VTaXplc1tjdXJyZW50UGFnZV0ucGFnZUhlaWdodDtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlV2lkdGggPSBwYWdlU2l6ZXNbY3VycmVudFBhZ2VdLnBhZ2VXaWR0aDtcbiAgICAgICAgdmFyIHVwZGF0ZVNjYWxlID0gcGFnZXNFbGVcbiAgICAgICAgICAgID8gdHlwZW9mIG5ld1NjYWxlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gY2FsY3VsYXRlU2NhbGUocGFnZXNFbGUsIGN1cnJlbnRQYWdlSGVpZ2h0LCBjdXJyZW50UGFnZVdpZHRoLCBuZXdTY2FsZSwgc3RhdGVSZWYuY3VycmVudC52aWV3TW9kZSwgbnVtUGFnZXMpXG4gICAgICAgICAgICAgICAgOiBuZXdTY2FsZVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICBrZWVwU3BlY2lhbFpvb21MZXZlbFJlZi5jdXJyZW50ID0gdHlwZW9mIG5ld1NjYWxlID09PSAnc3RyaW5nJyA/IG5ld1NjYWxlIDogbnVsbDtcbiAgICAgICAgaWYgKHVwZGF0ZVNjYWxlID09PSBzdGF0ZVJlZi5jdXJyZW50LnNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVuZGVyUXVldWVLZXkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ICsgMTsgfSk7XG4gICAgICAgIHJlbmRlclF1ZXVlLm1hcmtOb3RSZW5kZXJlZCgpO1xuICAgICAgICBzZXRTY2FsZSh1cGRhdGVTY2FsZSk7XG4gICAgICAgIG9uWm9vbSh7IGRvYzogZG9jLCBzY2FsZTogdXBkYXRlU2NhbGUgfSk7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyBzY2FsZTogdXBkYXRlU2NhbGUgfSkpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgZW50ZXJGdWxsU2NyZWVuTW9kZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBmdWxsU2NyZWVuLmVudGVyRnVsbFNjcmVlbk1vZGUodGFyZ2V0KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGV4aXRGdWxsU2NyZWVuTW9kZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBmdWxsU2NyZWVuLmV4aXRGdWxsU2NyZWVuTW9kZSgpO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyBmdWxsU2NyZWVuTW9kZTogZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSB9KSk7XG4gICAgfSwgW2Z1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGVdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwbHVnaW5NZXRob2RzID0ge1xuICAgICAgICAgICAgZW50ZXJGdWxsU2NyZWVuTW9kZTogZW50ZXJGdWxsU2NyZWVuTW9kZSxcbiAgICAgICAgICAgIGV4aXRGdWxsU2NyZWVuTW9kZTogZXhpdEZ1bGxTY3JlZW5Nb2RlLFxuICAgICAgICAgICAgZ2V0UGFnZXNDb250YWluZXI6IGdldFBhZ2VzQ29udGFpbmVyLFxuICAgICAgICAgICAgZ2V0Vmlld2VyU3RhdGU6IGdldFZpZXdlclN0YXRlLFxuICAgICAgICAgICAganVtcFRvRGVzdGluYXRpb246IGp1bXBUb0Rlc3RpbmF0aW9uLFxuICAgICAgICAgICAganVtcFRvTmV4dERlc3RpbmF0aW9uOiBqdW1wVG9OZXh0RGVzdGluYXRpb24sXG4gICAgICAgICAgICBqdW1wVG9QcmV2aW91c0Rlc3RpbmF0aW9uOiBqdW1wVG9QcmV2aW91c0Rlc3RpbmF0aW9uLFxuICAgICAgICAgICAganVtcFRvTmV4dFBhZ2U6IGp1bXBUb05leHRQYWdlLFxuICAgICAgICAgICAganVtcFRvUHJldmlvdXNQYWdlOiBqdW1wVG9QcmV2aW91c1BhZ2UsXG4gICAgICAgICAgICBqdW1wVG9QYWdlOiBqdW1wVG9QYWdlLFxuICAgICAgICAgICAgb3BlbkZpbGU6IG9wZW5GaWxlLFxuICAgICAgICAgICAgcm90YXRlOiByb3RhdGUsXG4gICAgICAgICAgICByb3RhdGVQYWdlOiByb3RhdGVQYWdlLFxuICAgICAgICAgICAgc2V0Vmlld2VyU3RhdGU6IHNldFZpZXdlclN0YXRlLFxuICAgICAgICAgICAgc3dpdGNoU2Nyb2xsTW9kZTogc3dpdGNoU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHN3aXRjaFZpZXdNb2RlOiBzd2l0Y2hWaWV3TW9kZSxcbiAgICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIH07XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChwbHVnaW5NZXRob2RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4udW5pbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi51bmluc3RhbGwocGx1Z2luTWV0aG9kcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW2RvY0lkXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkRvY3VtZW50TG9hZCh7IGRvYzogZG9jLCBmaWxlOiBjdXJyZW50RmlsZSB9KTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIHBsdWdpbi5vbkRvY3VtZW50TG9hZCAmJiBwbHVnaW4ub25Eb2N1bWVudExvYWQoeyBkb2M6IGRvYywgZmlsZTogY3VycmVudEZpbGUgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtkb2NJZF0pO1xuICAgIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSB2aXJ0dWFsaXplci5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gICAgdXNlUnVuT25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbml0aWFsUGFnZSkge1xuICAgICAgICAgICAganVtcFRvUGFnZShpbml0aWFsUGFnZSk7XG4gICAgICAgIH1cbiAgICB9LCBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0ID4gMCAmJiBib3VuZGluZ0NsaWVudFJlY3Qud2lkdGggPiAwKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhdGVzdFBhZ2UgPSBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDtcbiAgICAgICAgaWYgKGxhdGVzdFBhZ2UgPiAtMSAmJiBwcmV2aW91c1Njcm9sbE1vZGUgIT09IGN1cnJlbnRTY3JvbGxNb2RlKSB7XG4gICAgICAgICAgICB2aXJ0dWFsaXplci5zY3JvbGxUb0l0ZW0obGF0ZXN0UGFnZSwgWkVST19PRkZTRVQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlID09PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWRDb21wbGV0ZWx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5hYmxlU21vb3RoU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJRdWV1ZS5tYXJrTm90UmVuZGVyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVRhcmdldEZ1bGxTY3JlZW5SZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRTY3JvbGxNb2RlXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXRlc3RQYWdlID0gc3RhdGVSZWYuY3VycmVudC5wYWdlSW5kZXg7XG4gICAgICAgIGlmIChsYXRlc3RQYWdlID4gLTEgJiYgcHJldmlvdXNSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyLnNjcm9sbFRvSXRlbShsYXRlc3RQYWdlLCBaRVJPX09GRlNFVCk7XG4gICAgICAgIH1cbiAgICB9LCBbcm90YXRpb25dKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzU2NhbGUgIT0gMCAmJiBwcmV2aW91c1NjYWxlICE9IHN0YXRlUmVmLmN1cnJlbnQuc2NhbGUpIHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyLnpvb20oc3RhdGVSZWYuY3VycmVudC5zY2FsZSAvIHByZXZpb3VzU2NhbGUsIHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkQ29tcGxldGVseSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVRhcmdldFpvb21SZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW3NjYWxlXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1ZpZXdNb2RlID09PSBzdGF0ZVJlZi5jdXJyZW50LnZpZXdNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IHZpcnR1YWxpemVyLnN0YXJ0UGFnZSwgZW5kUGFnZSA9IHZpcnR1YWxpemVyLmVuZFBhZ2UsIHZpcnR1YWxJdGVtcyA9IHZpcnR1YWxpemVyLnZpcnR1YWxJdGVtcztcbiAgICAgICAgcmVuZGVyUXVldWUubWFya05vdFJlbmRlcmVkKCk7XG4gICAgICAgIHJlbmRlclF1ZXVlLnNldFJhbmdlKHN0YXJ0UGFnZSwgZW5kUGFnZSk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdmlydHVhbEl0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaW5kZXggPT09IGk7IH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJRdWV1ZS5zZXRWaXNpYmlsaXR5KGksIGl0ZW0udmlzaWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydFBhZ2U7IGkgPD0gZW5kUGFnZTsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlck5leHRQYWdlKCk7XG4gICAgfSwgW2N1cnJlbnRWaWV3TW9kZV0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGF0ZXN0UGFnZSA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4O1xuICAgICAgICBpZiAobGF0ZXN0UGFnZSA+IC0xICYmIHByZXZpb3VzVmlld01vZGUgIT09IGN1cnJlbnRWaWV3TW9kZSkge1xuICAgICAgICAgICAgdmlydHVhbGl6ZXIuc2Nyb2xsVG9JdGVtKGxhdGVzdFBhZ2UsIFpFUk9fT0ZGU0VUKTtcbiAgICAgICAgfVxuICAgIH0sIFtjdXJyZW50Vmlld01vZGVdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhdGVzdFBhZ2UgPSBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDtcbiAgICAgICAgaWYgKGxhdGVzdFBhZ2UgPiAwICYmXG4gICAgICAgICAgICBsYXRlc3RQYWdlID09PSBpbml0aWFsUGFnZSAmJlxuICAgICAgICAgICAgZm9yY2VUYXJnZXRJbml0aWFsUGFnZVJlZi5jdXJyZW50ID09PSBpbml0aWFsUGFnZSAmJlxuICAgICAgICAgICAga2VlcFNwZWNpYWxab29tTGV2ZWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZm9yY2VUYXJnZXRJbml0aWFsUGFnZVJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgICB6b29tKGtlZXBTcGVjaWFsWm9vbUxldmVsUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRQYWdlXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNTbW9vdGhTY3JvbGxpbmcgPSB2aXJ0dWFsaXplci5pc1Ntb290aFNjcm9sbGluZztcbiAgICAgICAgaWYgKGlzU21vb3RoU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vc3RSZWNlbnRWaXNpdGVkUmVmLmN1cnJlbnQgPT09IG51bGwgfHwgbW9zdFJlY2VudFZpc2l0ZWRSZWYuY3VycmVudCAhPT0gY3VycmVudFBhZ2UpIHtcbiAgICAgICAgICAgIG1vc3RSZWNlbnRWaXNpdGVkUmVmLmN1cnJlbnQgPSBjdXJyZW50UGFnZTtcbiAgICAgICAgICAgIG9uUGFnZUNoYW5nZSh7IGN1cnJlbnRQYWdlOiBjdXJyZW50UGFnZSwgZG9jOiBkb2MgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFBhZ2UsIHZpcnR1YWxpemVyLmlzU21vb3RoU2Nyb2xsaW5nXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmluZyAmJiBzdGF0ZVJlZi5jdXJyZW50LnNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlKSB7XG4gICAgICAgICAgICBmb3JjZVRhcmdldEZ1bGxTY3JlZW5SZWYuY3VycmVudCA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlID09PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWRDb21wbGV0ZWx5ICYmXG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LnNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlICYmXG4gICAgICAgICAgICBlbmFibGVTbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgICAgIGZvcmNlVGFyZ2V0RnVsbFNjcmVlblJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJlZENvbXBsZXRlbHkgJiYga2VlcFNwZWNpYWxab29tTGV2ZWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZm9yY2VUYXJnZXRab29tUmVmLmN1cnJlbnQgPSBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDtcbiAgICAgICAgICAgIHpvb20oa2VlcFNwZWNpYWxab29tTGV2ZWxSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBbZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJpbmcgfHxcbiAgICAgICAgICAgIGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRXhpdHRpbmcgfHxcbiAgICAgICAgICAgIHZpcnR1YWxpemVyLmlzU21vb3RoU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IHZpcnR1YWxpemVyLnN0YXJ0UGFnZSwgZW5kUGFnZSA9IHZpcnR1YWxpemVyLmVuZFBhZ2UsIG1heFZpc2JpbGl0eUluZGV4ID0gdmlydHVhbGl6ZXIubWF4VmlzYmlsaXR5SW5kZXgsIHZpcnR1YWxJdGVtcyA9IHZpcnR1YWxpemVyLnZpcnR1YWxJdGVtcztcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlID0gbWF4VmlzYmlsaXR5SW5kZXg7XG4gICAgICAgIHZhciBpc0Z1bGxTY3JlZW4gPSBmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlID09PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWQgfHxcbiAgICAgICAgICAgIGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJlZENvbXBsZXRlbHk7XG4gICAgICAgIGlmIChpc0Z1bGxTY3JlZW4gJiYgY3VycmVudFBhZ2UgIT09IGZvcmNlVGFyZ2V0RnVsbFNjcmVlblJlZi5jdXJyZW50ICYmIGZvcmNlVGFyZ2V0RnVsbFNjcmVlblJlZi5jdXJyZW50ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdWxsU2NyZWVuICYmIGN1cnJlbnRQYWdlICE9PSBmb3JjZVRhcmdldFpvb21SZWYuY3VycmVudCAmJiBmb3JjZVRhcmdldFpvb21SZWYuY3VycmVudCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q3VycmVudFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgICAgICBzZXRWaWV3ZXJTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGVSZWYuY3VycmVudCksIHsgcGFnZUluZGV4OiBjdXJyZW50UGFnZSB9KSk7XG4gICAgICAgIHJlbmRlclF1ZXVlLnNldFJhbmdlKHN0YXJ0UGFnZSwgZW5kUGFnZSk7XG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdmlydHVhbEl0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaW5kZXggPT09IGk7IH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJRdWV1ZS5zZXRWaXNpYmlsaXR5KGksIGl0ZW0udmlzaWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydFBhZ2U7IGkgPD0gZW5kUGFnZTsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8yKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlck5leHRQYWdlKCk7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplci5zdGFydFBhZ2UsXG4gICAgICAgIHZpcnR1YWxpemVyLmVuZFBhZ2UsXG4gICAgICAgIHZpcnR1YWxpemVyLmlzU21vb3RoU2Nyb2xsaW5nLFxuICAgICAgICB2aXJ0dWFsaXplci5tYXhWaXNiaWxpdHlJbmRleCxcbiAgICAgICAgZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSxcbiAgICAgICAgcGFnZXNSb3RhdGlvbkNoYW5nZWQsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBzY2FsZSxcbiAgICBdKTtcbiAgICB2YXIgaGFuZGxlUGFnZVJlbmRlckNvbXBsZXRlZCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgICByZW5kZXJRdWV1ZS5tYXJrUmVuZGVyZWQocGFnZUluZGV4KTtcbiAgICAgICAgcmVuZGVyTmV4dFBhZ2UoKTtcbiAgICB9LCBbcmVuZGVyUXVldWVLZXldKTtcbiAgICB2YXIgcmVuZGVyTmV4dFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UGFnZSA9IHJlbmRlclF1ZXVlLmdldEhpZ2hlc3RQcmlvcml0eVBhZ2UoKTtcbiAgICAgICAgaWYgKG5leHRQYWdlID4gLTEgJiYgcmVuZGVyUXVldWUuaXNJblJhbmdlKG5leHRQYWdlKSkge1xuICAgICAgICAgICAgcmVuZGVyUXVldWUubWFya1JlbmRlcmluZyhuZXh0UGFnZSk7XG4gICAgICAgICAgICBzZXRSZW5kZXJQYWdlSW5kZXgobmV4dFBhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZXhlY3V0ZU5hbWVkQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgcHJldmlvdXNQYWdlID0gY3VycmVudFBhZ2UgLSAxO1xuICAgICAgICB2YXIgbmV4dFBhZ2UgPSBjdXJyZW50UGFnZSArIDE7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdGaXJzdFBhZ2UnOlxuICAgICAgICAgICAgICAgIGp1bXBUb1BhZ2UoMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMYXN0UGFnZSc6XG4gICAgICAgICAgICAgICAganVtcFRvUGFnZShudW1QYWdlcyAtIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTmV4dFBhZ2UnOlxuICAgICAgICAgICAgICAgIG5leHRQYWdlIDwgbnVtUGFnZXMgJiYganVtcFRvUGFnZShuZXh0UGFnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQcmV2UGFnZSc6XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQYWdlID49IDAgJiYganVtcFRvUGFnZShwcmV2aW91c1BhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVuZGVyVmlld2VyID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2aXJ0dWFsSXRlbXMgPSB2aXJ0dWFsaXplci52aXJ0dWFsSXRlbXM7XG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Vmlld01vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZTpcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBjaHVuayh2aXJ0dWFsSXRlbXMsIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyOlxuICAgICAgICAgICAgICAgIGlmICh2aXJ0dWFsSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsSXRlbXNbMF0uaW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtbdmlydHVhbEl0ZW1zWzBdXV0uY29uY2F0KGNodW5rKHZpcnR1YWxJdGVtcy5zbGljZSgxKSwgMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaHVuayh2aXJ0dWFsSXRlbXMsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5WaWV3TW9kZS5TaW5nbGVQYWdlOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBjaHVuayh2aXJ0dWFsSXRlbXMsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWdlTGFiZWwgPSBsMTBuICYmIGwxMG4uY29yZSA/IGwxMG4uY29yZS5wYWdlTGFiZWwgOiAnUGFnZSB7e3BhZ2VJbmRleH19JztcbiAgICAgICAgdmFyIHNsb3QgPSB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3Jwdi1jb3JlX19pbm5lci1jb250YWluZXInLFxuICAgICAgICAgICAgICAgICdkYXRhLXRlc3RpZCc6ICdjb3JlX19pbm5lci1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsKSxcbiAgICAgICAgICAgIHN1YlNsb3Q6IHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAnZGF0YS10ZXN0aWQnOiAnY29yZV9faW5uZXItcGFnZXMnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2VzLS1ob3Jpem9udGFsJzogY3VycmVudFNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5Ib3Jpem9udGFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlcy0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2VzLS1zaW5nbGUnOiBjdXJyZW50U2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2VzLS12ZXJ0aWNhbCc6IGN1cnJlbnRTY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2VzLS13cmFwcGVkJzogY3VycmVudFNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5XcmFwcGVkLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBwYWdlc1JlZixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJjb3JlX19pbm5lci1jdXJyZW50LXBhZ2UtXCIuY29uY2F0KGN1cnJlbnRQYWdlKSwgc3R5bGU6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgJy0tc2NhbGUtZmFjdG9yJzogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHZpcnR1YWxpemVyLmdldENvbnRhaW5lclN0eWxlcygpKSB9LCBjaHVua3MubWFwKGZ1bmN0aW9uIChpdGVtcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2UtY29udGFpbmVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZS1jb250YWluZXItLXNpbmdsZSc6IGN1cnJlbnRTY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIHN0eWxlOiB2aXJ0dWFsaXplci5nZXRJdGVtQ29udGFpbmVyU3R5bGVzKGl0ZW1zWzBdKSwga2V5OiBcIlwiLmNvbmNhdChpdGVtc1swXS5pbmRleCwgXCItXCIpLmNvbmNhdChjdXJyZW50Vmlld01vZGUpIH0sIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb3ZlciA9IGN1cnJlbnRWaWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3ZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGl0ZW0uaW5kZXggPT09IDAgfHwgKG51bVBhZ2VzICUgMiA9PT0gMCAmJiBpdGVtLmluZGV4ID09PSBudW1QYWdlcyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxcIjogcGFnZUxhYmVsLnJlcGxhY2UoJ3t7cGFnZUluZGV4fX0nLCBcIlwiLmNvbmNhdChpdGVtLmluZGV4ICsgMSkpLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlLS1kdWFsLWV2ZW4nOiBjdXJyZW50Vmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2UgJiYgaXRlbS5pbmRleCAlIDIgPT09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlLS1kdWFsLW9kZCc6IGN1cnJlbnRWaWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZSAmJiBpdGVtLmluZGV4ICUgMiA9PT0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2UtLWR1YWwtY292ZXInOiBpc0NvdmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZS0tZHVhbC1jb3Zlci1ldmVuJzogY3VycmVudFZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc0NvdmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaW5kZXggJSAyID09PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZS0tZHVhbC1jb3Zlci1vZGQnOiBjdXJyZW50Vmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ292ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pbmRleCAlIDIgPT09IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlLS1zaW5nbGUnOiBjdXJyZW50Vmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuU2luZ2xlUGFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgcm9sZTogXCJyZWdpb25cIiwga2V5OiBcIlwiLmNvbmNhdChpdGVtLmluZGV4LCBcIi1cIikuY29uY2F0KGN1cnJlbnRWaWV3TW9kZSksIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCB2aXJ0dWFsaXplci5nZXRJdGVtU3R5bGVzKGl0ZW0pLCBsYXlvdXRCdWlsZGVyLmJ1aWxkUGFnZVN0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGFnZXM6IG51bVBhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogaXRlbS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxNb2RlOiBjdXJyZW50U2Nyb2xsTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogY3VycmVudFZpZXdNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUGFnZUxheWVyLCB7IGRvYzogZG9jLCBtZWFzdXJlUmVmOiBpdGVtLm1lYXN1cmVSZWYsIG91dGxpbmVzOiBvdXRsaW5lcywgcGFnZUluZGV4OiBpdGVtLmluZGV4LCBwYWdlUm90YXRpb246IHBhZ2VzUm90YXRpb24uaGFzKGl0ZW0uaW5kZXgpID8gcGFnZXNSb3RhdGlvbi5nZXQoaXRlbS5pbmRleCkgOiAwLCBwYWdlU2l6ZTogcGFnZVNpemVzW2l0ZW0uaW5kZXhdLCBwbHVnaW5zOiBwbHVnaW5zLCByZW5kZXJQYWdlOiByZW5kZXJQYWdlLCByZW5kZXJRdWV1ZUtleTogcmVuZGVyUXVldWVLZXksIHJvdGF0aW9uOiByb3RhdGlvbiwgc2NhbGU6IHNjYWxlLCBzaG91bGRSZW5kZXI6IHJlbmRlclBhZ2VJbmRleCA9PT0gaXRlbS5pbmRleCwgdmlld01vZGU6IGN1cnJlbnRWaWV3TW9kZSwgb25FeGVjdXRlTmFtZWRBY3Rpb246IGV4ZWN1dGVOYW1lZEFjdGlvbiwgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uOiBoYW5kbGVKdW1wRnJvbUxpbmtBbm5vdGF0aW9uLCBvbkp1bXBUb0Rlc3Q6IGp1bXBUb0Rlc3RpbmF0aW9uLCBvblJlbmRlckNvbXBsZXRlZDogaGFuZGxlUGFnZVJlbmRlckNvbXBsZXRlZCwgb25Sb3RhdGVQYWdlOiByb3RhdGVQYWdlIH0pKSk7XG4gICAgICAgICAgICAgICAgfSkpKTsgfSkpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnJlbmRlclZpZXdlcikge1xuICAgICAgICAgICAgICAgIHNsb3QgPSBwbHVnaW4ucmVuZGVyVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyUmVmOiBjb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgICAgICBwYWdlc0NvbnRhaW5lclJlZjogcGFnZXNSZWYsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VzUm90YXRpb246IHBhZ2VzUm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplczogcGFnZVNpemVzLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNsb3Q6IHNsb3QsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lQ29udGV4dDogdGhlbWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBqdW1wVG9QYWdlOiBqdW1wVG9QYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuRmlsZTogb3BlbkZpbGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogcm90YXRlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGVQYWdlOiByb3RhdGVQYWdlLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hTY3JvbGxNb2RlOiBzd2l0Y2hTY3JvbGxNb2RlLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hWaWV3TW9kZTogc3dpdGNoVmlld01vZGUsXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2xvdDtcbiAgICB9LCBbcGx1Z2lucywgdmlydHVhbGl6ZXJdKTtcbiAgICB2YXIgcmVuZGVyU2xvdCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNsb3QpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHNsb3QuYXR0cnMsIHsgc3R5bGU6IHNsb3QuYXR0cnMgJiYgc2xvdC5hdHRycy5zdHlsZSA/IHNsb3QuYXR0cnMuc3R5bGUgOiB7fSB9KSxcbiAgICAgICAgc2xvdC5jaGlsZHJlbixcbiAgICAgICAgc2xvdC5zdWJTbG90ICYmIHJlbmRlclNsb3Qoc2xvdC5zdWJTbG90KSkpOyB9LCBbXSk7XG4gICAgcmV0dXJuIHJlbmRlclNsb3QocmVuZGVyVmlld2VyKCkpO1xufTtcblxudmFyIExFVkVMUyA9IFtcbiAgICAwLjEsIDAuMiwgMC4zLCAwLjQsIDAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxLCAxLjEsIDEuMywgMS41LCAxLjcsIDEuOSwgMi4xLCAyLjQsIDIuNywgMy4wLCAzLjMsIDMuNywgNC4xLCA0LjYsXG4gICAgNS4xLCA1LjcsIDYuMywgNy4wLCA3LjcsIDguNSwgOS40LCAxMCxcbl07XG52YXIgZGVjcmVhc2UgPSBmdW5jdGlvbiAoY3VycmVudExldmVsKSB7XG4gICAgdmFyIGZvdW5kID0gTEVWRUxTLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSA+PSBjdXJyZW50TGV2ZWw7IH0pO1xuICAgIHJldHVybiBmb3VuZCA9PT0gLTEgfHwgZm91bmQgPT09IDAgPyBjdXJyZW50TGV2ZWwgOiBMRVZFTFNbZm91bmQgLSAxXTtcbn07XG5cbnZhciBSRVNFUlZFX0hFSUdIVCA9IDQ1O1xudmFyIFJFU0VSVkVfV0lEVEggPSA0NTtcbnZhciBQYWdlU2l6ZUNhbGN1bGF0b3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGVmYXVsdFNjYWxlID0gX2EuZGVmYXVsdFNjYWxlLCBkb2MgPSBfYS5kb2MsIHJlbmRlciA9IF9hLnJlbmRlciwgc2Nyb2xsTW9kZSA9IF9hLnNjcm9sbE1vZGUsIHZpZXdNb2RlID0gX2Eudmlld01vZGU7XG4gICAgdmFyIHBhZ2VzUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHtcbiAgICAgICAgcGFnZVNpemVzOiBbXSxcbiAgICAgICAgc2NhbGU6IDAsXG4gICAgfSksIHN0YXRlID0gX2JbMF0sIHNldFN0YXRlID0gX2JbMV07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVlcnlQYWdlU2l6ZXMgPSBBcnJheShkb2MubnVtUGFnZXMpXG4gICAgICAgICAgICAuZmlsbCgwKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCBfKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFnZShkb2MsIGkpLnRoZW4oZnVuY3Rpb24gKHBkZlBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gcGRmUGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VIZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VXaWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBQcm9taXNlLmFsbChxdWVyeVBhZ2VTaXplcykudGhlbihmdW5jdGlvbiAocGFnZVNpemVzKSB7XG4gICAgICAgICAgICB2YXIgcGFnZXNFbGUgPSBwYWdlc1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFwYWdlc0VsZSB8fCBwYWdlU2l6ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHcgPSBwYWdlU2l6ZXNbMF0ucGFnZVdpZHRoO1xuICAgICAgICAgICAgdmFyIGggPSBwYWdlU2l6ZXNbMF0ucGFnZUhlaWdodDtcbiAgICAgICAgICAgIHZhciBwYXJlbnRFbGUgPSBwYWdlc0VsZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlV2lkdGggPSAocGFyZW50RWxlLmNsaWVudFdpZHRoIC0gUkVTRVJWRV9XSURUSCkgLyB3O1xuICAgICAgICAgICAgdmFyIHNjYWxlSGVpZ2h0ID0gKHBhcmVudEVsZS5jbGllbnRIZWlnaHQgLSBSRVNFUlZFX0hFSUdIVCkgLyBoO1xuICAgICAgICAgICAgdmFyIHNjYWxlZCA9IHNjYWxlV2lkdGg7XG4gICAgICAgICAgICBzd2l0Y2ggKHNjcm9sbE1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgICAgICAgICBzY2FsZWQgPSBNYXRoLm1pbihzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLlZlcnRpY2FsOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZCA9IHNjYWxlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gZGVmYXVsdFNjYWxlXG4gICAgICAgICAgICAgICAgPyB0eXBlb2YgZGVmYXVsdFNjYWxlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IGNhbGN1bGF0ZVNjYWxlKHBhcmVudEVsZSwgaCwgdywgZGVmYXVsdFNjYWxlLCB2aWV3TW9kZSwgZG9jLm51bVBhZ2VzKVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRTY2FsZVxuICAgICAgICAgICAgICAgIDogZGVjcmVhc2Uoc2NhbGVkKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgcGFnZVNpemVzOiBwYWdlU2l6ZXMsIHNjYWxlOiBzY2FsZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2RvYy5sb2FkaW5nVGFzay5kb2NJZF0pO1xuICAgIHJldHVybiBzdGF0ZS5wYWdlU2l6ZXMubGVuZ3RoID09PSAwIHx8IHN0YXRlLnNjYWxlID09PSAwID8gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fcGFnZS1zaXplLWNhbGN1bGF0b3JcIiwgXCJkYXRhLXRlc3RpZFwiOiBcImNvcmVfX3BhZ2Utc2l6ZS1jYWxjdWxhdGluZ1wiLCByZWY6IHBhZ2VzUmVmIH0sXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChTcGlubmVyLCBudWxsKSkpIDogKHJlbmRlcihzdGF0ZS5wYWdlU2l6ZXMsIHN0YXRlLnNjYWxlKSk7XG59O1xuXG52YXIgTG9hZGluZ1N0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9hZGluZ1N0YXR1cygpIHtcbiAgICB9XG4gICAgcmV0dXJuIExvYWRpbmdTdGF0dXM7XG59KCkpO1xuXG52YXIgQXNrRm9yUGFzc3dvcmRTdGF0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFza0ZvclBhc3N3b3JkU3RhdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNrRm9yUGFzc3dvcmRTdGF0ZSh2ZXJpZnlQYXNzd29yZCwgcGFzc3dvcmRTdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmVyaWZ5UGFzc3dvcmQgPSB2ZXJpZnlQYXNzd29yZDtcbiAgICAgICAgX3RoaXMucGFzc3dvcmRTdGF0dXMgPSBwYXNzd29yZFN0YXR1cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQXNrRm9yUGFzc3dvcmRTdGF0ZTtcbn0oTG9hZGluZ1N0YXR1cykpO1xuXG52YXIgQXNraW5nUGFzc3dvcmQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcGFzc3dvcmRTdGF0dXMgPSBfYS5wYXNzd29yZFN0YXR1cywgcmVuZGVyUHJvdGVjdGVkVmlldyA9IF9hLnJlbmRlclByb3RlY3RlZFZpZXcsIHZlcmlmeVBhc3N3b3JkID0gX2EudmVyaWZ5UGFzc3dvcmQsIG9uRG9jdW1lbnRBc2tQYXNzd29yZCA9IF9hLm9uRG9jdW1lbnRBc2tQYXNzd29yZDtcbiAgICB2YXIgbDEwbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChMb2NhbGl6YXRpb25Db250ZXh0KS5sMTBuO1xuICAgIHZhciBfYiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoJycpLCBwYXNzd29yZCA9IF9iWzBdLCBzZXRQYXNzd29yZCA9IF9iWzFdO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIHN1Ym1pdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcmlmeVBhc3N3b3JkKHBhc3N3b3JkKTsgfTtcbiAgICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgc3VibWl0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9uRG9jdW1lbnRBc2tQYXNzd29yZCkge1xuICAgICAgICAgICAgb25Eb2N1bWVudEFza1Bhc3N3b3JkKHtcbiAgICAgICAgICAgICAgICB2ZXJpZnlQYXNzd29yZDogdmVyaWZ5UGFzc3dvcmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBpZiAocmVuZGVyUHJvdGVjdGVkVmlldykge1xuICAgICAgICByZXR1cm4gcmVuZGVyUHJvdGVjdGVkVmlldyh7XG4gICAgICAgICAgICBwYXNzd29yZFN0YXR1czogcGFzc3dvcmRTdGF0dXMsXG4gICAgICAgICAgICB2ZXJpZnlQYXNzd29yZDogdmVyaWZ5UGFzc3dvcmQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYXNraW5nLXBhc3N3b3JkLXdyYXBwZXJcIiB9LFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXNraW5nLXBhc3N3b3JkJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fza2luZy1wYXNzd29yZC0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hc2tpbmctcGFzc3dvcmQtbWVzc2FnZVwiIH0sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRTdGF0dXMgPT09IGV4cG9ydHMuUGFzc3dvcmRTdGF0dXMuUmVxdWlyZWRQYXNzd29yZCAmJlxuICAgICAgICAgICAgICAgICAgICBsMTBuLmNvcmUuYXNraW5nUGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXF1aXJlUGFzc3dvcmRUb09wZW4sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRTdGF0dXMgPT09IGV4cG9ydHMuUGFzc3dvcmRTdGF0dXMuV3JvbmdQYXNzd29yZCAmJlxuICAgICAgICAgICAgICAgICAgICBsMTBuLmNvcmUud3JvbmdQYXNzd29yZC50cnlBZ2FpbiksXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fza2luZy1wYXNzd29yZC1ib2R5XCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hc2tpbmctcGFzc3dvcmQtaW5wdXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hc2tpbmctcGFzc3dvcmQtaW5wdXQtLWx0cic6ICFpc1J0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXNraW5nLXBhc3N3b3JkLWlucHV0LS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFRleHRCb3gsIHsgdGVzdElkOiBcImNvcmVfX2Fza2luZy1wYXNzd29yZC1pbnB1dFwiLCB0eXBlOiBcInBhc3N3b3JkXCIsIHZhbHVlOiBwYXNzd29yZCwgb25DaGFuZ2U6IHNldFBhc3N3b3JkLCBvbktleURvd246IGhhbmRsZUtleURvd24gfSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQcmltYXJ5QnV0dG9uLCB7IG9uQ2xpY2s6IHN1Ym1pdCB9LCBsMTBuLmNvcmUuYXNraW5nUGFzc3dvcmQuc3VibWl0KSkpKSk7XG59O1xuXG52YXIgQ29tcGxldGVkU3RhdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wbGV0ZWRTdGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wbGV0ZWRTdGF0ZShkb2MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZG9jID0gZG9jO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21wbGV0ZWRTdGF0ZTtcbn0oTG9hZGluZ1N0YXR1cykpO1xuXG52YXIgRmFpbHVyZVN0YXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmFpbHVyZVN0YXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZhaWx1cmVTdGF0ZShlcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBGYWlsdXJlU3RhdGU7XG59KExvYWRpbmdTdGF0dXMpKTtcblxudmFyIExvYWRpbmdTdGF0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvYWRpbmdTdGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2FkaW5nU3RhdGUocGVyY2VudGFnZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGVyY2VudGFnZXMgPSBwZXJjZW50YWdlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTG9hZGluZ1N0YXRlO1xufShMb2FkaW5nU3RhdHVzKSk7XG5cbnZhciBEb2N1bWVudExvYWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGFyYWN0ZXJNYXAgPSBfYS5jaGFyYWN0ZXJNYXAsIGZpbGUgPSBfYS5maWxlLCBodHRwSGVhZGVycyA9IF9hLmh0dHBIZWFkZXJzLCByZW5kZXIgPSBfYS5yZW5kZXIsIHJlbmRlckVycm9yID0gX2EucmVuZGVyRXJyb3IsIHJlbmRlckxvYWRlciA9IF9hLnJlbmRlckxvYWRlciwgcmVuZGVyUHJvdGVjdGVkVmlldyA9IF9hLnJlbmRlclByb3RlY3RlZFZpZXcsIHRyYW5zZm9ybUdldERvY3VtZW50UGFyYW1zID0gX2EudHJhbnNmb3JtR2V0RG9jdW1lbnRQYXJhbXMsIHdpdGhDcmVkZW50aWFscyA9IF9hLndpdGhDcmVkZW50aWFscywgb25Eb2N1bWVudEFza1Bhc3N3b3JkID0gX2Eub25Eb2N1bWVudEFza1Bhc3N3b3JkO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShuZXcgTG9hZGluZ1N0YXRlKDApKSwgc3RhdHVzID0gX2JbMF0sIHNldFN0YXR1cyA9IF9iWzFdO1xuICAgIHZhciBkb2NSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZignJyk7XG4gICAgdmFyIGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgc2V0U3RhdHVzKG5ldyBMb2FkaW5nU3RhdGUoMCkpO1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFBkZkpzQXBpX19uYW1lc3BhY2UuUERGV29ya2VyKHsgbmFtZTogXCJQREZXb3JrZXJfXCIuY29uY2F0KERhdGUubm93KCkpIH0pO1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBodHRwSGVhZGVyczogaHR0cEhlYWRlcnMsXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgIHdvcmtlcjogd29ya2VyLFxuICAgICAgICB9LCAnc3RyaW5nJyA9PT0gdHlwZW9mIGZpbGUgPyB7IHVybDogZmlsZSB9IDogeyBkYXRhOiBmaWxlIH0sIGNoYXJhY3Rlck1hcFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY01hcFVybDogY2hhcmFjdGVyTWFwLnVybCxcbiAgICAgICAgICAgICAgICBjTWFwUGFja2VkOiBjaGFyYWN0ZXJNYXAuaXNDb21wcmVzc2VkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1QYXJhbXMgPSB0cmFuc2Zvcm1HZXREb2N1bWVudFBhcmFtcyA/IHRyYW5zZm9ybUdldERvY3VtZW50UGFyYW1zKHBhcmFtcykgOiBwYXJhbXM7XG4gICAgICAgIHZhciBsb2FkaW5nVGFzayA9IFBkZkpzQXBpX19uYW1lc3BhY2UuZ2V0RG9jdW1lbnQodHJhbnNmb3JtUGFyYW1zKTtcbiAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCA9IGZ1bmN0aW9uICh2ZXJpZnlQYXNzd29yZCwgcmVhc29uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgUGRmSnNBcGlfX25hbWVzcGFjZS5QYXNzd29yZFJlc3BvbnNlcy5ORUVEX1BBU1NXT1JEOlxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKG5ldyBBc2tGb3JQYXNzd29yZFN0YXRlKHZlcmlmeVBhc3N3b3JkLCBleHBvcnRzLlBhc3N3b3JkU3RhdHVzLlJlcXVpcmVkUGFzc3dvcmQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQZGZKc0FwaV9fbmFtZXNwYWNlLlBhc3N3b3JkUmVzcG9uc2VzLklOQ09SUkVDVF9QQVNTV09SRDpcbiAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhuZXcgQXNrRm9yUGFzc3dvcmRTdGF0ZSh2ZXJpZnlQYXNzd29yZCwgZXhwb3J0cy5QYXNzd29yZFN0YXR1cy5Xcm9uZ1Bhc3N3b3JkKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gcHJvZ3Jlc3MudG90YWwgPiAwXG4gICAgICAgICAgICAgICAgP1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigxMDAsICgxMDAgKiBwcm9ncmVzcy5sb2FkZWQpIC8gcHJvZ3Jlc3MudG90YWwpXG4gICAgICAgICAgICAgICAgOiAxMDA7XG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgJiYgZG9jUmVmLmN1cnJlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKG5ldyBMb2FkaW5nU3RhdGUobG9hZGVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRpbmdUYXNrLnByb21pc2UudGhlbihmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICBkb2NSZWYuY3VycmVudCA9IGRvYy5sb2FkaW5nVGFzay5kb2NJZDtcbiAgICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ICYmIHNldFN0YXR1cyhuZXcgQ29tcGxldGVkU3RhdGUoZG9jKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc01vdW50ZWQuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICF3b3JrZXIuZGVzdHJveWVkICYmXG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKG5ldyBGYWlsdXJlU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSB8fCAnQ2Fubm90IGxvYWQgZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBlcnIubmFtZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICAgICAgICAgICAgd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZmlsZV0pO1xuICAgIGlmIChzdGF0dXMgaW5zdGFuY2VvZiBBc2tGb3JQYXNzd29yZFN0YXRlKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFza2luZ1Bhc3N3b3JkLCB7IHBhc3N3b3JkU3RhdHVzOiBzdGF0dXMucGFzc3dvcmRTdGF0dXMsIHJlbmRlclByb3RlY3RlZFZpZXc6IHJlbmRlclByb3RlY3RlZFZpZXcsIHZlcmlmeVBhc3N3b3JkOiBzdGF0dXMudmVyaWZ5UGFzc3dvcmQsIG9uRG9jdW1lbnRBc2tQYXNzd29yZDogb25Eb2N1bWVudEFza1Bhc3N3b3JkIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyBpbnN0YW5jZW9mIENvbXBsZXRlZFN0YXRlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXIoc3RhdHVzLmRvYyk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgaW5zdGFuY2VvZiBGYWlsdXJlU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckVycm9yID8gKHJlbmRlckVycm9yKHN0YXR1cy5lcnJvcikpIDogKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19kb2MtZXJyb3InOiB0cnVlLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fZG9jLWVycm9yLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2RvYy1lcnJvci10ZXh0XCIgfSwgc3RhdHVzLmVycm9yLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcImNvcmVfX2RvYy1sb2FkaW5nXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX2RvYy1sb2FkaW5nJzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fZG9jLWxvYWRpbmctLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSB9LCByZW5kZXJMb2FkZXIgPyByZW5kZXJMb2FkZXIoc3RhdHVzLnBlcmNlbnRhZ2VzKSA6IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChTcGlubmVyLCBudWxsKSkpO1xufTtcblxudmFyIGlzRGFya01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcztcbn07XG5cbnZhciB3aXRoVGhlbWUgPSBmdW5jdGlvbiAodGhlbWUsIG9uU3dpdGNoVGhlbWUpIHtcbiAgICB2YXIgaW5pdGlhbFRoZW1lID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGVtZSA9PT0gJ2F1dG8nID8gKGlzRGFya01vZGUoKSA/ICdkYXJrJyA6ICdsaWdodCcpIDogdGhlbWUpOyB9LCBbXSk7XG4gICAgdmFyIF9hID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShpbml0aWFsVGhlbWUpLCBjdXJyZW50VGhlbWUgPSBfYVswXSwgc2V0Q3VycmVudFRoZW1lID0gX2FbMV07XG4gICAgdmFyIHByZXZUaGVtZSA9IHVzZVByZXZpb3VzKGN1cnJlbnRUaGVtZSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhlbWUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZWRpYSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUaGVtZShlLm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVyKTsgfTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY3VycmVudFRoZW1lICE9PSBwcmV2VGhlbWUgJiYgb25Td2l0Y2hUaGVtZSkge1xuICAgICAgICAgICAgb25Td2l0Y2hUaGVtZShjdXJyZW50VGhlbWUpO1xuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRUaGVtZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoZW1lICE9PSBjdXJyZW50VGhlbWUpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUaGVtZSh0aGVtZSk7XG4gICAgICAgIH1cbiAgICB9LCBbdGhlbWVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50VGhlbWU6IGN1cnJlbnRUaGVtZSxcbiAgICAgICAgc2V0Q3VycmVudFRoZW1lOiBzZXRDdXJyZW50VGhlbWUsXG4gICAgfTtcbn07XG5cbnZhciBpc1NhbWVVcmwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB0eXBlQSA9IHR5cGVvZiBhO1xuICAgIHZhciB0eXBlQiA9IHR5cGVvZiBiO1xuICAgIGlmICh0eXBlQSA9PT0gJ3N0cmluZycgJiYgdHlwZUIgPT09ICdzdHJpbmcnICYmIGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlQSA9PT0gJ29iamVjdCcgJiYgdHlwZUIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gdiA9PT0gYltpXTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBOVU1fT1ZFUlNDQU5fUEFHRVMgPSAzO1xudmFyIERFRkFVTFRfUkVOREVSX1JBTkdFID0gZnVuY3Rpb24gKHZpc2libGVQYWdlc1JhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRQYWdlOiB2aXNpYmxlUGFnZXNSYW5nZS5zdGFydFBhZ2UgLSBOVU1fT1ZFUlNDQU5fUEFHRVMsXG4gICAgICAgIGVuZFBhZ2U6IHZpc2libGVQYWdlc1JhbmdlLmVuZFBhZ2UgKyBOVU1fT1ZFUlNDQU5fUEFHRVMsXG4gICAgfTtcbn07XG52YXIgVmlld2VyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoYXJhY3Rlck1hcCA9IF9hLmNoYXJhY3Rlck1hcCwgZGVmYXVsdFNjYWxlID0gX2EuZGVmYXVsdFNjYWxlLCBfYiA9IF9hLmVuYWJsZVNtb290aFNjcm9sbCwgZW5hYmxlU21vb3RoU2Nyb2xsID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgZmlsZVVybCA9IF9hLmZpbGVVcmwsIF9jID0gX2EuaHR0cEhlYWRlcnMsIGh0dHBIZWFkZXJzID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2MsIF9kID0gX2EuaW5pdGlhbFBhZ2UsIGluaXRpYWxQYWdlID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgcGFnZUxheW91dCA9IF9hLnBhZ2VMYXlvdXQsIF9lID0gX2EuaW5pdGlhbFJvdGF0aW9uLCBpbml0aWFsUm90YXRpb24gPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lLCBsb2NhbGl6YXRpb24gPSBfYS5sb2NhbGl6YXRpb24sIF9mID0gX2EucGx1Z2lucywgcGx1Z2lucyA9IF9mID09PSB2b2lkIDAgPyBbXSA6IF9mLCByZW5kZXJFcnJvciA9IF9hLnJlbmRlckVycm9yLCByZW5kZXJMb2FkZXIgPSBfYS5yZW5kZXJMb2FkZXIsIHJlbmRlclBhZ2UgPSBfYS5yZW5kZXJQYWdlLCByZW5kZXJQcm90ZWN0ZWRWaWV3ID0gX2EucmVuZGVyUHJvdGVjdGVkVmlldywgX2cgPSBfYS5zY3JvbGxNb2RlLCBzY3JvbGxNb2RlID0gX2cgPT09IHZvaWQgMCA/IGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbCA6IF9nLCBfaCA9IF9hLnNldFJlbmRlclJhbmdlLCBzZXRSZW5kZXJSYW5nZSA9IF9oID09PSB2b2lkIDAgPyBERUZBVUxUX1JFTkRFUl9SQU5HRSA6IF9oLCB0cmFuc2Zvcm1HZXREb2N1bWVudFBhcmFtcyA9IF9hLnRyYW5zZm9ybUdldERvY3VtZW50UGFyYW1zLCBfaiA9IF9hLnRoZW1lLCB0aGVtZSA9IF9qID09PSB2b2lkIDAgPyB7XG4gICAgICAgIGRpcmVjdGlvbjogZXhwb3J0cy5UZXh0RGlyZWN0aW9uLkxlZnRUb1JpZ2h0LFxuICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICB9IDogX2osIF9rID0gX2Eudmlld01vZGUsIHZpZXdNb2RlID0gX2sgPT09IHZvaWQgMCA/IGV4cG9ydHMuVmlld01vZGUuU2luZ2xlUGFnZSA6IF9rLCBfbCA9IF9hLndpdGhDcmVkZW50aWFscywgd2l0aENyZWRlbnRpYWxzID0gX2wgPT09IHZvaWQgMCA/IGZhbHNlIDogX2wsIG9uRG9jdW1lbnRBc2tQYXNzd29yZCA9IF9hLm9uRG9jdW1lbnRBc2tQYXNzd29yZCwgX20gPSBfYS5vbkRvY3VtZW50TG9hZCwgb25Eb2N1bWVudExvYWQgPSBfbSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge1xuICAgIH0gOiBfbSwgX28gPSBfYS5vblBhZ2VDaGFuZ2UsIG9uUGFnZUNoYW5nZSA9IF9vID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7XG4gICAgfSA6IF9vLCBfcCA9IF9hLm9uUm90YXRlLCBvblJvdGF0ZSA9IF9wID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7XG4gICAgfSA6IF9wLCBfcSA9IF9hLm9uUm90YXRlUGFnZSwgb25Sb3RhdGVQYWdlID0gX3EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICB9IDogX3EsIF9yID0gX2Eub25Td2l0Y2hUaGVtZSwgb25Td2l0Y2hUaGVtZSA9IF9yID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7XG4gICAgfSA6IF9yLCBfcyA9IF9hLm9uWm9vbSwgb25ab29tID0gX3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICB9IDogX3M7XG4gICAgdmFyIF90ID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7XG4gICAgICAgIGRhdGE6IGZpbGVVcmwsXG4gICAgICAgIG5hbWU6IHR5cGVvZiBmaWxlVXJsID09PSAnc3RyaW5nJyA/IGZpbGVVcmwgOiAnJyxcbiAgICAgICAgc2hvdWxkTG9hZDogZmFsc2UsXG4gICAgfSksIGZpbGUgPSBfdFswXSwgc2V0RmlsZSA9IF90WzFdO1xuICAgIHZhciBvcGVuRmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSwgZGF0YSkge1xuICAgICAgICBzZXRGaWxlKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIHNob3VsZExvYWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIF91ID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIHZpc2libGUgPSBfdVswXSwgc2V0VmlzaWJsZSA9IF91WzFdO1xuICAgIHZhciBwcmV2RmlsZSA9IHVzZVByZXZpb3VzKGZpbGUpO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1NhbWVVcmwocHJldkZpbGUuZGF0YSwgZmlsZVVybCkpIHtcbiAgICAgICAgICAgIHNldEZpbGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGVVcmwsXG4gICAgICAgICAgICAgICAgbmFtZTogdHlwZW9mIGZpbGVVcmwgPT09ICdzdHJpbmcnID8gZmlsZVVybCA6ICcnLFxuICAgICAgICAgICAgICAgIHNob3VsZExvYWQ6IHZpc2libGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtmaWxlVXJsLCB2aXNpYmxlXSk7XG4gICAgdmFyIHZpc2liaWxpdHlDaGFuZ2VkID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBzZXRWaXNpYmxlKHBhcmFtcy5pc1Zpc2libGUpO1xuICAgICAgICBpZiAocGFyYW1zLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgc2V0RmlsZShmdW5jdGlvbiAoY3VycmVudEZpbGUpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRGaWxlLCB7IHNob3VsZExvYWQ6IHRydWUgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoe1xuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2VkOiB2aXNpYmlsaXR5Q2hhbmdlZCxcbiAgICB9KTtcbiAgICB2YXIgdGhlbWVQcm9wcyA9IHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycgPyB7IGRpcmVjdGlvbjogZXhwb3J0cy5UZXh0RGlyZWN0aW9uLkxlZnRUb1JpZ2h0LCB0aGVtZTogdGhlbWUgfSA6IHRoZW1lO1xuICAgIHZhciBfdiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUobG9jYWxpemF0aW9uIHx8IERlZmF1bHRMb2NhbGl6YXRpb24pLCBsMTBuID0gX3ZbMF0sIHNldEwxMG4gPSBfdlsxXTtcbiAgICB2YXIgbG9jYWxpemF0aW9uQ29udGV4dCA9IHsgbDEwbjogbDEwbiwgc2V0TDEwbjogc2V0TDEwbiB9O1xuICAgIHZhciB0aGVtZUNvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCB7IGRpcmVjdGlvbjogdGhlbWVQcm9wcy5kaXJlY3Rpb24gfSwgd2l0aFRoZW1lKHRoZW1lUHJvcHMudGhlbWUgfHwgJ2xpZ2h0Jywgb25Td2l0Y2hUaGVtZSkpO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvY2FsaXphdGlvbikge1xuICAgICAgICAgICAgc2V0TDEwbihsb2NhbGl6YXRpb24pO1xuICAgICAgICB9XG4gICAgfSwgW2xvY2FsaXphdGlvbl0pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExvY2FsaXphdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGxvY2FsaXphdGlvbkNvbnRleHQgfSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFRoZW1lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhlbWVDb250ZXh0IH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lclJlZiwgY2xhc3NOYW1lOiBcInJwdi1jb3JlX192aWV3ZXIgcnB2LWNvcmVfX3ZpZXdlci0tXCIuY29uY2F0KHRoZW1lQ29udGV4dC5jdXJyZW50VGhlbWUpLCBcImRhdGEtdGVzdGlkXCI6IFwiY29yZV9fdmlld2VyXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIH0gfSwgZmlsZS5zaG91bGRMb2FkICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRG9jdW1lbnRMb2FkZXIsIHsgY2hhcmFjdGVyTWFwOiBjaGFyYWN0ZXJNYXAsIGZpbGU6IGZpbGUuZGF0YSwgaHR0cEhlYWRlcnM6IGh0dHBIZWFkZXJzLCByZW5kZXI6IGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUGFnZVNpemVDYWxjdWxhdG9yLCB7IGRlZmF1bHRTY2FsZTogZGVmYXVsdFNjYWxlLCBkb2M6IGRvYywgcmVuZGVyOiBmdW5jdGlvbiAocGFnZVNpemVzLCBpbml0aWFsU2NhbGUpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSW5uZXIsIHsgY3VycmVudEZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmaWxlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGVmYXVsdFNjYWxlOiBkZWZhdWx0U2NhbGUsIGRvYzogZG9jLCBlbmFibGVTbW9vdGhTY3JvbGw6IGVuYWJsZVNtb290aFNjcm9sbCwgaW5pdGlhbFBhZ2U6IGluaXRpYWxQYWdlLCBpbml0aWFsUm90YXRpb246IGluaXRpYWxSb3RhdGlvbiwgaW5pdGlhbFNjYWxlOiBpbml0aWFsU2NhbGUsIHBhZ2VMYXlvdXQ6IHBhZ2VMYXlvdXQsIHBhZ2VTaXplczogcGFnZVNpemVzLCBwbHVnaW5zOiBwbHVnaW5zLCByZW5kZXJQYWdlOiByZW5kZXJQYWdlLCBzY3JvbGxNb2RlOiBzY3JvbGxNb2RlLCBzZXRSZW5kZXJSYW5nZTogc2V0UmVuZGVyUmFuZ2UsIHZpZXdNb2RlOiB2aWV3TW9kZSwgdmlld2VyU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxTY3JlZW5Nb2RlOiBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLk5vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VIZWlnaHQ6IHBhZ2VTaXplc1swXS5wYWdlSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VXaWR0aDogcGFnZVNpemVzWzBdLnBhZ2VXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlc1JvdGF0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IGluaXRpYWxSb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogaW5pdGlhbFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbE1vZGU6IHNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGU6IHZpZXdNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25Eb2N1bWVudExvYWQ6IG9uRG9jdW1lbnRMb2FkLCBvbk9wZW5GaWxlOiBvcGVuRmlsZSwgb25QYWdlQ2hhbmdlOiBvblBhZ2VDaGFuZ2UsIG9uUm90YXRlOiBvblJvdGF0ZSwgb25Sb3RhdGVQYWdlOiBvblJvdGF0ZVBhZ2UsIG9uWm9vbTogb25ab29tIH0pKTsgfSwgc2Nyb2xsTW9kZTogc2Nyb2xsTW9kZSwgdmlld01vZGU6IHZpZXdNb2RlIH0pKTsgfSwgcmVuZGVyRXJyb3I6IHJlbmRlckVycm9yLCByZW5kZXJMb2FkZXI6IHJlbmRlckxvYWRlciwgcmVuZGVyUHJvdGVjdGVkVmlldzogcmVuZGVyUHJvdGVjdGVkVmlldywgdHJhbnNmb3JtR2V0RG9jdW1lbnRQYXJhbXM6IHRyYW5zZm9ybUdldERvY3VtZW50UGFyYW1zLCB3aXRoQ3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscywgb25Eb2N1bWVudEFza1Bhc3N3b3JkOiBvbkRvY3VtZW50QXNrUGFzc3dvcmQgfSkpKSkpKTtcbn07XG5cbnZhciBXb3JrZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgd29ya2VyVXJsID0gX2Eud29ya2VyVXJsO1xuICAgIFBkZkpzQXBpX19uYW1lc3BhY2UuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSB3b3JrZXJVcmw7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59O1xuXG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbmV4cG9ydHMuSWNvbiA9IEljb247XG5leHBvcnRzLkxhenlSZW5kZXIgPSBMYXp5UmVuZGVyO1xuZXhwb3J0cy5Mb2NhbGl6YXRpb25Db250ZXh0ID0gTG9jYWxpemF0aW9uQ29udGV4dDtcbmV4cG9ydHMuTWVudSA9IE1lbnU7XG5leHBvcnRzLk1lbnVEaXZpZGVyID0gTWVudURpdmlkZXI7XG5leHBvcnRzLk1lbnVJdGVtID0gTWVudUl0ZW07XG5leHBvcnRzLk1pbmltYWxCdXR0b24gPSBNaW5pbWFsQnV0dG9uO1xuZXhwb3J0cy5Nb2RhbCA9IE1vZGFsO1xuZXhwb3J0cy5Qb3BvdmVyID0gUG9wb3ZlcjtcbmV4cG9ydHMuUHJpbWFyeUJ1dHRvbiA9IFByaW1hcnlCdXR0b247XG5leHBvcnRzLlByb2dyZXNzQmFyID0gUHJvZ3Jlc3NCYXI7XG5leHBvcnRzLlNlcGFyYXRvciA9IFNlcGFyYXRvcjtcbmV4cG9ydHMuU3Bpbm5lciA9IFNwaW5uZXI7XG5leHBvcnRzLlNwbGl0dGVyID0gU3BsaXR0ZXI7XG5leHBvcnRzLlRleHRCb3ggPSBUZXh0Qm94O1xuZXhwb3J0cy5UaGVtZUNvbnRleHQgPSBUaGVtZUNvbnRleHQ7XG5leHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuZXhwb3J0cy5WaWV3ZXIgPSBWaWV3ZXI7XG5leHBvcnRzLldvcmtlciA9IFdvcmtlcjtcbmV4cG9ydHMuY2h1bmsgPSBjaHVuaztcbmV4cG9ydHMuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gY3JlYXRlU3RvcmU7XG5leHBvcnRzLmdldERlc3RpbmF0aW9uID0gZ2V0RGVzdGluYXRpb247XG5leHBvcnRzLmdldFBhZ2UgPSBnZXRQYWdlO1xuZXhwb3J0cy5pc0Z1bGxTY3JlZW5FbmFibGVkID0gaXNGdWxsU2NyZWVuRW5hYmxlZDtcbmV4cG9ydHMuaXNNYWMgPSBpc01hYztcbmV4cG9ydHMudXNlRGVib3VuY2VDYWxsYmFjayA9IHVzZURlYm91bmNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUludGVyc2VjdGlvbk9ic2VydmVyID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG5leHBvcnRzLnVzZUlzTW91bnRlZCA9IHVzZUlzTW91bnRlZDtcbmV4cG9ydHMudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZVByZXZpb3VzID0gdXNlUHJldmlvdXM7XG5leHBvcnRzLnVzZVJlbmRlclF1ZXVlID0gdXNlUmVuZGVyUXVldWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-pdf-viewer/core/lib/cjs/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-pdf-viewer/core/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@react-pdf-viewer/core/lib/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A React component to view a PDF document\n *\n * @see https://react-pdf-viewer.dev\n * @license https://react-pdf-viewer.dev/license\n * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/core.js */ \"(ssr)/./node_modules/@react-pdf-viewer/core/lib/cjs/core.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi12aWV3ZXIvY29yZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixJQUFJLHdIQUF5QztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1bW1lcnktYWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi12aWV3ZXIvY29yZS9saWIvaW5kZXguanM/OTliOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRvIHZpZXcgYSBQREYgZG9jdW1lbnRcbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3QtcGRmLXZpZXdlci5kZXZcbiAqIEBsaWNlbnNlIGh0dHBzOi8vcmVhY3QtcGRmLXZpZXdlci5kZXYvbGljZW5zZVxuICogQGNvcHlyaWdodCAyMDE5LTIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvY29yZS5taW4uanMnKTtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9jb3JlLmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-pdf-viewer/core/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-pdf-viewer/core/lib/styles/index.css":
/*!******************************************************************!*\
  !*** ./node_modules/@react-pdf-viewer/core/lib/styles/index.css ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e66f4f3c22e4\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi12aWV3ZXIvY29yZS9saWIvc3R5bGVzL2luZGV4LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1bW1lcnktYWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi12aWV3ZXIvY29yZS9saWIvc3R5bGVzL2luZGV4LmNzcz9mZDBmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZTY2ZjRmM2MyMmU0XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-pdf-viewer/core/lib/styles/index.css\n");

/***/ })

};
;